<html>
<head>
  <title>Java事务及隔离级别</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1129"/>
<h1>Java事务及隔离级别</h1>

<div>
<div><div><h1><span style="color: #000066;"><span style="font-size: 24px;">Java事务</span></span></h1><div><span style="font-size: 18px; color: #000066;"><br clear="none"/> </span></div><p><span style="font-size: 14px;"><strong>1)       说到事务，不得不提的就是ACID特性，再次回顾：</strong></span></p><p><span style="font-size: 14px;">　　Ø  原子性(atomicity)：组成事务处理的语句形成了一个逻辑单元，不能只执行其中的一部分。</span></p><p><span style="font-size: 14px;">　　Ø  一致性(consistency)：在事务处理执行前后，数据库是一致的(数据库数据完整性约束)。</span></p><p><span style="font-size: 14px;">　　Ø  隔离性(isolcation)：一个事务处理对另一个事务处理的影响。 </span></p><p><span style="font-size: 14px;">　　Ø  持续性(durability)：事务处理的效果能够被永久保存下来 。</span></p><p><span style="font-size: 14px;"><strong>2)       然后就是事务在Java中的最基本操作：</strong></span></p><p><span style="font-size: 14px;">　　Ø  connection.setAutoCommit(false);//打开事务。</span></p><p><span style="font-size: 14px;">　　Ø  connection.commit();//提交事务。</span></p><p><span style="font-size: 14px;">　　Ø  connection.rollback();//回滚事务。</span></p><p><span style="font-size: 14px;">　　这里需要提的就是，当只想撤销事务中的部分操作时可使用<strong>SavePoint</strong>：</span></p><p><span style="font-size: 14px;">　　Ø  SavePoint sp = connection.setSavepoint();</span></p><p><span style="font-size: 14px;">　　Ø  connection.rollerbak(sp);connection.commit();</span></p><p><span style="font-size: 14px;"><strong>3)       下面用一个实例代码来展示一下：</strong></span></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/wang379275614/article/details/24818397#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/wang379275614/article/details/24818397#" shape="rect" title="copy">copy</a><a href="https://code.csdn.net/snippets/322723" shape="rect" style="text-indent: 0;" target="_blank" title="在CODE上查看代码片"><img src="Java事务及隔离级别_files/Image.png" type="image/png" alt="在CODE上查看代码片" height="12" style="position: relative; top: 1px; left: 2px;" width="12"/></a><a href="https://code.csdn.net/snippets/322723/fork" shape="rect" style="text-indent: 0;" target="_blank" title="派生到我的代码片"><img alt="派生到我的代码片" height="12" src="https://code.csdn.net/assets/ico_fork.svg" style="position: relative; top: 2px; left: 2px;" width="12"></img></a><div style="position: absolute; left: 585px; top: 854px; width: 18px; height: 18px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>package</span><span> cn.itcast.jdbc;  </span></span></li><li><span>  </span></li><li><span><span>import</span><span> java.sql.Connection;  </span></span></li><li><span><span>import</span><span> java.sql.ResultSet;  </span></span></li><li><span><span>import</span><span> java.sql.SQLException;  </span></span></li><li><span><span>import</span><span> java.sql.Savepoint;  </span></span></li><li><span><span>import</span><span> java.sql.Statement;  </span></span></li><li><span><span>/**</span> </span></li><li><span><span> * 事务测试</span> </span></li><li><span><span> */</span><span>  </span></span></li><li><span><span>public</span><span> </span><span>class</span><span> SavePointTest {  </span></span></li><li><span>  </span></li><li><span>    <span>public</span><span> </span><span>static</span><span> </span><span>void</span><span> main(String[] args) </span><span>throws</span><span> SQLException {  </span></span></li><li><span>        testTransaction();  </span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>static</span><span> </span><span>void</span><span> testTransaction() </span><span>throws</span><span> SQLException {  </span></span></li><li><span>        Connection conn = <span>null</span><span>;  </span></span></li><li><span>        Statement st = <span>null</span><span>;  </span></span></li><li><span>        ResultSet rs = <span>null</span><span>;  </span></span></li><li><span>        Savepoint sp = <span>null</span><span>;  </span></span></li><li><span>        <span>try</span><span> {  </span></span></li><li><span>            <span>//获取Connection（JdbcUtils为自定义的包装类，这里不做解释）</span><span>  </span></span></li><li><span>            conn = JdbcUtils.getConnection();  </span></li><li><span>            <span>//开启事务</span><span>  </span></span></li><li><span>            conn.setAutoCommit(<span>false</span><span>);            </span></span></li><li><span>            st = conn.createStatement();  </span></li><li><span>            <span>//id为1的人的Money减10</span><span>  </span></span></li><li><span>            String sql = <span>&quot;update user set money=money-10 where id=1&quot;</span><span>;  </span></span></li><li><span>            st.executeUpdate(sql);  </span></li><li><span>            <span>//********************回滚界限***************************</span><span>  </span></span></li><li><span>            <span>//设置回滚点（savepoint）</span><span>  </span></span></li><li><span>            sp = conn.setSavepoint();  </span></li><li><span>            <span>//********************回滚界限***************************</span><span>  </span></span></li><li><span>            <span>//id为2的人的Money减10</span><span>  </span></span></li><li><span>            sql = <span>&quot;update user set money=money-10 where id=3&quot;</span><span>;  </span></span></li><li><span>            st.executeUpdate(sql);        </span></li><li><span>            sql = <span>&quot;select money from user where id=2&quot;</span><span>;  </span></span></li><li><span>            rs = st.executeQuery(sql);  </span></li><li><span>            <span>float</span><span> money = </span><span>0</span><span>.0f;  </span></span></li><li><span>            <span>if</span><span> (rs.next()) {  </span></span></li><li><span>                money = rs.getFloat(<span>&quot;money&quot;</span><span>);  </span></span></li><li><span>            }  </span></li><li><span>            <span>if</span><span> (money &gt; </span><span>300</span><span>){  </span></span></li><li><span>                <span>throw</span><span> </span><span>new</span><span> RuntimeException(</span><span>&quot;已经超过最大值！&quot;</span><span>);  </span></span></li><li><span>            }  </span></li><li><span>            <span>//id为2的人的Money加10</span><span>  </span></span></li><li><span>            sql = <span>&quot;update user set money=money+10 where id=2&quot;</span><span>;  </span></span></li><li><span>            st.executeUpdate(sql);  </span></li><li><span>            <span>//提交事务</span><span>  </span></span></li><li><span>            conn.commit();  </span></li><li><span>        } <span>catch</span><span> (RuntimeException e) {  </span></span></li><li><span>            <span>if</span><span> (conn != </span><span>null</span><span> &amp;&amp; sp != </span><span>null</span><span>) {  </span></span></li><li><span>                <span>//回滚事务，注意里面的参数sp即为我们上面设置的savePoint，如果回滚的话只能回滚到savePoint以下的部分</span><span>  </span></span></li><li><span>                <span>//上面的部分不会得到回滚</span><span>  </span></span></li><li><span>                conn.rollback(sp);  </span></li><li><span>                conn.commit();  </span></li><li><span>            }  </span></li><li><span>            <span>throw</span><span> e;  </span></span></li><li><span>        } <span>catch</span><span> (SQLException e) {  </span></span></li><li><span>            <span>if</span><span> (conn != </span><span>null</span><span>)  </span></span></li><li><span>                conn.rollback();  </span></li><li><span>            <span>throw</span><span> e;  </span></span></li><li><span>        } <span>finally</span><span> {  </span></span></li><li><span>            <span>//释放资源（JdbcUtils为自定义类）</span><span>  </span></span></li><li><span>            JdbcUtils.free(rs, st, conn);  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>}  </span></li></ol></div><p><br clear="none"/></p><p><br clear="none"/></p><p><span style="font-size: 14px;">　　上面所有的操作（CRUD）都是在同一个数据源上的操作，无法处理跨多数据源（分布式）操作。跨多个数据源的事务就要使用JTA容器实现事务。根本思想就是“分成两阶段提交”，具体内容这里不做介绍。</span></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/wang379275614/article/details/24818397#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/wang379275614/article/details/24818397#" shape="rect" title="copy">copy</a><a href="https://code.csdn.net/snippets/322723" shape="rect" style="text-indent: 0;" target="_blank" title="在CODE上查看代码片"><img src="Java事务及隔离级别_files/Image [1].png" type="image/png" alt="在CODE上查看代码片" height="12" style="position: relative; top: 1px; left: 2px;" width="12"/></a><a href="https://code.csdn.net/snippets/322723/fork" shape="rect" style="text-indent: 0;" target="_blank" title="派生到我的代码片"><img alt="派生到我的代码片" height="12" src="https://code.csdn.net/assets/ico_fork.svg" style="position: relative; top: 2px; left: 2px;" width="12"></img></a><div style="position: absolute; left: 585px; top: 2219px; width: 18px; height: 18px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>javax.transaction.UserTransaction tx = (UserTransaction)ctx.lookup(“jndiName&quot;);  </span></span></li><li><span>    tx.begin();  </span></li><li><span>    <span>//connection1 connection2 (可能来自不同的数据库)… </span><span>  </span></span></li><li><span>    tx.commit();<span>//tx.rollback();</span><span>  </span></span></li></ol></div><p><br clear="none"/></p><p><br clear="none"/></p><h1><a name="t2" shape="rect"></a><span style="color: #000066;"><span style="font-size: 24px;">隔离级别</span></span></h1><div><span style="color: #000066;"><span style="font-size: 24px;"><br clear="none"/> </span></span></div><p><span style="font-size: 14px;">1)      为了应对<strong>多线程并发读取数据</strong>时出现的问题，事务有了“隔离级别”特性，多线程并发读取数据一般会引发如下<strong>三个问题</strong>：</span></p><p><span style="font-size: 14px;">　　Ø  脏读（dirtyreads）</span></p><p><span style="font-size: 14px;">　　Ø  不可重复读（non-repeatablereads）</span></p><p><span style="font-size: 14px;">　　Ø  幻读（phantomread）</span></p><p><span style="font-size: 14px;">下面进行简要介绍：</span></p><p><span style="font-size: 14px;">　　Ø  脏读：一个事务读取了另一个未提交的并行事务写的数据。 </span></p><p><span style="font-size: 14px;">　　Ø  不可重复读：一个事务重新读取前面读取过的数据， 发现该数据已经被另一个已提交的事务修改过。</span></p><p><span style="font-size: 14px;">　　Ø  幻读：一个事务重新执行一个查询，返回一套符合查询条件的行， 发现这些行因为其他最近提交的事务而发生了改变。</span></p><p><span style="font-size: 14px;"><strong>2)       为了处理上面的读数据问题，java事务提供了4种隔离级别，如下：</strong></span></p><p><span style="font-size: 14px;">　　Ø  读未提交（Read uncommitted）</span></p><p><span style="font-size: 14px;">　　Ø  读已提交（Readcommitted）</span></p><p><span style="font-size: 14px;">　　Ø  可重复读（Repeatableread）</span></p><p><span style="font-size: 14px;">　　Ø  可串行化（Serializable）</span></p><p><span style="font-size: 14px;"><strong>3)       4种隔离级别与上面3个问题的对应关系如下：</strong></span></p><p><span style="font-size: 14px;"><strong><br clear="none"/> </strong></span></p><p><span style="font-size: 14px;"><strong>　　<img src="Java事务及隔离级别_files/Image [2].png" type="image/png"/></strong></span></p><p><br clear="none"/></p><p><span style="font-size: 14px;">　　注意上面的“可能”二字。</span></p><p><span style="font-size: 14px;"><br clear="none"/> </span></p><p><span style="font-size: 14px;"><strong>4)       隔离级别的设定：</strong></span></p><p><strong><span style="font-size: 14px;">　　connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span></strong></p><p><span style="font-size: 14px;">　　在代码中的应用：</span></p><p><span style="font-size: 14px;">　　<img src="Java事务及隔离级别_files/Image [3].png" type="image/png"/></span></p><p><span style="font-size: 14px;"><br clear="none"/> </span></p><p><br clear="none"/></p><h1><a name="t3" shape="rect"></a><span style="color: #000066;"><span style="font-size: 24px;">总结</span></span></h1><div><span style="font-size: 18px; color: #000066;"><br clear="none"/> </span></div><p><span style="font-size: 14px;">　　除了隔离级别，上面所有的东西在.net中相信大家都很熟悉。当然在八期的.net教务系统也用到了事务隔离级别这一点，当时自己还是初步接触，现在可以详细的学习，可以看到学习就是一个不断反复的过程。</span></p></div></div>
</div></body></html> 