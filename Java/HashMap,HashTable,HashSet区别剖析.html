<html>
<head>
  <title>HashMap,HashTable,HashSet区别剖析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1127"/>
<h1>HashMap,HashTable,HashSet区别剖析</h1>

<div>
<div><div><p><span style="font-family: SimSun; font-size: 18px;">HashMap、HashSet、HashTable之间的区别是Java程序员的一个常见面试题目，在此仅以此博客记录，并深入源代码进行分析：</span></p><p><span style="font-family: SimSun; font-size: 18px;">在分析之前，先将其区别列于下面</span></p><p><span style="font-family: SimSun; font-size: 18px;">1:HashSet底层采用的是HashMap进行实现的，但是没有key-value，只有HashMap的key set的视图，HashSet不容许重复的对象</span></p><p><span style="font-family: SimSun; font-size: 18px;">2:Hashtable是基于Dictionary类的，而HashMap是基于Map接口的一个实现</span></p><p><span style="font-family: SimSun; font-size: 18px;">3:Hashtable里默认的方法是同步的，而HashMap则是非同步的，因此Hashtable是多线程安全的</span></p><p><span style="font-family: SimSun; font-size: 18px;">4:HashMap可以将空值作为一个表的条目的key或者value,HashMap中由于键不能重复，因此只有一条记录的Key可以是空值，而value可以有多个为空，但HashTable不允许null值(键与值均不行)</span></p><p><span style="font-family: SimSun; font-size: 18px;">5:内存初始大小不同，HashTable初始大小是11，而HashMap初始大小是16</span></p><p><span style="font-family: SimSun; font-size: 18px;">6:内存扩容时采取的方式也不同，Hashtable采用的是2*old+1,而HashMap是2*old。</span></p><p><span style="font-family: SimSun; font-size: 18px;">7:哈希值的计算方法不同，Hashtable直接使用的是对象的hashCode,而HashMap则是在对象的hashCode的基础上还进行了一些变化</span></p><p><span style="font-family: SimSun; font-size: 18px;">源代码分析：</span></p><p><span style="font-family: SimSun; font-size: 18px;">对于区别1，看下面的源码</span></p><p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//HashSet类的部份源代码</span><span>  </span></span></li><li><span><span>public</span><span> </span><span>class</span><span> HashSet&lt;E&gt;  </span></span></li><li><span>    <span>extends</span><span> AbstractSet&lt;E&gt;  </span></span></li><li><span>    <span>implements</span><span> Set&lt;E&gt;, Cloneable, java.io.Serializable  </span></span></li><li><span>{   <span>//用于类的序列化，可以不用管它</span><span>  </span></span></li><li><span>    <span>static</span><span> </span><span>final</span><span> </span><span>long</span><span> serialVersionUID = -5024744406713321676L;  </span></span></li><li><span>    <span>//从这里可以看出HashSet类里面真的是采用HashMap来实现的</span><span>  </span></span></li><li><span>    <span>private</span><span> </span><span>transient</span><span> HashMap&lt;E,Object&gt; map;  </span></span></li><li><span>  </span></li><li><span>    <span>// Dummy value to associate with an Object in the backing Map</span><span>  </span></span></li><li><span>    <span>//这里是生成一个对象，生成这个对象的作用是将每一个键的值均关联于此对象，以满足HashMap的键值对</span><span>  </span></span></li><li><span>    <span>private</span><span> </span><span>static</span><span> </span><span>final</span><span> Object PRESENT = </span><span>new</span><span> Object();  </span></span></li><li><span>  </span></li><li><span>    <span>/**</span> </span></li><li><span><span>     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span> </span></li><li><span><span>     * default initial capacity (16) and load factor (0.75).</span> </span></li><li><span><span>     */</span><span>  </span></span></li><li><span>    <span>//这里是一个构造函数，开构生成一个HashMap对象，用来存放数据</span><span>  </span></span></li><li><span>    <span>public</span><span> HashSet() {  </span></span></li><li><span>    map = <span>new</span><span> HashMap&lt;E,Object&gt;();  </span></span></li><li><span>    }  </span></li></ol></div>从上面的代码中得出的结论是HashSet的确是采用HashMap来实现的，而且每一个键都关键同一个Object类的对象，因此键所关联的值没有意义，真正有意义的是键。而HashMap里的键是不允许重复的，因此1也就很容易明白了。<p><span style="font-family: SimSun; font-size: 18px;">对于区别2，继续看源代码如下</span></p><p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//从这里可以看得出Hashtable是继承于Dictionary,实现了Map接口</span><span>  </span></span></li><li><span><span>public</span><span> </span><span>class</span><span> Hashtable&lt;K,V&gt;  </span></span></li><li><span>    <span>extends</span><span> Dictionary&lt;K,V&gt;  </span></span></li><li><span>    <span>implements</span><span> Map&lt;K,V&gt;, Cloneable, java.io.Serializable {  </span></span></li></ol></div><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//这里可以看出的是HashMap是继承于AbstractMap类，实现了Map接口</span><span>  </span></span></li><li><span><span>//因此与Hashtable继承的父类不同</span><span>  </span></span></li><li><span><span>public</span><span> </span><span>class</span><span> HashMap&lt;K,V&gt;  </span></span></li><li><span>    <span>extends</span><span> AbstractMap&lt;K,V&gt;  </span></span></li><li><span>    <span>implements</span><span> Map&lt;K,V&gt;, Cloneable, Serializable  </span></span></li></ol></div>区别3，找一个具有针对性的方法看看，这个方法就是put<p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//Hashtable里的向集体增加键值对的方法，从这里可以明显看到的是</span><span>  </span></span></li><li><span><span>//采用了synchronized关键字，这个关键字的作用就是用于线程的同步操作</span><span>  </span></span></li><li><span><span>//因此下面这个方法对于多线程来说是安全的，但这会影响效率   </span><span>  </span></span></li><li><span><span>public</span><span> </span><span>synchronized</span><span> V put(K key, V value) {  </span></span></li><li><span>    <span>// Make sure the value is not null</span><span>  </span></span></li><li><span>    <span>//如果值为空的，则会抛出异常</span><span>  </span></span></li><li><span>    <span>if</span><span> (value == </span><span>null</span><span>) {  </span></span></li><li><span>        <span>throw</span><span> </span><span>new</span><span> NullPointerException();  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>// Makes sure the key is not already in the hashtable.</span><span>  </span></span></li><li><span>    Entry tab[] = table;  </span></li><li><span>    <span>//获得键值的hashCode,从这里也可以看得出key!=null,否则的话会抛出异常的呦</span><span>  </span></span></li><li><span>    <span>int</span><span> hash = key.hashCode();  </span></span></li><li><span>    <span>//获取键据所在的哈希表的位置</span><span>  </span></span></li><li><span>    <span>int</span><span> index = (hash &amp; </span><span>0x7FFFFFFF</span><span>) % tab.length;  </span></span></li><li><span>    <span>//从下面这个循环中可以看出的是，内部实现采用了链表，即桶状结构</span><span>  </span></span></li><li><span>    <span>for</span><span> (Entry&lt;K,V&gt; e = tab[index] ; e != </span><span>null</span><span> ; e = e.next) {  </span></span></li><li><span>        <span>//如果向Hashtable中增加同一个元素时，则会重新更新元素的值 </span><span>  </span></span></li><li><span>        <span>if</span><span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) {  </span></span></li><li><span>                V old = e.value;  </span></li><li><span>                e.value = value;  </span></li><li><span>                <span>return</span><span> old;  </span></span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    <span>//后面的暂时不用管它，大概的意思就是内存的个数少于某个阀值时，进行重新分配内存</span><span>  </span></span></li><li><span>    modCount++;  </span></li><li><span>    <span>if</span><span> (count &gt;= threshold) {  </span></span></li><li><span>        <span>// Rehash the table if the threshold is exceeded</span><span>  </span></span></li><li><span>        rehash();  </span></li><li><span>  </span></li><li><span>            tab = table;  </span></li><li><span>            index = (hash &amp; <span>0x7FFFFFFF</span><span>) % tab.length;  </span></span></li><li><span>    }  </span></li></ol></div><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//HashMap中的实现则相对来说要简单的很多了，如下代码</span><span>  </span></span></li><li><span><span>//这里的代码中没有synchronize关键字，即可以看出，这个关键函数不是线程安全的</span><span>  </span></span></li><li><span>    <span>public</span><span> V put(K key, V value) {  </span></span></li><li><span>    <span>//对于键是空时，将向Map中放值一个null-value构成的键值对</span><span>  </span></span></li><li><span>    <span>//对值却没有进行判空处理，意味着可以有多个具有键，键所对应的值却为空的元素。</span><span>  </span></span></li><li><span>        <span>if</span><span> (key == </span><span>null</span><span>)  </span></span></li><li><span>            <span>return</span><span> putForNullKey(value);  </span></span></li><li><span>    <span>//算出键所在的哈希表的位置</span><span>  </span></span></li><li><span>        <span>int</span><span> hash = hash(key.hashCode());  </span></span></li><li><span>        <span>int</span><span> i = indexFor(hash, table.length);  </span></span></li><li><span>    <span>//同样从这里可以看得出来的是采用的是链表结构，采用的是桶状</span><span>  </span></span></li><li><span>        <span>for</span><span> (Entry&lt;K,V&gt; e = table[i]; e != </span><span>null</span><span>; e = e.next) {  </span></span></li><li><span>            Object k;  </span></li><li><span>            <span>//对于向集体中增加具有相同键的情况时，这里可以看出，并不增加进去，而是进行更新操作</span><span>  </span></span></li><li><span>            <span>if</span><span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {  </span></span></li><li><span>                V oldValue = e.value;  </span></li><li><span>                e.value = value;  </span></li><li><span>                e.recordAccess(<span>this</span><span>);  </span></span></li><li><span>                <span>return</span><span> oldValue;  </span></span></li><li><span>            }  </span></li><li><span>        }  </span></li><li><span>        <span>//开始增加元素</span><span>  </span></span></li><li><span>        modCount++;  </span></li><li><span>        addEntry(hash, key, value, i);  </span></li><li><span>        <span>return</span><span> </span><span>null</span><span>;  </span></span></li><li><span>    }  </span></li></ol></div>区别4在上面的代码中，已经分析了，可以再细看一下<p><span style="font-family: SimSun; font-size: 18px;">区别5内存初化大小不同，看看两者的源代码：</span></p><p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span> </span><span>public</span><span> Hashtable() {  </span></span></li><li><span>   <span>//从这里可以看出，默认的初始化大小11，这里的11并不是11个字节，而是11个Entry,这个Entry是</span><span>  </span></span></li><li><span>   <span>//实现链表的关键结构</span><span>  </span></span></li><li><span>   <span>//这里的0.75代表的是装载因子</span><span>  </span></span></li><li><span><span>this</span><span>(</span><span>11</span><span>, </span><span>0</span><span>.75f);  </span></span></li><li><span> }  </span></li></ol></div><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//这里均是一些定义</span><span>  </span></span></li><li><span> <span>public</span><span> HashMap() {  </span></span></li><li><span> <span>//这个默认的装载因子也是0.75</span><span>  </span></span></li><li><span>     <span>this</span><span>.loadFactor = DEFAULT_LOAD_FACTOR;  </span></span></li><li><span> <span>//默认的痤为0.75*16</span><span>  </span></span></li><li><span>     threshold = (<span>int</span><span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);  </span></span></li><li><span> <span>//这里开始是默认的初始化大小，这里大小是16</span><span>  </span></span></li><li><span>     table = <span>new</span><span> Entry[DEFAULT_INITIAL_CAPACITY];  </span></span></li><li><span>     init();  </span></li><li><span> }  </span></li></ol></div>从上面的代码中，可以看出的是两者的默认大小是不同的，一个是11，一个是16<p><span style="font-family: SimSun; font-size: 18px;">区别6内存的扩容方式，看一看源代码也是很清楚的，其实区别是不大的，看到网上一哥们写的，说两者有区别，其实真正深入源码，区别真不大，一个是2*oldCapacity+1, 一个是2*oldCapacity,你说大吗:）</span></p><p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//Hashtable中调整内存的函数，这个函数没有synchronize关键字，但是protected呦</span><span>  </span></span></li><li><span><span>protected</span><span> </span><span>void</span><span> rehash() {  </span></span></li><li><span>    <span>//获取原来的表大小</span><span>  </span></span></li><li><span>    <span>int</span><span> oldCapacity = table.length;  </span></span></li><li><span>    Entry[] oldMap = table;  </span></li><li><span>  <span>//设置新的大小为2*oldCapacity+1</span><span>  </span></span></li><li><span>    <span>int</span><span> newCapacity = oldCapacity * </span><span>2</span><span> + </span><span>1</span><span>;  </span></span></li><li><span>    <span>//开设空间</span><span>  </span></span></li><li><span>    Entry[] newMap = <span>new</span><span> Entry[newCapacity];  </span></span></li><li><span>  <span>//以下就不用管了。。。</span><span>  </span></span></li><li><span>    modCount++;  </span></li><li><span>    threshold = (<span>int</span><span>)(newCapacity * loadFactor);  </span></span></li><li><span>    table = newMap;  </span></li><li><span>  </span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = oldCapacity ; i-- &gt; </span><span>0</span><span> ;) {  </span></span></li><li><span>        <span>for</span><span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != </span><span>null</span><span> ; ) {  </span></span></li><li><span>        Entry&lt;K,V&gt; e = old;  </span></li><li><span>        old = old.next;  </span></li><li><span>  </span></li><li><span>        <span>int</span><span> index = (e.hash &amp; </span><span>0x7FFFFFFF</span><span>) % newCapacity;  </span></span></li><li><span>        e.next = newMap[index];  </span></li><li><span>        newMap[index] = e;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    }  </span></li></ol></div><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//HashMap中要简单的多了，看看就知道了</span><span>  </span></span></li><li><span><span>void</span><span> addEntry(</span><span>int</span><span> hash, K key, V value, </span><span>int</span><span> bucketIndex) {  </span></span></li><li><span>Entry&lt;K,V&gt; e = table[bucketIndex];  </span></li><li><span>       table[bucketIndex] = <span>new</span><span> Entry&lt;K,V&gt;(hash, key, value, e);  </span></span></li><li><span>       <span>//如果超过了阀值</span><span>  </span></span></li><li><span>       <span>if</span><span> (size++ &gt;= threshold)  </span></span></li><li><span>       <span>//就将大小设置为原来的2倍</span><span>  </span></span></li><li><span>           resize(<span>2</span><span> * table.length);  </span></span></li><li><span>   }  </span></li></ol></div>是吧，没什么区别吧<p><span style="font-family: SimSun; font-size: 18px;">对于区别7的哈希值计算方法的不同，源码面前，同样是了无秘密</span></p><p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//Hashtable中可以看出的是直接采用关键字的hashcode作为哈希值</span><span>  </span></span></li><li><span><span>int</span><span> hash = key.hashCode();  </span></span></li><li><span><span>//然后进行模运算，求出所在哗然表的位置 </span><span>  </span></span></li><li><span><span>int</span><span> index = (hash &amp; </span><span>0x7FFFFFFF</span><span>) % tab.length;  </span></span></li></ol></div><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//HashMap中的实现</span><span>  </span></span></li><li><span><span>//这两行代码的意思是先计算hashcode,然后再求其在哈希表的相应位置      </span><span>  </span></span></li><li><span><span>int</span><span> hash = hash(key.hashCode());  </span></span></li><li><span><span>int</span><span> i = indexFor(hash, table.length);  </span></span></li></ol></div>上面的HashMap中可以看出关键在两个函数hash与indexFor<p><span style="font-family: SimSun; font-size: 18px;">源码如下:</span></p><p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>static</span><span> </span><span>int</span><span> hash(</span><span>int</span><span> h) {  </span></span></li><li><span>    <span>// This function ensures that hashCodes that differ only by</span><span>  </span></span></li><li><span>    <span>// constant multiples at each bit position have a bounded</span><span>  </span></span></li><li><span>    <span>// number of collisions (approximately 8 at default load factor).</span><span>  </span></span></li><li><span>    <span>//这个我就不多说了，&gt;&gt;&gt;这个是无符号右移运算符，可以理解为无符号整型</span><span>  </span></span></li><li><span>    h ^= (h &gt;&gt;&gt; <span>20</span><span>) ^ (h &gt;&gt;&gt; </span><span>12</span><span>);  </span></span></li><li><span>    <span>return</span><span> h ^ (h &gt;&gt;&gt; </span><span>7</span><span>) ^ (h &gt;&gt;&gt; </span><span>4</span><span>);  </span></span></li><li><span>}  </span></li></ol></div><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/zwjlpeng/article/details/9746425#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>//求位于哈希表中的位置</span><span>  </span></span></li><li><span> <span>static</span><span> </span><span>int</span><span> indexFor(</span><span>int</span><span> h, </span><span>int</span><span> length) {  </span></span></li><li><span>     <span>return</span><span> h &amp; (length-</span><span>1</span><span>);  </span></span></li><li><span> }  <br clear="none"/></span></li></ol></div></div></div>
</div></body></html> 