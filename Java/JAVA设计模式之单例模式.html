<html>
<head>
  <title>JAVA设计模式之单例模式</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1034"/>
<h1>JAVA设计模式之单例模式</h1>

<div>
<div><div><p><span style="line-height: 1.8; margin: 0px; font-family: 宋体; padding: 0px;">概念：<span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;"><br clear="none" style="margin: 0px; padding: 0px;"/> </span>　　<span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;">java</span>中单例模式是一种常见的设计模式，单例模式分三种：懒汉式单例、饿汉式单例、登记式单例三种。<span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;"><br clear="none" style="margin: 0px; padding: 0px;"/> </span>　　单例模式有一下特点：<span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;"><br clear="none" style="margin: 0px; padding: 0px;"/> </span>　　<span style="line-height: 1.8; margin: 0px; color: #008000; padding: 0px;"><span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;">1</span>、单例类只能有一个实例。<span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;"><br clear="none" style="margin: 0px; padding: 0px;"/> </span>　　<span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;">2</span>、单例类必须自己自己创建自己的唯一实例。<span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;"><br clear="none" style="margin: 0px; padding: 0px;"/> </span>　　<span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;">3</span>、单例类必须给所有其他对象提供这一实例。<span lang="EN-US" style="line-height: 1.8; margin: 0px; padding: 0px;"><br clear="none" style="margin: 0px; padding: 0px;"/> <span style="line-height: 1.8; margin: 0px; font-family: 宋体; color: black; padding: 0px;"><span style="line-height: 1.8; margin: 0px; padding: 0px;">　 　单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序 对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请 求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</span></span></span></span></span></p><p><br clear="none"/></p><p><br clear="none"/></p><p><br clear="none"/></p><p><br clear="none"/></p><p align="left">首先看一个经典的单例实现。</p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="copy">copy</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="print">print</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="?">?</a><a href="https://code.csdn.net/snippets/294885" shape="rect" style="text-indent: 0;" target="_blank" title="在CODE上查看代码片"><img src="JAVA设计模式之单例模式_files/Image.png" type="image/png" alt="在CODE上查看代码片" height="12" style="position: relative; top: 1px; left: 2px;" width="12"/></a><a href="https://code.csdn.net/snippets/294885/fork" shape="rect" style="text-indent: 0;" target="_blank" title="派生到我的代码片"><img alt="派生到我的代码片" height="12" src="https://code.csdn.net/assets/ico_fork.svg" style="position: relative; top: 2px; left: 2px;" width="12"></img></a><div style="position: absolute; left: 742px; top: 860px; width: 24px; height: 13px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>public</span><span> </span><span>class</span><span> Singleton {  </span></span></li><li><span>    <span>private</span><span> </span><span>static</span><span> Singleton uniqueInstance = </span><span>null</span><span>;  </span></span></li><li><span>   </span></li><li><span>    <span>private</span><span> Singleton() {  </span></span></li><li><span>       <span>// Exists only to defeat instantiation.</span><span>  </span></span></li><li><span>    }  </span></li><li><span>   </span></li><li><span>    <span>public</span><span> </span><span>static</span><span> Singleton getInstance() {  </span></span></li><li><span>       <span>if</span><span> (uniqueInstance == </span><span>null</span><span>) {  </span></span></li><li><span>           uniqueInstance = <span>new</span><span> Singleton();  </span></span></li><li><span>       }  </span></li><li><span>       <span>return</span><span> uniqueInstance;  </span></span></li><li><span>    }  </span></li><li><span>    <span>// Other methods...</span><span>  </span></span></li><li><span>}  </span></li></ol></div><p align="left"><br clear="none"/>  </p><p align="left">Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围 内，Singleton的唯一实例只能通过getInstance()方法访问。（事实上，通过Java反射机制是能够实例化构造方法为private的 类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。）</p><p align="left">但是以上实现没有考虑线程安全问题。所谓线程安全是指：如果你的代码所在的进程中有多个线程在同时运 行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说： 一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。显然以 上实现并不满足线程安全的要求，在并发环境下很可能出现多个Singleton实例。</p><p align="left"> </p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="copy">copy</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="print">print</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="?">?</a><a href="https://code.csdn.net/snippets/294885" shape="rect" style="text-indent: 0;" target="_blank" title="在CODE上查看代码片"><img src="JAVA设计模式之单例模式_files/Image [1].png" type="image/png" alt="在CODE上查看代码片" height="12" style="position: relative; top: 1px; left: 2px;" width="12"/></a><a href="https://code.csdn.net/snippets/294885/fork" shape="rect" style="text-indent: 0;" target="_blank" title="派生到我的代码片"><img alt="派生到我的代码片" height="12" src="https://code.csdn.net/assets/ico_fork.svg" style="position: relative; top: 2px; left: 2px;" width="12"></img></a><div style="position: absolute; left: 742px; top: 1524px; width: 24px; height: 13px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>package</span><span> jason.single;  </span></span></li><li><span>  </span></li><li><span><span>public</span><span> </span><span>class</span><span> TestStream {  </span></span></li><li><span>    String name = <span>null</span><span>;  </span></span></li><li><span>  </span></li><li><span>    <span>public</span><span> String getName() {  </span></span></li><li><span>        <span>return</span><span> name;  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>public</span><span> </span><span>void</span><span> setName(String name) {  </span></span></li><li><span>        <span>this</span><span>.name = name;  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>private</span><span> TestStream() {  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>private</span><span> </span><span>static</span><span> TestStream ts1 = </span><span>null</span><span>;  </span></span></li><li><span>  </span></li><li><span>    <span>public</span><span> </span><span>static</span><span> TestStream getTest() {  </span></span></li><li><span>        <span>if</span><span> (ts1 == </span><span>null</span><span>) {  </span></span></li><li><span>            ts1 = <span>new</span><span> TestStream();  </span></span></li><li><span>        }  </span></li><li><span>        <span>return</span><span> ts1;  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>public</span><span> </span><span>void</span><span> printInfo() {  </span></span></li><li><span>        System.out.println(<span>&quot;the name is &quot;</span><span> + name);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>}  </span></li></ol></div><p align="left"><br clear="none"/>  </p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="copy">copy</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="print">print</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="?">?</a><a href="https://code.csdn.net/snippets/294885" shape="rect" style="text-indent: 0;" target="_blank" title="在CODE上查看代码片"><img src="JAVA设计模式之单例模式_files/Image [2].png" type="image/png" alt="在CODE上查看代码片" height="12" style="position: relative; top: 1px; left: 2px;" width="12"/></a><a href="https://code.csdn.net/snippets/294885/fork" shape="rect" style="text-indent: 0;" target="_blank" title="派生到我的代码片"><img alt="派生到我的代码片" height="12" src="https://code.csdn.net/assets/ico_fork.svg" style="position: relative; top: 2px; left: 2px;" width="12"></img></a><div style="position: absolute; left: 742px; top: 2182px; width: 24px; height: 13px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>package</span><span> jason.single;  </span></span></li><li><span>  </span></li><li><span><span>public</span><span> </span><span>class</span><span> TMain {  </span></span></li><li><span>    <span>public</span><span> </span><span>static</span><span> </span><span>void</span><span> main(String[] args){  </span></span></li><li><span>        TestStream ts1 = TestStream.getTest();  </span></li><li><span>        ts1.setName(<span>&quot;jason&quot;</span><span>);  </span></span></li><li><span>        TestStream ts2 = TestStream.getTest();  </span></li><li><span>        ts2.setName(<span>&quot;0539&quot;</span><span>);  </span></span></li><li><span>          </span></li><li><span>        ts1.printInfo();  </span></li><li><span>        ts2.printInfo();  </span></li><li><span>          </span></li><li><span>        <span>if</span><span>(ts1 == ts2){  </span></span></li><li><span>            System.out.println(<span>&quot;创建的是同一个实例&quot;</span><span>);  </span></span></li><li><span>        }<span>else</span><span>{  </span></span></li><li><span>            System.out.println(<span>&quot;创建的不是同一个实例&quot;</span><span>);  </span></span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>}  </span></li></ol></div><p align="left"> </p><p>运行结果：</p><p><img src="JAVA设计模式之单例模式_files/Image [3].png" type="image/png"/><br clear="none" style="margin: 0px; padding: 0px;"/></p><p>结论：由结果可以得知单例模式为一个面向对象的应用程序提供了对象惟一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。</p><p align="left"> </p><p align="left">1.饿汉式单例类</p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="copy">copy</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="print">print</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="?">?</a><a href="https://code.csdn.net/snippets/294885" shape="rect" style="text-indent: 0;" target="_blank" title="在CODE上查看代码片"><img src="JAVA设计模式之单例模式_files/Image [4].png" type="image/png" alt="在CODE上查看代码片" height="12" style="position: relative; top: 1px; left: 2px;" width="12"/></a><a href="https://code.csdn.net/snippets/294885/fork" shape="rect" style="text-indent: 0;" target="_blank" title="派生到我的代码片"><img alt="派生到我的代码片" height="12" src="https://code.csdn.net/assets/ico_fork.svg" style="position: relative; top: 2px; left: 2px;" width="12"></img></a><div style="position: absolute; left: 742px; top: 3021px; width: 24px; height: 13px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>//饿汉式单例类.在类初始化时，已经自行实例化 </span><span>  </span></span></li><li><span><span>public</span><span> </span><span>class</span><span> Singleton1 {  </span></span></li><li><span>    <span>//私有的默认构造子</span><span>  </span></span></li><li><span>    <span>private</span><span> Singleton1() {}  </span></span></li><li><span>    <span>//已经自行实例化 </span><span>  </span></span></li><li><span>    <span>private</span><span> </span><span>static</span><span> </span><span>final</span><span> Singleton1 single = </span><span>new</span><span> Singleton1();  </span></span></li><li><span>    <span>//静态工厂方法 </span><span>  </span></span></li><li><span>    <span>public</span><span> </span><span>static</span><span> Singleton1 getInstance() {  </span></span></li><li><span>        <span>return</span><span> single;  </span></span></li><li><span>    }  </span></li><li><span>}  </span></li></ol></div><p align="left"><br clear="none"/> 2.懒汉式单例类</p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="copy">copy</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="print">print</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="?">?</a><a href="https://code.csdn.net/snippets/294885" shape="rect" style="text-indent: 0;" target="_blank" title="在CODE上查看代码片"><img src="JAVA设计模式之单例模式_files/Image [5].png" type="image/png" alt="在CODE上查看代码片" height="12" style="position: relative; top: 1px; left: 2px;" width="12"/></a><a href="https://code.csdn.net/snippets/294885/fork" shape="rect" style="text-indent: 0;" target="_blank" title="派生到我的代码片"><img alt="派生到我的代码片" height="12" src="https://code.csdn.net/assets/ico_fork.svg" style="position: relative; top: 2px; left: 2px;" width="12"></img></a><div style="position: absolute; left: 742px; top: 3337px; width: 24px; height: 13px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>//懒汉式单例类.在第一次调用的时候实例化 </span><span>  </span></span></li><li><span><span>public</span><span> </span><span>class</span><span> Singleton2 {  </span></span></li><li><span>    <span>//私有的默认构造子</span><span>  </span></span></li><li><span>    <span>private</span><span> Singleton2() {}  </span></span></li><li><span>    <span>//注意，这里没有final    </span><span>  </span></span></li><li><span>    <span>private</span><span> </span><span>static</span><span> Singleton2 single=</span><span>null</span><span>;  </span></span></li><li><span>    <span>//静态工厂方法 </span><span>  </span></span></li><li><span>    <span>public</span><span> </span><span>synchronized</span><span>  </span><span>static</span><span> Singleton2 getInstance() {  </span></span></li><li><span>         <span>if</span><span> (single == </span><span>null</span><span>) {    </span></span></li><li><span>             single = <span>new</span><span> Singleton2();  </span></span></li><li><span>         }    </span></li><li><span>        <span>return</span><span> single;  </span></span></li><li><span>    }  </span></li><li><span>}  </span></li></ol></div><p align="left"><br clear="none"/>  </p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="copy">copy</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="print">print</a><a href="http://blog.csdn.net/jason0539/article/details/23297037#" shape="rect" title="?">?</a><a href="https://code.csdn.net/snippets/294885" shape="rect" style="text-indent: 0;" target="_blank" title="在CODE上查看代码片"><img src="JAVA设计模式之单例模式_files/Image [6].png" type="image/png" alt="在CODE上查看代码片" height="12" style="position: relative; top: 1px; left: 2px;" width="12"/></a><a href="https://code.csdn.net/snippets/294885/fork" shape="rect" style="text-indent: 0;" target="_blank" title="派生到我的代码片"><img alt="派生到我的代码片" height="12" src="https://code.csdn.net/assets/ico_fork.svg" style="position: relative; top: 2px; left: 2px;" width="12"></img></a><div style="position: absolute; left: 742px; top: 3707px; width: 24px; height: 13px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>import</span><span> java.util.HashMap;  </span></span></li><li><span><span>import</span><span> java.util.Map;  </span></span></li><li><span><span>//登记式单例类.</span><span>  </span></span></li><li><span><span>//类似Spring里面的方法，将类名注册，下次从里面直接获取。</span><span>  </span></span></li><li><span><span>public</span><span> </span><span>class</span><span> Singleton3 {  </span></span></li><li><span>    <span>private</span><span> </span><span>static</span><span> Map&lt;String,Singleton3&gt; map = </span><span>new</span><span> HashMap&lt;String,Singleton3&gt;();  </span></span></li><li><span>    <span>static</span><span>{  </span></span></li><li><span>        Singleton3 single = <span>new</span><span> Singleton3();  </span></span></li><li><span>        map.put(single.getClass().getName(), single);  </span></li><li><span>    }  </span></li><li><span>    <span>//保护的默认构造子</span><span>  </span></span></li><li><span>    <span>protected</span><span> Singleton3(){}  </span></span></li><li><span>    <span>//静态工厂方法,返还此类惟一的实例</span><span>  </span></span></li><li><span>    <span>public</span><span> </span><span>static</span><span> Singleton3 getInstance(String name) {  </span></span></li><li><span>        <span>if</span><span>(name == </span><span>null</span><span>) {  </span></span></li><li><span>            name = Singleton3.<span>class</span><span>.getName();  </span></span></li><li><span>            System.out.println(<span>&quot;name == null&quot;</span><span>+</span><span>&quot;---&gt;name=&quot;</span><span>+name);  </span></span></li><li><span>        }  </span></li><li><span>        <span>if</span><span>(map.get(name) == </span><span>null</span><span>) {  </span></span></li><li><span>            <span>try</span><span> {  </span></span></li><li><span>                map.put(name, (Singleton3) Class.forName(name).newInstance());  </span></li><li><span>            } <span>catch</span><span> (InstantiationException e) {  </span></span></li><li><span>                e.printStackTrace();  </span></li><li><span>            } <span>catch</span><span> (IllegalAccessException e) {  </span></span></li><li><span>                e.printStackTrace();  </span></li><li><span>            } <span>catch</span><span> (ClassNotFoundException e) {  </span></span></li><li><span>                e.printStackTrace();  </span></li><li><span>            }  </span></li><li><span>        }  </span></li><li><span>        <span>return</span><span> map.get(name);  </span></span></li><li><span>    }  </span></li><li><span>    <span>//一个示意性的商业方法</span><span>  </span></span></li><li><span>    <span>public</span><span> String about() {      </span></span></li><li><span>        <span>return</span><span> </span><span>&quot;Hello, I am RegSingleton.&quot;</span><span>;      </span></span></li><li><span>    }      </span></li><li><span>    <span>public</span><span> </span><span>static</span><span> </span><span>void</span><span> main(String[] args) {  </span></span></li><li><span>        Singleton3 single3 = Singleton3.getInstance(<span>null</span><span>);  </span></span></li><li><span>        System.out.println(single3.about());  </span></li><li><span>    }  </span></li><li><span>}  </span></li></ol></div></div></div>
</div></body></html> 