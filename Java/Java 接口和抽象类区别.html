<html>
<head>
  <title>Java 接口和抽象类区别</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1039"/>
<h1>Java 接口和抽象类区别</h1>

<div>
<div><div><h2>1.概述</h2><p>一个软件设计的好坏，我想很大程度上取决于它的整体架构，而这个整体架构其实就是你对整个宏观商业业务的抽象框架，当代表业务逻辑的高层抽象层结构 合理时，你底层的具体实现需要考虑的就仅仅是一些算法和一些具体的业务实现了。当你需要再开发另一个相近的项目时，你以前的抽象层说不定还可以再次利用 。<strong><span style="color: #ff0000;">面对对象的设计，复用的重点其实应该是抽象层的复用，而不是具体某一个代码块的复用</span></strong>。</p><p>说到了抽象，我就不能不提到曾让我头痛的Java接口和Java抽象类了，这也是本文我想说的重点。</p><p>既然面向对象设计的重点在于抽象，那Java接口和Java抽象类就有它存在的必然性了。</p><p>Java接口(interface)和Java抽象类(abstract class)代表的就是抽象类型，就是我们需要提出的抽象层的具体表现。OOP面向对象的编程，如果要提高程序的复用率，增加程序 的可维护性，可扩展性，就必须是面向接口的编程，面向抽象的编程，正确地使用接口、抽象类这些有用的抽象类型作为你结构层次上的顶层。</p><p>Java接口和Java抽象类有太多相似的地方，又有太多特别的地方，究竟在什么地方，才是它们的最佳位置呢？把它们比较一下，你就可以发现了。</p><p><br clear="none"/></p><ol><li>Java接口和Java抽象类最大的一个区别，就在于Java抽象类可以提供某些方法的部分实现，而Java接口不可以<span style="color: #ff0000;"><strong>（就是interface中只能定义方法，而不能有方法的实现，而在abstract class中则可以既有方法的具体实现，又有没有具体实现的抽象方法）</strong></span>，这大概就是Java抽象类唯一的优点吧，但这个优点非常有用。<strong><span style="text-decoration: underline;">如果向一个抽象类里加入一个新的具体方法时，那么它所有的子类都一下子都得到了这个新方法，而Java接口做不到这一点，如果向一个Java接口里加入一个 新方法，所有实现这个接口的类就无法成功通过编译了，因为你必须让每一个类都再实现这个方法才行，这显然是Java接口的缺点</span>。</strong>这个在我的另外一篇博客<a href="http://blog.csdn.net/xw13106209/article/details/6924458" shape="rect">mapreduce 新旧API 区别</a>中有提到类似的问题，在新的mapreduce api中更倾向于使用抽象类，而不是接口，因为这更容易扩展。原因就是上面划线部分所说的。</li><li>一 个抽象类的实现只能由这个抽象类的子类给出，也就是说，这个实现处在抽象类所定义出的继承的等级结构中，而由于Java语言的单继承性，所以抽象类作为类 型定义工具的效能大打折扣。在这一点上，Java接口的优势就出来了，任何一个实现了一个Java接口所规定的方法的类都可以具有这个接口的类型，而一个 类可以实现任意多个Java接口，从而这个类就有了多种类型。<span style="color: #ff0000;">（使用抽象类，那么继承这个抽象类的子类类型就比较单一，因为子类只能单继承抽象类；而子类能够同时实现多个接口，因为类型就比较多。接口和抽象类都可以定义对象，但是只能用他们的具体实现类来进行实例化。）</span></li><li>从第2点不难看出，Java接口是定义混合类型的理想工具，混合类表明一个类不仅仅具有某个主类型的行为，而且具有其他的次要行为。</li><li>结合1、2点中抽象类和Java接口的各自优势，具精典的设计模式就出来了：声明类型的工作仍然由Java接口承担，但是同时给出一个Java 抽象类，且实现了这个接口，而其他同属于这个抽象类型的具体类可以选择实现这个Java接口，也可以选择继承这个抽象类，<strong><span style="color: #ff0000;">也就是说在层次结构中，Java 接口在最上面，然后紧跟着抽象类</span></strong>，这下两个的最大优点都能发挥到极至了。这个模式就是<strong><span style="color: #ff0000;">“缺省适配模式</span></strong>”。在Java语言API中用了这种模式，而且全都遵循一定的命名规范：Abstract ＋接口名。<span style="color: #ff0000;"><strong>（A extends AbstractB implements interfaceC，那么A即可以选择实现(@Override)接口interfaceC中的方法，也可以选择不实现；A即可以选择实现 (@Override)抽象类AbstractB中的方法，也可以选择不实现）</strong></span></li></ol><p><br clear="none"/></p><p>Java接口和Java抽象类的存在就是为了用于具体类的实现和继承的，如果你准备写一个具体类去继承另一个具体类的话，那你的设计就有很大问题了。Java抽象类就是为了继承而存在的，它的抽象方法就是为了强制子类必须去实现的。</p><p>使用Java接口和抽象Java类进行变量的类型声明、参数是类型声明、方法的返还类型说明，以及数据类型的转换等。而不要用具体Java类进行变量的类型声明、参数是类型声明、方法的返还类型说明，以及数据类型的转换等。<br clear="none"/></p><h2><a name="t1" shape="rect"></a>2.实例</h2><p>下面给出一个具体的接口Action，代码如下所示：</p><p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/xw13106209/article/details/6923556#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/xw13106209/article/details/6923556#" shape="rect" title="copy">copy</a><div style="position: absolute; left: 704px; top: 1765px; width: 18px; height: 18px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>package</span><span> org.springframework.webflow.execution;  </span></span></li><li><span><span>public</span><span> </span><span>interface</span><span> Action {  </span></span></li><li><span>    <span>public</span><span> Event execute(RequestContext context) </span><span>throws</span><span> Exception;  </span></span></li><li><span>}  </span></li></ol></div>在这个接口中，定义了一个没有具体实现的方法，方法名叫做execute()，返回类型是Event。如前面第一条所述，接口中的方法都是没有实现的。这些方法的具体实现是在实现(implements)这个接口的类中给出的。<br clear="none"/><p>再来看一个实现Action接口的抽象类AbstractAction，代码如下。</p><p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/xw13106209/article/details/6923556#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/xw13106209/article/details/6923556#" shape="rect" title="copy">copy</a><div style="position: absolute; left: 704px; top: 1998px; width: 18px; height: 18px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>package</span><span> org.springframework.webflow.action;  </span></span></li><li><span>  </span></li><li><span><span>import</span><span> org.apache.commons.logging.Log;  </span></span></li><li><span><span>import</span><span> org.apache.commons.logging.LogFactory;  </span></span></li><li><span><span>import</span><span> org.springframework.beans.factory.BeanInitializationException;  </span></span></li><li><span><span>import</span><span> org.springframework.beans.factory.InitializingBean;  </span></span></li><li><span><span>import</span><span> org.springframework.util.ClassUtils;  </span></span></li><li><span><span>import</span><span> org.springframework.webflow.core.collection.AttributeMap;  </span></span></li><li><span><span>import</span><span> org.springframework.webflow.execution.Action;  </span></span></li><li><span><span>import</span><span> org.springframework.webflow.execution.Event;  </span></span></li><li><span><span>import</span><span> org.springframework.webflow.execution.RequestContext;  </span></span></li><li><span>  </span></li><li><span><span>public</span><span> </span><span>abstract</span><span> </span><span>class</span><span> AbstractAction </span><span>implements</span><span> Action, InitializingBean {  </span></span></li><li><span>  </span></li><li><span>    <span>protected</span><span> </span><span>final</span><span> Log logger = LogFactory.getLog(getClass());  </span></span></li><li><span>  </span></li><li><span>    <span>public</span><span> EventFactorySupport getEventFactorySupport() {  </span></span></li><li><span>        <span>return</span><span> </span><span>new</span><span> EventFactorySupport();  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>public</span><span> </span><span>void</span><span> afterPropertiesSet() </span><span>throws</span><span> Exception {  </span></span></li><li><span>        <span>try</span><span> {  </span></span></li><li><span>            initAction();  </span></li><li><span>        } <span>catch</span><span> (Exception ex) {  </span></span></li><li><span>            <span>throw</span><span> </span><span>new</span><span> BeanInitializationException(</span><span>&quot;Initialization of this Action failed: &quot;</span><span> + ex.getMessage(), ex);  </span></span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> </span><span>void</span><span> initAction() </span><span>throws</span><span> Exception {  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event success() {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().success(</span><span>this</span><span>);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event success(Object result) {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().success(</span><span>this</span><span>, result);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event error() {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().error(</span><span>this</span><span>);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event error(Exception e) {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().error(</span><span>this</span><span>, e);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event yes() {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().yes(</span><span>this</span><span>);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event no() {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().no(</span><span>this</span><span>);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event result(</span><span>boolean</span><span> booleanResult) {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().event(</span><span>this</span><span>, booleanResult);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event result(String eventId) {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().event(</span><span>this</span><span>, eventId);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event result(String eventId, AttributeMap resultAttributes) {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().event(</span><span>this</span><span>, eventId, resultAttributes);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event result(String eventId, String resultAttributeName, Object resultAttributeValue) {  </span></span></li><li><span>        <span>return</span><span> getEventFactorySupport().event(</span><span>this</span><span>, eventId, resultAttributeName, resultAttributeValue);  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>public</span><span> </span><span>final</span><span> Event execute(RequestContext context) </span><span>throws</span><span> Exception {  </span></span></li><li><span>        Event result = doPreExecute(context);  </span></li><li><span>        <span>if</span><span> (result == </span><span>null</span><span>) {  </span></span></li><li><span>            result = doExecute(context);  </span></li><li><span>            doPostExecute(context);  </span></li><li><span>        } <span>else</span><span> {  </span></span></li><li><span>            <span>if</span><span> (logger.isInfoEnabled()) {  </span></span></li><li><span>                logger.info(<span>&quot;Action execution disallowed; pre-execution result is '&quot;</span><span> + result.getId() + </span><span>&quot;'&quot;</span><span>);  </span></span></li><li><span>            }  </span></li><li><span>        }  </span></li><li><span>        <span>return</span><span> result;  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> String getActionNameForLogging() {  </span></span></li><li><span>        <span>return</span><span> ClassUtils.getShortName(getClass());  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>protected</span><span> Event doPreExecute(RequestContext context) </span><span>throws</span><span> Exception {  </span></span></li><li><span>        <span>return</span><span> </span><span>null</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>//抽象方法</span><span>  </span></span></li><li><span>    <span>protected</span><span> </span><span>abstract</span><span> Event doExecute(RequestContext context) </span><span>throws</span><span> Exception;  </span></span></li><li><span>  </span></li><li><span>    <span>protected</span><span> </span><span>void</span><span> doPostExecute(RequestContext context) </span><span>throws</span><span> Exception {  </span></span></li><li><span>    }  </span></li><li><span>}  </span></li></ol></div>在抽象类AbstractAction中，既有具体实现的方法，又有没有具体实现的抽象方法<p><br clear="none"/></p><p><br clear="none"/></p><div><div><div><strong>[java]</strong> <a href="http://blog.csdn.net/xw13106209/article/details/6923556#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/xw13106209/article/details/6923556#" shape="rect" title="copy">copy</a><div style="position: absolute; left: 704px; top: 3874px; width: 18px; height: 18px; z-index: 99;"><br clear="none"/></div></div></div><ol start="1"><li><span><span>//抽象方法</span><span>  </span></span></li><li><span><span>protected</span><span> </span><span>abstract</span><span> Event doExecute(RequestContext context) </span><span>throws</span><span> Exception;  </span></span></li></ol></div>需要注意的是在抽象类中，如果方法没有具体实现（就是方法后面<span style="color: #ff0000;"><strong>没有{}</strong></span>），那么必须加上abstract来声明这个方法，而接口中不需要使用abstract来声明<span style="color: #ff0000;"><strong>（抽象类之所以被称为抽象类，就是因为它包含有抽象方法。含有抽象方法的类叫做抽象类）</strong></span>。<br clear="none"/> </div></div>
</div></body></html> 