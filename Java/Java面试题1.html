<html>
<head>
  <title>Java面试题1</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="828"/>
<h1>Java面试题1</h1>

<div>
<div><div><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">1</span></strong><strong><span style="color: blue;">）</span><span style="color: blue;">transient</span></strong><strong><span style="color: blue;">和</span><span style="color: blue;">volatile</span></strong><strong><span style="color: blue;">是</span><span style="color: blue;">java</span></strong><strong><span style="color: blue;">关键字吗？（瞬联）</span></strong></p><p style="margin: 0cm 0cm 0pt;"><strong><span>如果用</span><span>transient</span></strong><span><strong>声明一个实例变量，当对象存储时，它的值不需要维持。</strong>例如：</span></p><p style="margin: 0cm 0cm 0pt;"><span>class T </span></p><p style="margin: 0cm 0cm 0pt;"><span>{<span>   </span></span></p><p style="margin: 0cm 0cm 0pt;"><span><span>      </span>transient int a;<span>  </span>//</span><span>不需要维持</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>      </span>int b;<span>  </span>//</span><span>需要维持</span></p><p style="margin: 0cm 0cm 0pt;"><span>}<span>  </span></span></p><p style="margin: 0cm 0cm 0pt;"><span>这里，如果</span><span>T</span><span>类的一个对象写入一个持久的存储区域，</span><span>a</span><span>的内容不被保存，但</span><span>b</span><span>的将被保存。</span></p><p style="margin: 0cm 0cm 0pt;"><strong><span>volatile</span><span>修饰符告诉编译器被</span><span>volatile</span></strong><span><strong>修饰的变量可以被程序的其他部分改变。</strong>在多线程程序中，有时两个或更多的线程共享一个相同的实例变量。考虑效率问题，每个线程可以自己保存该共享变量的私有拷贝。实际的变量副本在不同的时候更新，如当进入</span><span>synchronized</span><span>方法时。</span> <span>用</span><span>strictfp</span><span>修饰类或方法，可以确保浮点运算（以及所有切断）正如早期的</span><span>Java</span><span>版本那样准确。切断只影响某些操作的指数。当一个类被</span><span>strictfp</span><span>修饰，所有的方法自动被</span><span>strictfp</span><span>修饰。</span></p><p style="margin: 0cm 0cm 0pt;"><span>strictfp</span><span>的意思是</span><span>FP-strict</span><span>，也就是说精确浮点的意思。在</span><span>Java</span><span>虚拟机进行浮点运算时，如果没有指定</span><span>strictfp</span><span>关键字时，</span><span>Java</span><span>的编译器以及运行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令你满意。而一旦使用了</span><span>strictfp</span><span>来声明一个类、接口或者方法时，那么所声明的范围内</span><span>Java</span><span>的编译器以及运行环境会完全依照浮点规范</span><span>IEEE-754</span><span>来执行。因此如果你想让你的浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字</span><span>strictfp</span><span>。</span></p><p style="margin: 0cm 0cm 0pt;"><span>你可以将一个类、接口以及方法声明为</span><span>strictfp</span><span>，但是不允许对接口中的方法以及构造函数声明</span><span>strictfp</span><span>关键字，例如下面的代码：</span></p><p style="margin: 0cm 0cm 0pt;"><span>strictfp interface A {}</span></p><p style="margin: 0cm 0cm 0pt;"><span>public strictfp class FpDemo1 {<span>   </span></span></p><p style="margin: 0cm 0cm 0pt;"><span><span>      </span>strictfp void f() {}<span>   </span></span></p><p style="margin: 0cm 0cm 0pt;"><span>}<span>  </span></span></p><p style="margin: 0cm 0cm 0pt;"><span>2. </span><span>错误的使用方法</span></p><p style="margin: 0cm 0cm 0pt;"><span>interface A {<span>   </span></span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>strictfp void f();<span>   </span></span></p><p style="margin: 0cm 0cm 0pt;"><span>}<span>   </span></span></p><p style="margin: 0cm 0cm 0pt;"><span>public class FpDemo2 {<span>   </span></span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>strictfp FpDemo2() {}<span>   </span></span></p><p style="margin: 0cm 0cm 0pt;"><span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>一旦使用了关键字</span><span>strictfp</span><span>来声明某个类、接口或者方法时，那么在这个关键字所声明的范围内所有浮点运算都是精确的，符合</span><span>IEEE-754</span><span>规范</span></p><p style="margin: 0cm 0cm 0pt;"><span>的。例如一个类被声明为</span><span>strictfp</span><span>，那么该类中所有的方法都是</span><span>strictfp</span><span>的。</span></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">2</span></strong><strong><span style="color: blue;">）抽象类和接口有什么区别？（瞬联）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><span>1.abstract class </span><span>在</span><span> Java </span><span>语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个</span><span>interface</span><span>。</span></p><ol start="2"><li style="margin: 0cm 0cm 0pt;"><span>在</span><span>abstract class </span><span>中可以有自己的数据成员，也可以有非</span><span>abstarct</span><span>的成员方法，而在</span><span>interface</span><span>中，只能够有静态的不能被修改的数据成员（也就是必须是</span><span>static final</span><span>的，不过在</span><span> interface</span><span>中一般不定义数据成员），所有的成员方法都是</span><span>abstract</span><span>的。</span></li></ol><p style="margin: 0cm 0cm 0pt;"><span>3.abstract class</span><span>和</span><span>interface</span><span>所反映出的设计理念不同。其实</span><span>abstract class</span><span>表示的是</span><span>&quot;is-a&quot;</span><span>关系，</span><span>interface</span><span>表示的是</span><span>&quot;like-a&quot;</span><span>关系。</span></p><ol start="4"><li style="margin: 0cm 0cm 0pt;"><span>实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。</span></li><li style="margin: 0cm 0cm 0pt;"><span>接口中定义的变量默认是</span><span>public static final </span><span>型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。</span></li><li style="margin: 0cm 0cm 0pt;"><span>抽象类中的变量默认是</span><span> friendly </span><span>型，其值可以在子类中重新定义，也可以重新赋值。</span></li><li style="margin: 0cm 0cm 0pt;"><span>接口中的方法默认都是</span><span> public,abstract </span><span>类型的。</span></li></ol><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">3</span></strong><strong><span style="color: blue;">）能说一下</span><span style="color: blue;">java</span></strong><strong><span style="color: blue;">的反射</span><span style="color: blue;">(reflection)</span></strong><strong><span style="color: blue;">机制吗？（瞬联）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><span>开放性和原因连接</span><span>(causally-connected)</span><span>是反射系统的两大基本要素</span></p><table><tr><td colspan="1" rowspan="1"><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">4</span></strong><strong><span style="color: blue;">）在</span><span style="color: blue;">java</span></strong><strong><span style="color: blue;">中怎样实现多线程？（瞬联）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><span style="color: black;">extends Thread</span></p><p style="margin: 0cm 0cm 0pt;"><span style="color: black;">implement Runnable</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">方法一：继承</span><span style="font-size: 9pt;"> Thread </span><span style="font-size: 9pt;">类，覆盖方法</span><span style="font-size: 9pt;"> run()</span><span style="font-size: 9pt;">，我们在创建的</span><span style="font-size: 9pt;"> Thread </span><span style="font-size: 9pt;">类的子类中重写</span><span style="font-size: 9pt;"> run() ,</span><span style="font-size: 9pt;">加入线程所要执行的代码即可。下面是一个例子：</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">public class MyThread extends Thread<br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">{<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">int count= 1, number;<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">public MyThread(int num)<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">{<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">number = num;<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">System.out.println<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">(&quot;</span><span style="font-size: 9pt;">创建线程</span><span style="font-size: 9pt;"> &quot; + number);<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">public void run() {<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">while(true) {<br clear="none"/></span><span style="font-size: 9pt;">　　　　　</span><span style="font-size: 9pt;">System.out.println<br clear="none"/></span><span style="font-size: 9pt;">　　　　　　</span><span style="font-size: 9pt;">(&quot;</span><span style="font-size: 9pt;">线程</span><span style="font-size: 9pt;"> &quot; + number + &quot;:</span><span style="font-size: 9pt;">计数</span><span style="font-size: 9pt;"> &quot; + count);<br clear="none"/></span><span style="font-size: 9pt;">　　　　　</span><span style="font-size: 9pt;">if(++count== 6) return;<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">public static void main(String args[])<br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">{<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">for(int i = 0;i </span><span style="font-size: 9pt;">〈</span><span style="font-size: 9pt;"> 5; i++) new MyThread(i+1).start();<br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;"><br clear="none"/></span><span style="font-size: 9pt;">　　这种方法简单明了，符合大家的习惯，但是，它也有一个很大的缺点，那就是如果我们的类已经从一个类继承（如小程序必须继承自</span><span style="font-size: 9pt;"> Applet </span><span style="font-size: 9pt;">类），则无法再继承</span><span style="font-size: 9pt;"> Thread </span><span style="font-size: 9pt;">类，这时如果我们又不想建立一个新的类，应该怎么办呢？</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　我们不妨来探索一种新的方法：我们不创建</span><span style="font-size: 9pt;">Thread</span><span style="font-size: 9pt;">类的子类，而是直接使用它，那么我们只能将我们的方法作为参数传递给</span><span style="font-size: 9pt;"> Thread </span><span style="font-size: 9pt;">类的实例，有点类似回调函数。但是</span><span style="font-size: 9pt;"> Java </span><span style="font-size: 9pt;">没有指针，我们只能传递一个包含这个方法的类的实例。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　那么如何限制这个类必须包含这一方法呢？当然是使用接口！（虽然抽象类也可满足，但是需要继承，而我们之所以要采用这种新方法，不就是为了避免继承带来的限制吗？）</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">Java </span><span style="font-size: 9pt;">提供了接口</span><span style="font-size: 9pt;"> java.lang.Runnable </span><span style="font-size: 9pt;">来支持这种方法。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　方法二：实现</span><span style="font-size: 9pt;"> Runnable </span><span style="font-size: 9pt;">接口</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">Runnable</span><span style="font-size: 9pt;">接口只有一个方法</span><span style="font-size: 9pt;">run()</span><span style="font-size: 9pt;">，我们声明自己的类实现</span><span style="font-size: 9pt;">Runnable</span><span style="font-size: 9pt;">接口并提供这一方法，将我们的线程代码写入其中，就完成了这一部分的任务。但是</span><span style="font-size: 9pt;">Runnable</span><span style="font-size: 9pt;">接口并没有任何对线程的支持，我们还必须创建</span><span style="font-size: 9pt;">Thread</span><span style="font-size: 9pt;">类的实例，这一点通过</span><span style="font-size: 9pt;">Thread</span><span style="font-size: 9pt;">类的构造函数</span><span style="font-size: 9pt;"> public Thread(Runnable target);</span><span style="font-size: 9pt;">来实现。下面是一个例子：</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">public class MyThread implements Runnable<br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">{<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">int count= 1, number;<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">public MyThread(int num)<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">{<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">number = num;<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">System.out.println(&quot;</span><span style="font-size: 9pt;">创建线程</span><span style="font-size: 9pt;"> &quot; + number);<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">public void run()<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">{<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">while(true)<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">{<br clear="none"/></span><span style="font-size: 9pt;">　　　　　</span><span style="font-size: 9pt;">System.out.println<br clear="none"/></span><span style="font-size: 9pt;">　　　　　</span><span style="font-size: 9pt;">(&quot;</span><span style="font-size: 9pt;">线程</span><span style="font-size: 9pt;"> &quot; + number + &quot;:</span><span style="font-size: 9pt;">计数</span><span style="font-size: 9pt;"> &quot; + count);<br clear="none"/></span><span style="font-size: 9pt;">　　　　　</span><span style="font-size: 9pt;">if(++count== 6) return;<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">public static void main(String args[])<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">{<br clear="none"/></span><span style="font-size: 9pt;">　　　　</span><span style="font-size: 9pt;">for(int i = 0; i </span><span style="font-size: 9pt;">〈</span><span style="font-size: 9pt;"> 5;i++) new Thread(new MyThread(i+1)).start();<br clear="none"/></span><span style="font-size: 9pt;">　　　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">}<br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;"><br clear="none"/></span><span style="font-size: 9pt;">　　严格地说，创建</span><span style="font-size: 9pt;">Thread</span><span style="font-size: 9pt;">子类的实例也是可行的，但是必须注意的是，该子类必须没有覆盖</span><span style="font-size: 9pt;"> Thread </span><span style="font-size: 9pt;">类的</span><span style="font-size: 9pt;"> run </span><span style="font-size: 9pt;">方法，否则该线程执行的将是子类的</span><span style="font-size: 9pt;"> run </span><span style="font-size: 9pt;">方法，而不是我们用以实现</span><span style="font-size: 9pt;">Runnable </span><span style="font-size: 9pt;">接口的类的</span><span style="font-size: 9pt;"> run </span><span style="font-size: 9pt;">方法，对此大家不妨试验一下。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　使用</span><span style="font-size: 9pt;"> Runnable </span><span style="font-size: 9pt;">接口来实现多线程使得我们能够在一个类中包容所有的代码，有利于封装，它的缺点在于，我们只能使用一套代码，若想创建多个线程并使各个线程执行不同的代码，则仍必须额外创建类，如果这样的话，在大多数情况下也许还不如直接用多个类分别继承</span><span style="font-size: 9pt;"> Thread </span><span style="font-size: 9pt;">来得紧凑。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　综上所述，两种方法各有千秋，大家可以灵活运用。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　下面让我们一起来研究一下多线程使用中的一些问题。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　<strong><span>三、线程的四种状态</span></strong></span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">1. </span><span style="font-size: 9pt;">新状态：线程已被创建但尚未执行（</span><span style="font-size: 9pt;">start() </span><span style="font-size: 9pt;">尚未被调用）。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">2. </span><span style="font-size: 9pt;">可执行状态：线程可以执行，虽然不一定正在执行。</span><span style="font-size: 9pt;">CPU </span><span style="font-size: 9pt;">时间随时可能被分配给该线程，从而使得它执行。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">3. </span><span style="font-size: 9pt;">死亡状态：正常情况下</span><span style="font-size: 9pt;"> run() </span><span style="font-size: 9pt;">返回使得线程死亡。调用</span><span style="font-size: 9pt;"> stop()</span><span style="font-size: 9pt;">或</span><span style="font-size: 9pt;"> destroy() </span><span style="font-size: 9pt;">亦有同样效果，但是不被推荐，前者会产生异常，后者是强制终止，不会释放锁。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　</span><span style="font-size: 9pt;">4. </span><span style="font-size: 9pt;">阻塞状态：线程不会被分配</span><span style="font-size: 9pt;"> CPU </span><span style="font-size: 9pt;">时间，无法执行。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　<strong><span>四、线程的优先级</span></strong></span><strong><span style="font-size: 9pt;"><br clear="none"/></span></strong><span style="font-size: 9pt;"><br clear="none"/></span><span style="font-size: 9pt;">　　线程的优先级代表该线程的重要程度，当有多个线程同时处于可执行状态并等待获得</span><span style="font-size: 9pt;"> CPU </span><span style="font-size: 9pt;">时间时，线程调度系统根据各个线程的优先级来决定给谁分配</span><span style="font-size: 9pt;"> CPU </span><span style="font-size: 9pt;">时间，优先级高的线程有更大的机会获得</span><span style="font-size: 9pt;"> CPU </span><span style="font-size: 9pt;">时间，优先级低的线程也不是没有机会，只是机会要小一些罢了。</span><span style="font-size: 9pt;"><br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">　　你可以调用</span><span style="font-size: 9pt;"> Thread </span><span style="font-size: 9pt;">类的方法</span><span style="font-size: 9pt;"> getPriority() </span><span style="font-size: 9pt;">和</span><span style="font-size: 9pt;"> setPriority()</span><span style="font-size: 9pt;">来存取线程的优先级，线程的优先级界于</span><span style="font-size: 9pt;">1(MIN_PRIORITY)</span><span style="font-size: 9pt;">和</span><span style="font-size: 9pt;">10(MAX_PRIORITY)</span><span style="font-size: 9pt;">之间，缺省是</span><span style="font-size: 9pt;">5(NORM_PRIORITY)</span><span style="font-size: 9pt;">。</span></p></td></tr></table><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">5</span></strong><strong><span style="color: blue;">）你用过哪种设计模式？（瞬联，</span><span style="color: blue;">IBM</span></strong><strong><span style="color: blue;">，</span><span style="color: blue;">aspenTech</span></strong><strong><span style="color: blue;">）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><span>设计</span><span>:design</span></p><p style="margin: 0cm 0cm 0pt;"><span>模式</span><span>:pattern</span></p><p style="margin: 0cm 0cm 0pt;"><span>框架</span><span>:framework</span></p><p style="margin: 0cm 0cm 0pt;"><span>创建模式，结构模式和行为模式</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">GoF</span><span style="font-size: 9pt;">设计模式</span></p><ol><li style="margin: 0cm 0cm 0pt; text-align: left;"><span style="font-size: 9pt; color: black;"></span><strong><span style="font-size: 9pt; color: black;">创建模式</span></strong></li></ol><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Factory(</span><span style="font-size: 9pt;">工厂模式</span><span style="font-size: 9pt;">)</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">使用工厂模式就象使用</span><span style="font-size: 9pt;">new</span><span style="font-size: 9pt;">一样频繁</span><span style="font-size: 9pt;">.2002/10/9</span><span style="font-size: 9pt;">更新</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Prototype(</span><span style="font-size: 9pt;">原型模式</span><span style="font-size: 9pt;">)</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Builder</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">汽车由车轮</span> <span style="font-size: 9pt;">方向盘</span> <span style="font-size: 9pt;">发动机很多部件组成，同时，将这些部件组装成汽车也是一件复杂的工作，</span><span style="font-size: 9pt;">Builder</span><span style="font-size: 9pt;">模式就是将这两种情况分开进行。</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Singleton(</span><span style="font-size: 9pt;">单态模式</span><span style="font-size: 9pt;">)</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">保证一个类只有一个实例</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">并提供一个访问它的全局访问点</span><span style="font-size: 9pt;"> 2002/10/9</span><span style="font-size: 9pt;">更新</span></p><ol><li style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;"></span><strong><span style="font-size: 9pt;">结构模式</span></strong></li></ol><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Facade</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">可扩展的使用</span><span style="font-size: 9pt;">JDBC</span><span style="font-size: 9pt;">针对不同的数据库编程</span><span style="font-size: 9pt;">,Facade</span><span style="font-size: 9pt;">提供了一种灵活的实现</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Proxy</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">以</span><span style="font-size: 9pt;">Jive</span><span style="font-size: 9pt;">为例</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">剖析代理模式在用户级别授权机制上的应用</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Adapter</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">使用类再生的两个方式</span><span style="font-size: 9pt;">:</span><span style="font-size: 9pt;">组合</span><span style="font-size: 9pt;">(new)</span><span style="font-size: 9pt;">和继承</span><span style="font-size: 9pt;">(extends),</span><span style="font-size: 9pt;">这个已经在</span><span style="font-size: 9pt;">&quot;thinking in java&quot;</span><span style="font-size: 9pt;">中提到过</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Composite</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">就是将类用树形结构组合成一个单位</span><span style="font-size: 9pt;">.</span><span style="font-size: 9pt;">你向别人介绍你是某单位，你是单位中的一个元素，别人和你做买卖，相当于和单位做买卖。文章中还对</span><span style="font-size: 9pt;">Jive</span><span style="font-size: 9pt;">再进行了剖析。</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Decorator</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">Decorator</span><span style="font-size: 9pt;">是个油漆工</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">给你的东东的外表刷上美丽的颜色</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Bridge</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">将</span><span style="font-size: 9pt;">&quot;</span><span style="font-size: 9pt;">牛郎织女</span><span style="font-size: 9pt;">&quot;</span><span style="font-size: 9pt;">分开</span><span style="font-size: 9pt;">(</span><span style="font-size: 9pt;">本应在一起</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">分开他们</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">形成两个接口</span><span style="font-size: 9pt;">),</span><span style="font-size: 9pt;">在他们之间搭建一个桥</span><span style="font-size: 9pt;">(</span><span style="font-size: 9pt;">动态的结合</span><span style="font-size: 9pt;">)</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Flyweight</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">提供</span><span style="font-size: 9pt;">Java</span><span style="font-size: 9pt;">运行性能</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">降低小而大量重复的类的开销</span><span style="font-size: 9pt;">.</span></p><ol><li style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;"></span><strong><span style="font-size: 9pt;">行为模式</span></strong></li></ol><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Template</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">实际上向你介绍了为什么要使用</span><span style="font-size: 9pt;">Java </span><span style="font-size: 9pt;">抽象类</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">该模式原理简单</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">使用很普遍</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Memento</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">很简单一个模式</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">就是在内存中保留原来数据的拷贝</span><span style="font-size: 9pt;">. </span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Observer</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">介绍如何使用</span><span style="font-size: 9pt;">Java API</span><span style="font-size: 9pt;">提供的现成</span><span style="font-size: 9pt;">Observer</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Chain of Responsibility</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">各司其职的类串成一串</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">好象击鼓传花</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">当然如果自己能完成</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">就不要推委给下一个</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Command</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">什么是将行为封装</span><span style="font-size: 9pt;">,Command</span><span style="font-size: 9pt;">是最好的说明</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">State</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">状态是编程中经常碰到的实例</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">将状态对象化</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">设立状态变换器</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">便可在状态中轻松切换</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Strategy</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">不同算法各自封装</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">用户端可随意挑选需要的算法</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Mediator</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">Mediator</span><span style="font-size: 9pt;">很象十字路口的红绿灯</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">每个车辆只需和红绿灯交互就可以</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Interpreter</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">主要用来对语言的分析</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">应用机会不多</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Visitor</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">访问者在进行访问时</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">完成一系列实质性操作</span><span style="font-size: 9pt;">,</span><span style="font-size: 9pt;">而且还可以扩展</span><span style="font-size: 9pt;">.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">设计模式之</span><span style="font-size: 9pt;">Iterator</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">这个模式已经被整合入</span><span style="font-size: 9pt;">Java</span><span style="font-size: 9pt;">的</span><span style="font-size: 9pt;">Collection.</span><span style="font-size: 9pt;">在大多数场合下无需自己制造一个</span><span style="font-size: 9pt;">Iterator,</span><span style="font-size: 9pt;">只要将对象装入</span><span style="font-size: 9pt;">Collection</span><span style="font-size: 9pt;">中，直接使用</span><span style="font-size: 9pt;">Iterator</span><span style="font-size: 9pt;">进行对象遍历。</span></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">6</span></strong><strong><span style="color: blue;">）请说一下</span><span style="color: blue;">MVC</span></strong><strong><span style="color: blue;">架构（瞬联，</span><span style="color: blue;">IBM</span></strong><strong><span style="color: blue;">，</span><span style="color: blue;">aspenTech</span></strong><strong><span style="color: blue;">）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><span>Model:</span><span>模型层</span></p><p style="margin: 0cm 0cm 0pt;"><span>View:</span><span>视图层</span><span><span>   </span></span></p><p style="margin: 0cm 0cm 0pt;"><span>Controller:</span><span>控制层</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9pt;">MVC (Modal View Controler)</span><span style="font-size: 9pt;">本来是存在于</span><span style="font-size: 9pt;">Desktop</span><span style="font-size: 9pt;">程序中的，</span><span style="font-size: 9pt;">M</span><span style="font-size: 9pt;">是指数据模型，</span><span style="font-size: 9pt;">V</span><span style="font-size: 9pt;">是指用户界面，</span><span style="font-size: 9pt;">C</span><span style="font-size: 9pt;">则是控制器。使用</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">的目的是将</span><span style="font-size: 9pt;">M</span><span style="font-size: 9pt;">和</span><span style="font-size: 9pt;">V</span><span style="font-size: 9pt;">的实现代码分离，从而使同一个程序可以使用不同的表现形式。比如一批统计数据你可以分别用柱状图、饼图来表示。</span><span style="font-size: 9pt;">C</span><span style="font-size: 9pt;">存在的目的则是确保</span><span style="font-size: 9pt;">M</span><span style="font-size: 9pt;">和</span><span style="font-size: 9pt;">V</span><span style="font-size: 9pt;">的同步，一旦</span><span style="font-size: 9pt;">M</span><span style="font-size: 9pt;">改变，</span><span style="font-size: 9pt;">V</span><span style="font-size: 9pt;">应该同步更新。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">模型－视图－控制器（</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">）是</span><span style="font-size: 9pt;">Xerox PARC</span><span style="font-size: 9pt;">在八十年代为编程语言</span><span style="font-size: 9pt;">Smalltalk</span><span style="font-size: 9pt;">－</span><span style="font-size: 9pt;">80</span><span style="font-size: 9pt;">发明的一种软件设计模式，至今已被广泛使用。最近几年被推荐为</span><span style="font-size: 9pt;">Sun</span><span style="font-size: 9pt;">公司</span><span style="font-size: 9pt;">J2EE</span><span style="font-size: 9pt;">平台的设计模式，并且受到越来越多的使用</span><span style="font-size: 9pt;"> ColdFusion </span><span style="font-size: 9pt;">和</span><span style="font-size: 9pt;"> PHP </span><span style="font-size: 9pt;">的开发者的欢迎。模型－视图－控制器模式是一个有用的工具箱，它有很多好处，但也有一些缺点。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/><br clear="none"/>MVC</span><span style="font-size: 9pt;">如何工作</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/>MVC</span><span style="font-size: 9pt;">是一个设计模式，它强制性的使应用程序的输入、处理和输出分开。使用</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">视图</span><span style="font-size: 9pt;"> <br clear="none"/></span><span style="font-size: 9pt;">视图是用户看到并与之交互的界面。对老式的</span><span style="font-size: 9pt;">Web</span><span style="font-size: 9pt;">应用程序来说，视图就是由</span><span style="font-size: 9pt;">HTML</span><span style="font-size: 9pt;">元素组成的界面，在新式的</span><span style="font-size: 9pt;">Web</span><span style="font-size: 9pt;">应用程序中，</span><span style="font-size: 9pt;">HTML</span><span style="font-size: 9pt;">依旧在视图中扮演着重要的角色，但一些新的技术已层出不穷，它们包括</span><span style="font-size: 9pt;">Macromedia Flash</span><span style="font-size: 9pt;">和象</span><span style="font-size: 9pt;">XHTML</span><span style="font-size: 9pt;">，</span><span style="font-size: 9pt;">XML/XSL</span><span style="font-size: 9pt;">，</span><span style="font-size: 9pt;">WML</span><span style="font-size: 9pt;">等一些标识语言和</span><span style="font-size: 9pt;">Web services. <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">如何处理应用程序的界面变得越来越有挑战性。</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">一个大的好处是它能为你的应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，不管这些数据是联机存储的还是一个雇员列表，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">模型</span><span style="font-size: 9pt;"> <br clear="none"/></span><span style="font-size: 9pt;">模型表示企业数据和业务规则。在</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">的三个部件中，模型拥有最多的处理任务。例如它可能用象</span><span style="font-size: 9pt;">EJBs</span><span style="font-size: 9pt;">和</span><span style="font-size: 9pt;">ColdFusion Components</span><span style="font-size: 9pt;">这样的构件对象来处理数据库。被模型返回的数据是中立的，就是说模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">控制器</span><span style="font-size: 9pt;"> <br clear="none"/></span><span style="font-size: 9pt;">控制器接受用户的输入并调用模型和视图去完成用户的需求。所以当单击</span><span style="font-size: 9pt;">Web</span><span style="font-size: 9pt;">页面中的超链接和发送</span><span style="font-size: 9pt;">HTML</span><span style="font-size: 9pt;">表单时，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后用确定用哪个视图来显示模型处理返回的数据。</span><span style="font-size: 9pt;"> <span><br clear="none"/><br clear="none"/></span></span><span style="font-size: 9pt;">现在我们总结</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">的处理过程，首先控制器接收用户的请求，并决定应该调用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器用相应的视图格式化模型返回的数据，并通过表示层呈现给用户。</span><span style="font-size: 9pt;"> <br clear="none"/></span><span style="font-size: 9pt;">为什么要使用</span><span style="font-size: 9pt;"> MVC <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">大部分</span><span style="font-size: 9pt;">Web</span><span style="font-size: 9pt;">应用程序都是用像</span><span style="font-size: 9pt;">ASP</span><span style="font-size: 9pt;">，</span><span style="font-size: 9pt;">PHP</span><span style="font-size: 9pt;">，或者</span><span style="font-size: 9pt;">CFML</span><span style="font-size: 9pt;">这样的过程化语言来创建的。它们将像数据库查询语句这样的数据层代码和像</span><span style="font-size: 9pt;">HTML</span><span style="font-size: 9pt;">这样的表示层代码混在一起。经验比较丰富的开发者会将数据从表示层分离开来，但这通常不是很容易做到的，它需要精心的计划和不断的尝试。</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">从根本上强制性的将它们分开。尽管构造</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">应用程序需要一些额外的工作，但是它给我们带来的好处是无庸质疑的。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">首先，最重要的一点是多个视图能共享一个模型，正如我所提及的，现在需要用越来越多的方式来访问你的应用程序。对此，其中一个解决之道是使用</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">，无论你的用户想要</span><span style="font-size: 9pt;">Flash</span><span style="font-size: 9pt;">界面或是</span><span style="font-size: 9pt;"> WAP </span><span style="font-size: 9pt;">界面；用一个模型就能处理它们。由于你已经将数据和业务规则从表示层分开，所以你可以最大化的重用你的代码了。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">由于模型返回的数据没有进行格式化，所以同样的构件能被不同界面使用。例如，很多数据可能用</span><span style="font-size: 9pt;">HTML</span><span style="font-size: 9pt;">来表示，但是它们也有可能要用</span><span style="font-size: 9pt;">Macromedia Flash</span><span style="font-size: 9pt;">和</span><span style="font-size: 9pt;">WAP</span><span style="font-size: 9pt;">来表示。模型也有状态管理和数据持久性处理的功能，例如，基于会话的购物车和电子商务过程也能被</span><span style="font-size: 9pt;">Flash</span><span style="font-size: 9pt;">网站或者无线联网的应用程序所重用。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">因为模型是自包含的，并且与控制器和视图相分离，所以很容易改变你的应用程序的数据层和业务规则。如果你想把你的数据库从</span><span style="font-size: 9pt;">MySQL</span><span style="font-size: 9pt;">移植到</span><span style="font-size: 9pt;">Oracle</span><span style="font-size: 9pt;">，或者改变你的基于</span><span style="font-size: 9pt;">RDBMS</span><span style="font-size: 9pt;">数据源到</span><span style="font-size: 9pt;">LDAP</span><span style="font-size: 9pt;">，只需改变你的模型即可。一旦你正确的实现了模型，不管你的数据来自数据库或是</span><span style="font-size: 9pt;">LDAP</span><span style="font-size: 9pt;">服务器，视图将会正确的显示它们。由于运用</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">的应用程序的三个部件是相互对立，改变其中一个不会影响其它两个，所以依据这种设计思想你能构造良好的松偶合的构件。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">对我来说，控制器的也提供了一个好处，就是可以使用控制器来联接不同的模型和视图去完成用户的需求，这样控制器可以为构造应用程序提供强有力的手段。给定一些可重用的模型和视图，控制器可以根据用户的需求选择模型进行处理，然后选择视图将处理结果显示给用户。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/>MVC</span><span style="font-size: 9pt;">的缺点</span><span style="font-size: 9pt;"> <br clear="none"/>MVC</span><span style="font-size: 9pt;">的缺点是由于它没有明确的定义，所以完全理解</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">并不是很容易。使用</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">你将不得不花费相当可观的时间去考虑如何将</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">运用到你的应用程序，同时由于模型和视图要严格的分离，这样也给调试应用程序到来了一定的困难。每个构件在使用之前都需要经过彻底的测试。一旦你的构件经过了测试，你就可以毫无顾忌的重用它们了。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/></span><span style="font-size: 9pt;">根据我个人经验，由于我们将一个应用程序分成了三个部件，所以使用</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">同时也意味着你将要管理比以前更多的文件，这一点是显而易见的。这样好像我们的工作量增加了，但是请记住这比起它所能带给我们的好处是不值一提。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/>MVC</span><span style="font-size: 9pt;">并不适合小型甚至中等规模的应用程序，花费大量时间将</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">应用到规模并不是很大的应用程序通常会得不偿失。</span><span style="font-size: 9pt;"> <br clear="none"/><br clear="none"/>MVC</span><span style="font-size: 9pt;">是一条创建软件的好途径</span><span style="font-size: 9pt;"> <br clear="none"/>MVC</span><span style="font-size: 9pt;">设计模式是一个很好创建软件的途径，它所提倡的一些原则，像内容和显示互相分离可能比较好理解。但是如果你要隔离模型、视图和控制器的构件，你可能需要重新思考你的应用程序，尤其是应用程序的构架方面。如果你肯接受</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">，并且有能力应付它所带来的额外的工作和复杂性，</span><span style="font-size: 9pt;">MVC</span><span style="font-size: 9pt;">将会使你的软件在健壮性，代码重用和结构方面上一个新的台阶。</span></p><table><tr><td colspan="1" rowspan="1"><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">7</span></strong><strong><span style="color: blue;">）如果类</span><span style="color: blue;">a</span></strong><strong><span style="color: blue;">继承类</span><span style="color: blue;">b</span></strong><strong><span style="color: blue;">，实现接口</span><span style="color: blue;">c</span></strong><strong><span style="color: blue;">，而类</span><span style="color: blue;">b</span></strong><strong><span style="color: blue;">和接口</span><span style="color: blue;">c</span></strong><strong><span style="color: blue;">中定义了同名变量，请问会出现什么问题？（瞬联）</span></strong></p><p style="margin: 0cm 0cm 0pt;"><span><br clear="none"/></span><span>interface      A</span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>       int x = 0;<br clear="none"/>}<br clear="none"/>class B</span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>       int x =1;<br clear="none"/>}<br clear="none"/>class C extends B implements A</span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>       public void pX()</span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>        System.out.println(x);<br clear="none"/>     }<br clear="none"/>       public static void main(String[] args) {<br clear="none"/>          new C().pX();<br clear="none"/>       }<br clear="none"/>}<br clear="none"/></span><span>答案：错误。在编译时会发生错误</span><span>(</span><span>错误描述不同的</span><span>JVM</span><span>有不同的信息，意思就是未明确的</span><span>x</span><span>调用，两个</span><span>x</span><span>都匹配（就象在同时</span><span>import java.util</span><span>和</span><span>java.sql</span><span>两个包时直接声明</span><span>Date</span><span>一样）。对于父类的变量</span><span>,</span><span>可以用</span><span>super.x</span><span>来明确</span><span>(</span><span>输出的是</span><span>1)</span><span>，而接口的属性默认隐含为</span><span> public static final.</span><span>所以可以通过</span><span>A.x</span><span>来明确</span><span>(</span><span>输出的是</span><span>0)</span><span>。</span></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">下面的代码运行时会不会报错</span></strong><span><br clear="none"/>interface Playable </span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>        void play();<br clear="none"/>}<br clear="none"/>interface Bounceable </span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>        void play();<br clear="none"/>}<br clear="none"/>interface Rollable extends Playable, Bounceable </span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>        Ball ball = new Ball(&quot;PingPang&quot;);<br clear="none"/>}<br clear="none"/>class Ball implements Rollable </span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>        private String name;<br clear="none"/>        public String getName() </span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>            return name;<br clear="none"/>        }<br clear="none"/>        public Ball(String name) </span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>            this.name = name;        <br clear="none"/>        }<br clear="none"/>       public void play() </span></p><p style="margin: 0cm 0cm 0pt;"><span>{<br clear="none"/>            ball = new Ball(&quot;Football&quot;);<br clear="none"/>            System.out.println(ball.getName());<br clear="none"/>        }<br clear="none"/>}<br clear="none"/></span><span><br clear="none"/></span><span>答案</span><span>: </span><span>错。</span><span>&quot;interface Rollable extends Playable, Bounceable&quot;</span><span>没有问题。</span><span>interface</span><span>可继承多个</span><span>interfaces</span><span>，所以这里没错。问题出在</span><span>interface Rollable</span><span>里的</span><span>&quot;Ball ball = new Ball(&quot;PingPang&quot;);&quot;</span><span>。任何在</span><span>interface</span><span>里声明的</span><span>interface variable (</span><span>接口变量，也可称成员变量</span><span>)</span><span>，默认为</span><span>public static final</span><span>。也就是说</span><span>&quot;Ball ball = new Ball(&quot;PingPang&quot;);&quot;</span><span>实际上是</span><span>&quot;public static final Ball ball = new Ball(&quot;PingPang&quot;);&quot;</span><span>。在</span><span>Ball</span><span>类的</span><span>Play()</span><span>方法中，</span><span>&quot;ball = new Ball(&quot;Football&quot;);&quot;</span><span>改变了</span><span>ball</span><span>的</span><span>reference</span><span>，而这里的</span><span>ball</span><span>来自</span><span>Rollable interface</span><span>，</span><span>Rollable interface</span><span>里的</span><span>ball</span><span>是</span><span>public static final</span><span>的，</span><span>final</span><span>的</span><span>object</span><span>是不能被改变</span><span>reference</span><span>的。因此编译器将在</span><span>&quot;ball = new Ball(&quot;Football&quot;);&quot;</span><span>这里显示有错。</span></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">8</span></strong><strong><span style="color: blue;">）请说一下</span><span style="color: blue;">java</span></strong><strong><span style="color: blue;">中为什么要引入内部类？还有匿名内部类？（瞬联，</span><span style="color: blue;">IBM</span></strong><strong><span style="color: blue;">）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">9</span></strong><strong><span style="color: blue;">）请说一下</span><span style="color: blue;">final</span></strong><strong><span style="color: blue;">，</span><span style="color: blue;">finally</span></strong><strong><span style="color: blue;">和</span><span style="color: blue;">finalize</span></strong><strong><span style="color: blue;">的区别？（瞬联）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><span>final </span><span>用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</span></p><p style="margin: 0cm 0cm 0pt;"><span>finally</span><span>是异常处理语句结构的一部分，表示总是执行。</span></p><p style="margin: 0cm 0cm 0pt;"><span>finalize</span><span>是</span><span>Object</span><span>类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</span></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">10</span></strong><strong><span style="color: blue;">）请说一下</span><span style="color: blue;">HTTP</span></strong><strong><span style="color: blue;">请求的基本过程（</span><span style="color: blue;">IBM</span></strong><strong><span style="color: blue;">）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">11</span></strong><strong><span style="color: blue;">）</span><span style="color: blue;">java</span></strong><strong><span style="color: blue;">中存在内存泄漏问题吗？请举例说明？（</span><span style="color: blue;">IBM</span></strong><strong><span style="color: blue;">）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><span>会</span><span><span>  </span></span></p><p style="margin: 0cm 0cm 0pt;"><span style="color: #666666;">int i,i2;     return (i-i2);      //when i</span><span style="color: #666666;">为足够大的正数<span>,i2</span>为足够大的负数。结果会造成溢位，导致错误。<span><br clear="none"/><br clear="none"/></span></span></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">12</span></strong><strong><span style="color: blue;">）请说一下</span><span style="color: blue;">java</span></strong><strong><span style="color: blue;">中的内存回收机制所采用的算法（</span><span style="color: blue;">IBM</span></strong><strong><span style="color: blue;">，瞬联）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><span>虽然垃圾回收关心着大部分的问题，包括内存管理，使得程序员的任务显得更加轻松，但是程序员还是可能犯些错误导致内存泄漏问题。</span><span>GC(</span><span>垃圾回收</span><span>)</span><span>通过</span><span>递归</span><span>对所有从</span><span>“</span><span>根</span><span>”</span><span>对象</span><span>(</span><span>堆栈中的对象，静态数据成员，</span><span>JNI</span><span>句柄等等</span><span>)</span><span>继承下来的引用进行工作，然后标记所有可以访问的活动着的对象。而这些对象变成了程序唯一能够操纵的对象，其他的对象都被释放了。因为</span><span>GC</span><span>使得程序不能够访问那些被释放的对象，所以这样做是安全的。</span></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">13</span></strong><strong><span style="color: blue;">）请说一下</span><span style="color: blue;">System.gc()</span></strong><strong><span style="color: blue;">函数的作用。什么时候可以调用垃圾回收器？（瞬联）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><span>垃圾回收函数</span><span>,</span><span>手动调用的</span><span>.</span></p><p style="margin: 0cm 0cm 0pt;"><span style="color: #7b7d62;">当一个对象停止被活动声明所引用，它就变成了垃圾（</span><span style="color: #7b7d62;">garbage</span><span style="color: #7b7d62;">）可以被回收重新使用</span></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">14</span></strong><strong><span style="color: blue;">）你做过的项目中采用了什么安全认证机制？（</span><span style="color: blue;">IBM</span></strong><strong><span style="color: blue;">）</span> </strong></p><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">15</span></strong><strong><span style="color: blue;">）</span><span style="color: blue;">Math.round()</span></strong><strong><span style="color: blue;">什么作用？</span></strong></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9.5pt;">     Math.Round(3.44, 1) = 3.4<br clear="none"/>       Math.Round(3.45, 1) = 3.4<br clear="none"/>       Math.Round(3.46, 1) = 3.5<br clear="none"/>       -----------------------------------------------<br clear="none"/>       Math.Round(3.54, 1) = 3.5<br clear="none"/>       Math.Round(3.55, 1) = 3.6<br clear="none"/>       Math.Round(3.56, 1) = 3.6<br clear="none"/>       -----------------------------------------------<br clear="none"/>       Math.Round(3.64, 1) = 3.6<br clear="none"/>       Math.Round(3.65, 1) = 3.6<br clear="none"/>       Math.Round(3.66, 1) = 3.7<br clear="none"/>       -----------------------------------------------<br clear="none"/>       Math.Round(3.74, 1) = 3.7<br clear="none"/>       Math.Round(3.75, 1) = 3.8<br clear="none"/>       Math.Round(3.76, 1) = 3.8</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9.5pt;">这种舍入方法叫做银行家舍入（</span><span style="font-size: 9.5pt;">Banker'sRound</span><span style="font-size: 9.5pt;">），这就是已经规定下来的标准、</span><span style="font-size: 9.5pt;">Round</span><span style="font-size: 9.5pt;">的标准、世界的标准。</span></p><p style="margin: 0cm 0cm 0pt;"><span style="font-size: 9.5pt;">Round &lt;&gt; </span><span style="font-size: 9.5pt;">四舍五入</span></p></td></tr></table><p style="margin: 0cm 0cm 0pt 5pt;"><strong><span style="font-size: 10pt; color: blue;">16</span></strong><strong><span style="font-size: 10pt; color: blue;">、设计</span></strong><strong><span style="font-size: 10pt; color: blue;">4</span></strong><strong><span style="font-size: 10pt; color: blue;">个线程，其中两个线程每次对</span></strong><strong><span style="font-size: 10pt; color: blue;">j</span></strong><strong><span style="font-size: 10pt; color: blue;">增加</span></strong><strong><span style="font-size: 10pt; color: blue;">1</span></strong><strong><span style="font-size: 10pt; color: blue;">，另外两个线程对</span></strong><strong><span style="font-size: 10pt; color: blue;">j</span></strong><strong><span style="font-size: 10pt; color: blue;">每次减少</span></strong><strong><span style="font-size: 10pt; color: blue;">1</span></strong><strong><span style="font-size: 10pt; color: blue;">。写出程序。</span></strong><strong><span style="font-size: 10pt; color: blue;"><br clear="none"/></span></strong><strong><span style="font-size: 10pt; color: blue;">以下程序使用内部类实现线程，对</span></strong><strong><span style="font-size: 10pt; color: blue;">j</span></strong><strong><span style="font-size: 10pt; color: blue;">增减的时候没有考虑顺序问题。</span></strong><span style="font-size: 10pt;"><br clear="none"/><strong>package java_example150;</strong></span></p><p style="margin: 0cm 0cm 0pt 5pt;"><span style="font-size: 10pt;"><strong>public class TestThread3{<br clear="none"/> private int j;<br clear="none"/> public static void main(String[] args){<br clear="none"/>  TestThread3 t = new TestThread3();<br clear="none"/>     Inc inc = t.new Inc();<br clear="none"/>     Dec dec = t.new Dec();</strong></span></p><p style="margin: 0cm 0cm 0pt 5pt;"><span style="font-size: 10pt;"><strong>     for(int i=0;i&lt;2;i++){<br clear="none"/>      Thread ts = new Thread(inc);<br clear="none"/>      ts.start();<br clear="none"/>      ts= new Thread(dec);<br clear="none"/>      ts.start();<br clear="none"/>     }<br clear="none"/> }<br clear="none"/> private synchronized void inc(){<br clear="none"/>     j++;<br clear="none"/>     System.out.println(Thread.currentThread().getName()+&quot;-inc:&quot;+j);<br clear="none"/> }<br clear="none"/> private synchronized void dec(){<br clear="none"/>     j--;<br clear="none"/>     System.out.println(Thread.currentThread().getName()+&quot;-dec:&quot;+j);<br clear="none"/> }<br clear="none"/> class Inc implements Runnable{<br clear="none"/>    public void run(){<br clear="none"/>     for(int i=0;i&lt;10;i++){<br clear="none"/>      inc();<br clear="none"/>     }<br clear="none"/>    }<br clear="none"/> }</strong></span></p><p style="margin: 0cm 0cm 0pt 5pt;"><span style="font-size: 10pt;"><strong> class Dec implements Runnable{<br clear="none"/>  public void run(){<br clear="none"/>   for(int i=0;i&lt;10;i++){<br clear="none"/>    dec();<br clear="none"/>   }<br clear="none"/>     }<br clear="none"/> }<br clear="none"/>}</strong></span></p><p style="margin: 0cm 0cm 0pt 5pt;"> </p><ol start="7"><li style="margin: 0cm 0cm 0pt;"><span style="color: blue;"></span><strong><span style="font-size: 10pt; color: blue;">CORBA</span></strong><strong><span style="font-size: 10pt; color: blue;">是什么</span></strong><strong><span style="font-size: 10pt; color: blue;">?</span></strong><strong><span style="font-size: 10pt; color: blue;">用途是什么</span></strong><strong><span style="font-size: 10pt; color: blue;">? </span></strong><strong><span style="color: blue;"><br clear="none"/></span></strong><strong><span style="font-size: 10pt;">答：</span></strong><span style="font-size: 10pt;">CORBA </span><span style="font-size: 10pt;">标准是公共对象请求代理结构</span><span style="font-size: 10pt;">(Common Object Request Broker Architecture)</span><span style="font-size: 10pt;">，由对象管理组织</span><span style="font-size: 10pt;"> (Object Management Group</span><span style="font-size: 10pt;">，缩写为</span><span style="font-size: 10pt;"> OMG)</span><span style="font-size: 10pt;">标准化。它的组成是接口定义语言</span><span style="font-size: 10pt;">(IDL), </span><span style="font-size: 10pt;">语言绑定</span><span style="font-size: 10pt;">(binding:</span><span style="font-size: 10pt;">也译为联编</span><span style="font-size: 10pt;">)</span><span style="font-size: 10pt;">和允许应用程序间互操作的协议。</span> <span style="font-size: 10pt;">其目的为：</span><span><br clear="none"/></span><span style="font-size: 10pt;">1. 用不同的程序设计语言书写</span><span style="font-size: 10pt;"> <br clear="none"/></span><span style="font-size: 10pt;">2. 在不同的进程中运行</span><span style="font-size: 10pt;"> <br clear="none"/></span><span style="font-size: 10pt;">3. 为不同的操作系统开发</span></li></ol><p style="margin: 0cm 0cm 0pt;"><strong><span style="color: blue;">18.JAVA</span></strong><strong><span style="color: blue;">代码查错</span></strong></p><ul><li style="margin: 0cm 0cm 0pt;"></li></ul><p style="margin: 0cm 0cm 0pt;"><span>abstract class Name </span></p><p style="margin: 0cm 0cm 0pt;"><span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>private String name;</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>public abstract boolean isStupidName(String name) {}</span></p><p style="margin: 0cm 0cm 0pt;"><span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>答案</span><span>: </span><span>错。</span><strong><span>abstract method</span><span>必须以分号结尾，且不带花括号。</span></strong></p><ul><li style="margin: 0cm 0cm 0pt;"></li></ul><p style="margin: 0cm 0cm 0pt;"><span>public class Something </span></p><p style="margin: 0cm 0cm 0pt;"><span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>void doSomething () </span></p><p style="margin: 0cm 0cm 0pt;"><span><span>   </span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>        </span>private String s = &quot;&quot;;</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>        </span>int l = s.length();</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>答案</span><span>: </span><span>错。<strong>局部变量前不能放置任何访问修饰符</strong></span><strong><span> (private</span><span>，</span><span>public</span><span>，和</span><span>protected)</span><span>。</span><span>final</span><span>可以用来修饰局部变量</span></strong></p><p style="margin: 0cm 0cm 0pt;"><span>(final</span><span>如同</span><span>abstract</span><span>和</span><span>strictfp</span><span>，都是非访问修饰符，</span><span>strictfp</span><span>只能修饰</span><span>class</span><span>和</span><span>method</span><span>而非</span><span>variable)</span><span>。</span></p><ul><li style="margin: 0cm 0cm 0pt;"></li></ul><p style="margin: 0cm 0cm 0pt;"><span>abstract class Something </span></p><p style="margin: 0cm 0cm 0pt;"><span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>private abstract String doSomething ();</span></p><p style="margin: 0cm 0cm 0pt;"><span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>答案</span><span>: </span><span>错。</span><strong><span>abstract</span><span>的</span><span>methods</span><span>不能以</span><span>private</span><span>修饰。</span></strong><span>abstract</span><span>的</span><span>methods</span><span>就是让子类</span><span>implement(</span><span>实现</span><span>)</span><span>具体细节的，怎么可以用</span><span>private</span><span>把</span><span>abstract</span><span>method</span><span>封锁起来呢</span><span>? (</span><span>同理，</span><span>abstract method</span><span>前不能加</span><span>final)</span><span>。</span></p><ul><li style="margin: 0cm 0cm 0pt;"></li></ul><p style="margin: 0cm 0cm 0pt;"><span>public class Something </span></p><p style="margin: 0cm 0cm 0pt;"><span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>public int addOne(final int x) </span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>        </span>return ++x;</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>答案</span><span>: </span><span>错。</span><span>int x</span><span>被修饰成</span><span>final</span><span>，意味着</span><span>x</span><span>不能在</span><span>addOne method</span><span>中被修改。</span></p><ul><li style="margin: 0cm 0cm 0pt;"></li></ul><p style="margin: 0cm 0cm 0pt;"><span>public class Something </span></p><p style="margin: 0cm 0cm 0pt;"><span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>public static void main(String[] args) </span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>        </span>Other o = new Other();</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>        </span>new Something().addOne(o);</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>public void addOne(final Other o) </span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>        </span>o.i++;</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>class Other </span></p><p style="margin: 0cm 0cm 0pt;"><span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>public int i;</span></p><p style="margin: 0cm 0cm 0pt;"><span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>答案</span><span>: </span><span>正确。在</span><span>addOne method</span><span>中，参数</span><span>o</span><span>被修饰成</span><span>final</span><span>。如果在</span><span>addOne method</span><span>里我们修改了</span><span>o</span><span>的</span><span>reference</span></p><p style="margin: 0cm 0cm 0pt;"><span>(</span><span>比如</span><span>: o = new Other();)</span><span>，那么如同上例这题也是错的。但这里修改的是</span><span>o</span><span>的</span><span>member vairable</span></p><p style="margin: 0cm 0cm 0pt;"><span>(</span><span>成员变量</span><span>)</span><span>，而</span><span>o</span><span>的</span><span>reference</span><span>并没有改变。</span></p><ul><li style="margin: 0cm 0cm 0pt;"></li></ul><p style="margin: 0cm 0cm 0pt;"><span>class Something </span></p><p style="margin: 0cm 0cm 0pt;"><span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>int i;</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>public void doSomething() </span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>         </span>System.out.println(&quot;i = &quot; + i);</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>} </span></p><p style="margin: 0cm 0cm 0pt;"><span>答案</span><span>: </span><span>正确。输出的是</span><span>&quot;i = 0&quot;</span><span>。</span><span>int i</span><span>属於</span><span>instant variable (</span><span>实例变量，或叫成员变量</span><span>)</span><span>。</span><span>instant variable</span><span>有</span><span>default value</span><span>。</span><span>int</span><span>的</span><span>default value</span><span>是</span><span>0</span><span>。</span></p><ul><li style="margin: 0cm 0cm 0pt;"></li></ul><p style="margin: 0cm 0cm 0pt;"><span>class Something </span></p><p style="margin: 0cm 0cm 0pt;"><span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>final int i;</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>public void doSomething() </span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>         </span>System.out.println(&quot;i = &quot; + i);</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>答案</span><span>: </span><span>错。</span><strong><span>final int i </span><span>是个</span><span>final</span><span>的 </span><span>instant variable (</span><span>实例变量，或叫成员变量</span><span>)</span><span>。</span><span>final</span><span>的</span><span>instant variable</span><span>没有</span><span>default value</span><span>，必须在</span></strong><strong><span>constructor (</span><span>构造器</span><span>)</span></strong><span><strong>结束之前被赋予一个明确的值。</strong>可以修改为</span><span>&quot;final int i = 0;&quot;</span><span>。</span></p><ul><li style="margin: 0cm 0cm 0pt;"></li></ul><p style="margin: 0cm 0cm 0pt;"><span>public class Something </span></p><p style="margin: 0cm 0cm 0pt;"><span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>      </span>public static void main(String[] args) </span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>         </span>Something s = new Something();</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>         </span>System.out.println(&quot;s.doSomething() returns &quot; + doSomething());</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>public String doSomething() </span></p><p style="margin: 0cm 0cm 0pt;"><span><span>    </span>{</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>         </span>return &quot;Do something ...&quot;;</span></p><p style="margin: 0cm 0cm 0pt;"><span><span>     </span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>}</span></p><p style="margin: 0cm 0cm 0pt;"><span>答案</span><span>: </span><span>错。看上去在</span><span>main</span><span>里</span><span>call doSomething</span><span>没有什么问题，毕竟两个</span><span>methods</span><span>都在同一个</span><span>class</span><span>里。但仔细看，</span><span>main</span><span>是</span><span>static</span><span>的。</span><span><strong>static </strong></span><strong><span>method</span><span>不能直接</span><span>call non-static methods</span></strong><span><strong>。</strong>可改成</span><span>&quot;System.out.println(&quot;s.doSomething() returns &quot; + s.doSomething());&quot;</span><span>。同理，</span><strong><span>static method</span><span>不能访问</span><span>non-static instant variable</span><span>。</span></strong></p></div></div>
</div></body></html> 