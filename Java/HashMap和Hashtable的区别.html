<html>
<head>
  <title>HashMap和Hashtable的区别</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1128"/>
<h1>HashMap和Hashtable的区别</h1>

<div>
<div><div>导读： <br clear="none"/> <br clear="none"/><p>1 HashMap不是线程安全的</p><br clear="none"/><p>            hastmap是一个接口 是map接口的子接口，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap允许null key和null value，而hashtable不允许。</p><br clear="none"/><p>2   HashTable是线程安全的一个Collection。</p><br clear="none"/><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。<br clear="none"/> HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。<br clear="none"/> HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 <br clear="none"/> Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。<br clear="none"/> 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 <br clear="none"/> Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</p><br clear="none"/><p>public static void main(String args[])<br clear="none"/> {<br clear="none"/> HashTable h=new HashTable();<br clear="none"/> h.put(&quot;用户1&quot;,new Integer(90));<br clear="none"/> h.put(&quot;用户2&quot;,new Integer(50));<br clear="none"/> h.put(&quot;用户3&quot;,new Integer(60));<br clear="none"/> h.put(&quot;用户4&quot;,new Integer(70));<br clear="none"/> h.put(&quot;用户5&quot;,new Integer(80));<br clear="none"/> Enumeration e=h.elements();<br clear="none"/> while(e.hasMoreElements()){<br clear="none"/> System.out.println(e.nextElement());<br clear="none"/> }</p><br clear="none"/><p>map 的方法：</p><br clear="none"/><p>clear()从 Map 中删除所有映射</p><br clear="none"/><p>remove(Object key)从 Map 中删除键和关联的值</p><br clear="none"/>        put(Object key, Object value)将指定值与指定键相关联 <br clear="none"/><p>get(Object key)返回与指定键关联的值</p><br clear="none"/> containsKey(Object key)如果 Map 包含指定键的映射，则返回 true <br clear="none"/><p> </p><br clear="none"/><p> </p><br clear="none"/><p>containsValue(Object value)如果此 Map 将一个或多个键映射到指定值，则返回 true</p><br clear="none"/><p>isEmpty()如果 Map 不包含键-值映射，则返回 true size()返回 Map 中的键-值映射的数目</p><br clear="none"/> <br clear="none"/> <br clear="none"/> <br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>这些都代表了</span><span>Java</span><span>中的集合，这里主要从其元素是否有序，是否可重复来进行区别记忆，以便恰当地使用，当然还存在同步方面的差异，见上一篇相关文章。</span></p><br clear="none"/> <br clear="none"/><table><tr><td colspan="2" rowspan="1" style="width: 110.15pt; border: windowtext 1pt solid; padding: 0cm 5.4pt 0cm 5.4pt;" width="147"><br clear="none"/></td><td colspan="1" rowspan="1" style="width: 183.7pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="245"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>有序否</span></p></td><td colspan="1" rowspan="1" style="width: 132.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="176"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>允许元素重复否</span></p></td></tr><tr><td colspan="2" rowspan="1" style="width: 110.15pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="147"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>Collection</span></p></td><td colspan="1" rowspan="1" style="width: 183.7pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="245"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>否</span></p></td><td colspan="1" rowspan="1" style="width: 132.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="176"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>是</span></p></td></tr><tr><td colspan="2" rowspan="1" style="width: 110.15pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="147"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>List</span></p></td><td colspan="1" rowspan="1" style="width: 183.7pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="245"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>是</span></p></td><td colspan="1" rowspan="1" style="width: 132.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="176"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>是</span></p></td></tr><tr style="height: 5.25pt;"><td colspan="1" rowspan="3" style="width: 41.75pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="56"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>Set</span></p></td><td colspan="1" rowspan="1" style="width: 68.4pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="91"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>AbstractSet</span></p></td><td colspan="1" rowspan="2" style="width: 183.7pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="245"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>否</span></p></td><td colspan="1" rowspan="3" style="width: 132.25pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="176"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>否</span></p></td></tr><tr style="height: 5.25pt;"><td colspan="1" rowspan="1" style="width: 68.4pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="91"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>HashSet</span></p></td></tr><tr style="height: 5.25pt;"><td colspan="1" rowspan="1" style="width: 68.4pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="91"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>TreeSet</span></p></td><td colspan="1" rowspan="1" style="width: 183.7pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="245"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>是（用二叉树排序）</span></p></td></tr><tr style="height: 5.25pt;"><td colspan="1" rowspan="3" style="width: 41.75pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="56"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>Map</span></p></td><td colspan="1" rowspan="1" style="width: 68.4pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="91"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>AbstractMap</span></p></td><td colspan="1" rowspan="2" style="width: 183.7pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="245"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>否</span></p></td><td colspan="1" rowspan="3" style="width: 132.25pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="176"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>使用</span><span>key-value</span><span>来映射和存储数据，</span><span>Key</span><span>必须惟一，</span><span>value</span><span>可以重复</span></p></td></tr><tr style="height: 5.25pt;"><td colspan="1" rowspan="1" style="width: 68.4pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="91"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>HashMap</span></p></td></tr><tr style="height: 5.25pt;"><td colspan="1" rowspan="1" style="width: 68.4pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="91"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>TreeMap</span></p></td><td colspan="1" rowspan="1" style="width: 183.7pt; height: 5.25pt; padding: 0cm 5.4pt 0cm 5.4pt;" width="245"><br clear="none"/><p style="margin: 0cm 0cm 0pt;"><span>是（用二叉树排序）</span></p></td></tr></table><br clear="none"/><p> </p><p> </p><br clear="none"/><p> </p><br clear="none"/><p>List 接口对Collection进行了简单的扩充，它的具体实现类常用的有ArrayList和LinkedList。你可以将任何东西放到一个List容器 中，并在需要时从中取出。ArrayList从其命名中可以看出它是一种类似数组的形式进行存储，因此它的随机访问速度极快，而LinkedList的内 部实现是链表，它适合于在链表中间需要频繁进行插入和删除操作。在具体应用时可以根据需要自由选择。前面说的Iterator只能对容器进行向前遍历，而 ListIterator则继承了Iterator的思想，并提供了对List进行双向遍历的方法。 <br clear="none"/> <br clear="none"/> Set接口也是 Collection的一种扩展，而与List不同的时，在Set中的对象元素不能重复，也就是说你不能把同样的东西两次放入同一个Set容器中。它的常 用具体实现有HashSet和TreeSet类。HashSet能快速定位一个元素，但是你放到HashSet中的对象需要实现hashCode()方 法，它使用了前面说过的哈希码的算法。而TreeSet则将放入其中的元素按序存放，这就要求你放入其中的对象是可排序的，这就用到了集合框架提供的另外 两个实用类Comparable和Comparator。一个类是可排序的，它就应该实现Comparable接口。有时多个类具有相同的排序算法，那就 不需要在每分别重复定义相同的排序算法，只要实现Comparator接口即可。集合框架中还有两个很实用的公用类：Collections和 Arrays。Collections提供了对一个Collection容器进行诸如排序、复制、查找和填充等一些非常有用的方法，Arrays则是对一 个数组进行类似的操作。 <br clear="none"/> <br clear="none"/> <br clear="none"/>             Map是一种把键对象和值对象进行关联的容器，而一个值对象又可以是一个Map，依次类推，这样就可形成一个多级映射。对于键对象来说，像Set一样，一 个Map容器中的键对象不允许重复，这是为了保持查找结果的一致性;如果有两个键对象一样，那你想得到那个键对象所对应的值对象时就有问题了，可能你得到 的并不是你想的那个值对象，结果会造成混乱，所以键的唯一性很重要，也是符合集合的性质的。当然在使用过程中，某个键所对应的值对象可能会发生变化，这时 会按照最后一次修改的值对象与键对应。对于值对象则没有唯一性的要求。你可以将任意多个键都映射到一个值对象上，这不会发生任何问题（不过对你的使用却可 能会造成不便，你不知道你得到的到底是那一个键所对应的值对象）。Map有两种比较常用的实现： HashMap和TreeMap。HashMap也用到了哈希码的算法，以便快速查找一个键，TreeMap则是对键按序存放，因此它便有一些扩展的方 法，比如firstKey(),lastKey()等，你还可以从TreeMap中指定一个范围以取得其子Map。键和值的关联很简单，用pub (Object key,Object value)方法即可将一个键与一个值对象相关联。用get(Object key)可得到与此key对象所对应的值对象。</p></div></div>
</div></body></html> 