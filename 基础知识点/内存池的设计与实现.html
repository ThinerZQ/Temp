<html>
<head>
  <title>内存池的设计与实现</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1173"/>
<h1>内存池的设计与实现</h1>

<div>
<div><div><h2 style="text-align: left;">1. 内存池设计</h2><h3><a name="t1" shape="rect"></a>1.1 目的</h3><p><span style="font-family: mceinline;"><span style="white-space: pre;"> </span>在给定的内存buffer上建立内存管理机制，根据用户需求从该buffer上分配内存或者将已经分配的内存释放回buffer中。</span></p><h3><a name="t2" shape="rect"></a><span style="font-family: mceinline;">1.2 要求</span></h3><p><span style="font-family: mceinline;"><span style="white-space: pre;"> </span>尽量减少内存碎片，平均效率高于C语言的malloc和free。</span></p><h3><a name="t3" shape="rect"></a><span style="font-family: mceinline;">1.3 设计思路</span></h3><p><span style="font-family: mceinline;"><span style="white-space: pre;"> </span>将buffer分为四部分，第1部分是mem_pool结构体；第2部分是内存映射表；第3部分是内存chunk结构体缓冲区；第4部分是实际可分配的内存区。整个buffer结构图如图1所示：</span></p><p style="text-align: center;"><span style="font-family: mceinline;"><img alt="图1 内存buffer结构图" height="357" src="http://hi.csdn.net/attachment/201106/28/9373112_13092470699V2p.jpg" width="554"></img></span></p><p style="text-align: center;"><span style="font-family: mceinline;"><span style="font-family: mceinline;">图1 内存buffer结构图</span></span></p><p style="text-align: left;"><span style="font-family: mceinline;"><span style="font-family: mceinline;"><span style="white-space: pre;"> </span>第1部分的作用是可以通过该mem_pool结构体控制整个内存池。</span></span></p><p style="text-align: left;"><span style="font-family: mceinline;"><span style="font-family: mceinline;"><span style="white-space: pre;"> </span>第2部分的作用是记录第4部分，即实际可分配的内存区的使用情况。表中的每一个单元表示一个固定大小的内存块（block），多个连续的block组成一个chunk，每个block的详细结构如图2所示：</span></span></p><p style="text-align: center;"><span style="font-family: mceinline;"><span style="font-family: mceinline;"><img alt="图2 memory block结构图" height="122" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247069ugHx.jpg" width="157"></img></span></span></p><p style="text-align: center;"><span style="font-family: mceinline;"><span style="font-family: mceinline;">图2 memory block结构图</span></span></p><p><span style="font-family: mceinline;">其中count表示该block后面的与该block同属于一个 chunk的blokc的个数，start表示该block所在的chunk的起始block索引。其实start这个域只有在每个chunk的最后一个 block中才会用到（用于从当前chunk寻找前一个chunk的起始位置），而pmem_chunk则是一个指针，指向一个mem_chunk结构 体。任意一块大小的内存都会被取向上整到block大小的整数倍。</span></p><p><span style="font-family: mceinline;"><span style="white-space: pre;"> </span>第3部分是一个mem_chunk pool，其作用是存储整个程序可用的mem_chunk结构体。</span>mem_chunk pool中的mem_chunk被组织成双向链表结构（快速插入和删除）。每个mem_chunk结构图如图3所示：</p><p style="text-align: center;"><img alt="图3 memory chunk结构图" height="113" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247070HI91.jpg" width="157"></img></p><p style="text-align: center;">图3 memory chunk结构图</p><p style="text-align: left;">其中pmem_block指向该chunk在内存映射表中的位置，others表示其他一些域，不同的实现对应该域的内容略有不同。</p><p style="text-align: left;"><span style="white-space: pre;"> </span>第4部分就是实际可以被分配给用户的内存。</p><p style="text-align: left;"><span style="white-space: pre;"> </span>整个内 存池管理程序除了这四部分外，还有一个重要的内容就是memory chunk set。虽然其中的每个元素都来自mem_chunk pool，但是它与mem_chunk pool的不同之处在于其中的每个memory chunk中记录了当前可用的一块内存的相关信息。而mem_chunk pool中的memory chunk的内容是无定以的。可以这样理解mem_chunk pool与memory chunk set：mem_chunk pool是为memory chunk set分配内存的“内存池”，只是该“内存池”每次分配的内存大小是固定的，为mem_chunk结构体的大小。内存池程序主要是通过搜索这个 memory chunk set来获取可被分配的内存。在memory chunk set上建立不同的数据结构就构成了不同的内存池实现方法，同时也导致了不同的搜索效率，直接影响内存池的性能，本文稍后会介绍两种内存池的实现。</p><h3><a name="t4" shape="rect"></a>1.4 内存池管理程序运行过程</h3><ul><li>初始化：内存映射表中只有一块可用的内存信息，大小为内存池中所有可用的内存。从memory chunk pool中分配一个mem_chunk，使其指向内存映射表中的第一个block，并根据具体的内存池实现方式填充mem_chunk中的其他域，然后将 该mem_chunk添加到memory chunk set中。</li><li>申请内存：当用户申请一块内存时，首先在memory chunk set中查找合适的内存块。如果找到符合要求的内存块，就在内存映射表中找到相应的chunk，并修改chunk中相应block结构体的内容，然后根据 修改后的chunk修改memory chunk set中chunk的内容，最后返回分配内存的起始地址；否则返回NULL。</li><li>释放内存：当用户释放一块内存时，首先根据这块内存的起始地址找到其在内存映射表中对应的chunk，然后尝试将该chunk和与其相邻的 chunk合并，修改chunk中相应block的内容并修改memory chunk set中相应chunk的内容或者向memory chunk set加入新的mem_chunk（这种情况在不能合并内存是发生）。</li></ul><h3><a name="t5" shape="rect"></a>1.5 减少内存碎片</h3><p><span style="white-space: pre;"> </span>本文设计的方法只能在一定程度上减少内存碎片，并不能彻底消除内存碎片。具体方法如下：</p><p><span style="white-space: pre;"> </span>在用户释放内存时，尝试将该内存与其相邻的内存合并。如果其相邻内存为未分配内存则合并成功，合并后作为一整块内存使用；如火其相邻内存为已分配内存则不能合并，该释放的内存块作为一个独立的内存块被使用。</p><h2><a name="t6" shape="rect"></a>2 内存池实现-链表结构</h2><h3><a name="t7" shape="rect"></a>2.1 性能分析</h3><p><span style="white-space: pre;"> </span>链表结构的内存池实现是指将memory chunk set实现为双链表结构。这种方法的优缺点如下：</p><p><span style="white-space: pre;"> </span>优点：释放内存很快，O(1)复杂度。</p><p><span style="white-space: pre;"> </span>缺点：分配内存较慢，O(n)复杂度。</p><h3><a name="t8" shape="rect"></a>2.2 内存池运行状态转移图</h3><p><span style="white-space: pre;"> </span>绿色表示未使用的内存，红色表示已经使用的内存。其中每个block表示64B，这个值可以根据具体需要设定。</p><ul><li>初始化</li></ul><p style="text-align: center;"><img alt="图4 内存池初始化状态" height="255" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247070n3vC.jpg" width="555"></img></p><p style="text-align: center;">图4 内存池初始化状态</p><ul><li>申请内存</li></ul><p style="text-align: center;"><img alt="图5 第1次申请128B内存后" height="255" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247071ps5g.jpg" width="555"></img></p><p style="text-align: center;">图5 第1次申请128B内存后</p><p style="text-align: center;"><img alt="图6 第n次申请、释放内存后" height="210" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247071BuEH.jpg" width="555"></img></p><p style="text-align: center;">图6 第n次申请、释放内存后</p><ul><li>释放内存</li></ul><p><br clear="none"/></p><p style="text-align: center;"><img alt="图7 释放64B内存前后" height="574" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247073BWsK.jpg" width="555"></img></p><p style="text-align: center;">图7 释放64B内存前后</p><h2><a name="t9" shape="rect"></a>3 内存池实现-大顶堆结构</h2><h3><a name="t10" shape="rect"></a>3.1 性能分析</h3><p> </p><p><span style="white-space: pre;"> </span>大顶堆结构的内存池实现是指将memory chunk set实现为大顶堆结构。这种方法的优缺点如下：</p><p><span style="white-space: pre;"> </span>优点：降低了分配内存的时间复杂度，O(log(n))。<span style="white-space: pre;"> </span></p><p><span style="white-space: pre;"> </span>缺点：增加了释放内存的时间复杂度，O(log(n))。</p><h3><a name="t11" shape="rect"></a>3.2 内存池运行状态转移图</h3><p><span style="white-space: pre;"> </span>绿色表示未使用的内存，红色表示已经使用的内存。其中每个block表示64B，这个值可以根据具体需要设定。</p><ul><li>初始化</li></ul><p style="text-align: center;"><span style="white-space: pre;"> </span><img alt="图8 内存池初始化状态" height="297" src="http://hi.csdn.net/attachment/201106/28/9373112_13092470748RJZ.jpg" width="554"></img></p><p style="text-align: center;">图8 内存池初始化状态</p><ul><li>申请内存</li></ul><p style="text-align: center;"><img alt="图9 第1次申请128B内存后" height="272" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247074R0V8.jpg" width="554"></img></p><p style="text-align: center;">图9 第1次申请128B内存后</p><p style="text-align: center;"><img alt="图10 第n次申请、释放内存后" height="278" src="http://hi.csdn.net/attachment/201106/28/9373112_13092470753981.jpg" width="554"></img></p><p style="text-align: center;">图10 第n次申请、释放内存后</p><ul><li>释放内存</li></ul><p style="text-align: center;"><img alt="图11 释放64B内存前后" height="588" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247076FV3D.jpg" width="554"></img></p><p style="text-align: center;">图11 释放64B内存前后</p><h2><a name="t12" shape="rect"></a>4 性能测试</h2><ul><li>测试对象：C语言的malloc、free和本文的两种内存池（大小为500M，实际可分配内存为310M）。</li><li>测试指标：执行n=2000次随机分配、释放随机大小内存（范围为64B~1024B）的时间比。</li><li>测试方法1：</li></ul><p><span style="white-space: pre;"> </span>（1） 生成n个随机数，大小在64~1024之间，用于表示n个要分配的内存大小；</p><p><span style="white-space: pre;"> </span>（2） 生成n个随机数，取值 为0或者1，表示每次分配内存后紧接着是否释放内存；</p><p><span style="white-space: pre;"> </span>（3） 测量C语言的malloc、free和本文两种内存池执行n次随机分配、释放随机大小内存的时间比ratio；</p><p><span style="white-space: pre;"> </span>（4） 重复（3）m=200次，记录每次活动的ratio，并绘制相应的曲线。</p><ul><li>测试方法2：</li></ul><p><span style="white-space: pre;"> </span>（1） 生成n个随机数，大小在a~b之间（初始值a=64，b=1024），用于表示n个要分配的内存大小；</p><p><span style="white-space: pre;"> </span>（2） 测量C语言的malloc、free和本文两种内存池执行n次分配、释放随机大小内存的时间比ratio；</p><p><span style="white-space: pre;"> </span>（3） 重复（2）m=512次，每次分配的内存容量的范围比前一次大1024B，记录每次获得的ratio，并绘制相应曲线。</p><h3><a name="t13" shape="rect"></a>4.1 性能测试结果-链表结果内存池</h3><p style="text-align: center;"><img alt="图12 链表结构内存池性能测试结果1" height="301" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247077f10F.jpg" width="559"></img></p><p style="text-align: center;">图12 链表结构内存池性能测试结果1</p><p style="text-align: center;"><img alt="链表结构内存池性能测试结果2" height="279" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247078efj2.jpg" width="559"></img></p><p style="text-align: center;">图13 链表结构内存池性能测试结果2</p><h3><a name="t14" shape="rect"></a>4.2 性能测试结果-大顶堆结构内存池</h3><p style="text-align: center;"><img alt="图14 大顶堆内存池性能测试结果1" height="290" src="http://hi.csdn.net/attachment/201106/28/9373112_130924707853UP.jpg" width="559"></img></p><p style="text-align: center;">图14 大顶堆内存池性能测试结果1</p><p style="text-align: center;"><img alt="图15 大顶堆内存池性能测试结果2" height="253" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247079Flbr.jpg" width="559"></img></p><p style="text-align: center;">图15 大顶堆内存池性能测试结果2</p><h3><a name="t15" shape="rect"></a>4.3 性能比较</h3><p style="text-align: center;"><img alt="图16 两种内存池性能测试结果比较1" height="230" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247080ebAk.jpg" width="559"></img></p><p style="text-align: center;">图16 两种内存池性能测试结果比较1</p><p style="text-align: center;"><img alt="图17 两种内存池性能测试结果比较2" height="195" src="http://hi.csdn.net/attachment/201106/28/9373112_1309247081N0kj.jpg" width="559"></img></p><p style="text-align: center;">图17 两种内存池性能测试结果比较2</p><h2><a name="t16" shape="rect"></a>5 结论</h2><p><span style="white-space: pre;"> </span>从上面的内存池性能测试结果中可以看出，相比C语言的malloc和free，内存池使得用户分配内存和释放内存的效率有了较大的提高，这一优势尤其分配较大快的内存时体现的尤为突出。</p><p><span style="white-space: pre;"> </span>同时也可以看出大顶堆结够的内存池的性能并不比链表结构的内存池性能高，反而低于链表结构内存池的性能。这再一次表明O(log(n))优于O(n)是有条件的。当然，本文的测试具有一定的局限性，也许在其他的测试案例中大顶堆结构的内存池性能会超越链表结构的内存池。</p><p> </p><h2><a name="t17" shape="rect"></a>附：源代码</h2><p><span style="white-space: pre;"> </span>链表结构内存池：</p><p><span style="white-space: pre;"> </span>MemoryPool.h</p><div><div><div><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>#ifndef _MEMORYPOOL_H</span><span>  </span></span></li><li><span><span>#define _MEMORYPOOL_H</span><span>  </span></span></li><li><span><span>#include &lt;stdlib.h&gt;</span><span>  </span></span></li><li><span><span>#define MINUNITSIZE 64</span><span>  </span></span></li><li><span><span>#define ADDR_ALIGN 8</span><span>  </span></span></li><li><span><span>#define SIZE_ALIGN MINUNITSIZE</span><span>  </span></span></li><li><span><span>struct</span><span> memory_chunk;  </span></span></li><li><span><span>typedef</span><span> </span><span>struct</span><span> memory_block  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> count;  </span></span></li><li><span>    <span>size_t</span><span> start;  </span></span></li><li><span>    memory_chunk* pmem_chunk;  </span></li><li><span>}memory_block;  </span></li><li><span><span>// 可用的内存块结构体</span><span>  </span></span></li><li><span><span>typedef</span><span> </span><span>struct</span><span> memory_chunk  </span></span></li><li><span>{  </span></li><li><span>    memory_block* pfree_mem_addr;  </span></li><li><span>    memory_chunk* pre;  </span></li><li><span>    memory_chunk* next;  </span></li><li><span>}memory_chunk;  </span></li><li><span><span>// 内存池结构体</span><span>  </span></span></li><li><span><span>typedef</span><span> </span><span>struct</span><span> MEMORYPOOL  </span></span></li><li><span>{  </span></li><li><span>    <span>void</span><span> *memory;  </span></span></li><li><span>    <span>size_t</span><span> size;  </span></span></li><li><span>    memory_block* pmem_map;   </span></li><li><span>    memory_chunk* pfree_mem_chunk;  </span></li><li><span>    memory_chunk* pfree_mem_chunk_pool;  </span></li><li><span>    <span>size_t</span><span> mem_used_size; </span><span>// 记录内存池中已经分配给用户的内存的大小</span><span>  </span></span></li><li><span>    <span>size_t</span><span> mem_map_pool_count; </span><span>// 记录链表单元缓冲池中剩余的单元的个数，个数为0时不能分配单元给pfree_mem_chunk</span><span>  </span></span></li><li><span>    <span>size_t</span><span> free_mem_chunk_count; </span><span>// 记录 pfree_mem_chunk链表中的单元个数</span><span>  </span></span></li><li><span>    <span>size_t</span><span> mem_map_unit_count; </span><span>// </span><span>  </span></span></li><li><span>    <span>size_t</span><span> mem_block_count; </span><span>// 一个 mem_unit 大小为 MINUNITSIZE</span><span>  </span></span></li><li><span>}MEMORYPOOL, *PMEMORYPOOL;  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 生成内存池</span> </span></li><li><span><span> * pBuf: 给定的内存buffer起始地址</span> </span></li><li><span><span> * sBufSize: 给定的内存buffer大小</span> </span></li><li><span><span> * 返回生成的内存池指针</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span>PMEMORYPOOL CreateMemoryPool(<span>void</span><span>* pBuf, </span><span>size_t</span><span> sBufSize);  </span></span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 暂时没用</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span> ReleaseMemoryPool(PMEMORYPOOL* ppMem) ;   </span></span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 从内存池中分配指定大小的内存 </span> </span></li><li><span><span> * pMem: 内存池 指针</span> </span></li><li><span><span> * sMemorySize: 要分配的内存大小</span> </span></li><li><span><span> * 成功时返回分配的内存起始地址，失败返回NULL</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span>* GetMemory(</span><span>size_t</span><span> sMemorySize, PMEMORYPOOL pMem) ;  </span></span></li><li><span>  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 从内存池中释放申请到的内存</span> </span></li><li><span><span> * pMem：内存池指针</span> </span></li><li><span><span> * ptrMemoryBlock：申请到的内存起始地址</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span> FreeMemory(</span><span>void</span><span> *ptrMemoryBlock, PMEMORYPOOL pMem) ;  </span></span></li><li><span>  </span></li><li><span><span>#endif //_MEMORYPOOL_H</span><span>  </span></span></li></ol></div> <p><span style="white-space: pre;"> </span>MemoryPool.cpp</p><div><div><div><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>#include &quot;stdafx.h&quot;</span><span>  </span></span></li><li><span><span>#include &lt;memory.h&gt;</span><span>  </span></span></li><li><span><span>#include &quot;MemoryPool.h&quot;</span><span>  </span></span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存池起始地址对齐到ADDR_ALIGN字节</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>size_t</span><span> check_align_addr(</span><span>void</span><span>*&amp; pBuf)  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> align = 0;  </span></span></li><li><span>    <span>size_t</span><span> addr = (</span><span>int</span><span>)pBuf;  </span></span></li><li><span>    align = (ADDR_ALIGN - addr % ADDR_ALIGN) % ADDR_ALIGN;  </span></li><li><span>    pBuf = (<span>char</span><span>*)pBuf + align;  </span></span></li><li><span>    <span>return</span><span> align;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存block大小对齐到MINUNITSIZE字节</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>size_t</span><span> check_align_block(</span><span>size_t</span><span> size)  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> align = size % MINUNITSIZE;  </span></span></li><li><span>      </span></li><li><span>    <span>return</span><span> size - align;   </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 分配内存大小对齐到SIZE_ALIGN字节</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>size_t</span><span> check_align_size(</span><span>size_t</span><span> size)  </span></span></li><li><span>{  </span></li><li><span>    size = (size + SIZE_ALIGN - 1) / SIZE_ALIGN * SIZE_ALIGN;  </span></li><li><span>    <span>return</span><span> size;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 以下是链表相关操作</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span>memory_chunk* create_list(memory_chunk* pool, <span>size_t</span><span> count)  </span></span></li><li><span>{  </span></li><li><span>    <span>if</span><span> (!pool)  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span> NULL;  </span></span></li><li><span>    }  </span></li><li><span>    memory_chunk* head = NULL;  </span></li><li><span>    <span>for</span><span> (</span><span>size_t</span><span> i = 0; i &lt; count; i++)  </span></span></li><li><span>    {  </span></li><li><span>        pool-&gt;pre = NULL;  </span></li><li><span>        pool-&gt;next = head;  </span></li><li><span>        <span>if</span><span> (head != NULL)  </span></span></li><li><span>        {  </span></li><li><span>            head-&gt;pre = pool;              </span></li><li><span>        }  </span></li><li><span>        head = pool;  </span></li><li><span>        pool++;  </span></li><li><span>    }  </span></li><li><span>    <span>return</span><span> head;  </span></span></li><li><span>}  </span></li><li><span>memory_chunk* front_pop(memory_chunk*&amp; pool)  </span></li><li><span>{  </span></li><li><span>    <span>if</span><span> (!pool)  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span> NULL;  </span></span></li><li><span>    }  </span></li><li><span>    memory_chunk* tmp = pool;  </span></li><li><span>    pool = tmp-&gt;next;  </span></li><li><span>    pool-&gt;pre = NULL;  </span></li><li><span>    <span>return</span><span>  tmp;  </span></span></li><li><span>}  </span></li><li><span><span>void</span><span> push_back(memory_chunk*&amp; head, memory_chunk* element)  </span></span></li><li><span>{  </span></li><li><span>    <span>if</span><span> (head == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        head = element;  </span></li><li><span>        head-&gt;pre = element;  </span></li><li><span>        head-&gt;next = element;  </span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    head-&gt;pre-&gt;next = element;  </span></li><li><span>    element-&gt;pre = head-&gt;pre;  </span></li><li><span>    head-&gt;pre = element;  </span></li><li><span>    element-&gt;next = head;  </span></li><li><span>}  </span></li><li><span><span>void</span><span> push_front(memory_chunk*&amp; head, memory_chunk* element)  </span></span></li><li><span>{  </span></li><li><span>    element-&gt;pre = NULL;  </span></li><li><span>    element-&gt;next = head;  </span></li><li><span>    <span>if</span><span> (head != NULL)  </span></span></li><li><span>    {  </span></li><li><span>        head-&gt;pre = element;           </span></li><li><span>    }  </span></li><li><span>    head = element;  </span></li><li><span>}  </span></li><li><span><span>void</span><span> delete_chunk(memory_chunk*&amp; head, memory_chunk* element)  </span></span></li><li><span>{  </span></li><li><span>    <span>// 在双循环链表中删除元素</span><span>  </span></span></li><li><span>    <span>if</span><span> (element == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    <span>// element为链表头</span><span>  </span></span></li><li><span>    <span>else</span><span> </span><span>if</span><span> (element == head)  </span></span></li><li><span>    {  </span></li><li><span>        <span>// 链表只有一个元素</span><span>  </span></span></li><li><span>        <span>if</span><span> (head-&gt;pre == head)  </span></span></li><li><span>        {  </span></li><li><span>            head = NULL;  </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            head = element-&gt;next;  </span></li><li><span>            head-&gt;pre = element-&gt;pre;  </span></li><li><span>            head-&gt;pre-&gt;next = head;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    <span>// element为链表尾</span><span>  </span></span></li><li><span>    <span>else</span><span> </span><span>if</span><span> (element-&gt;next == head)  </span></span></li><li><span>    {  </span></li><li><span>        head-&gt;pre = element-&gt;pre;  </span></li><li><span>        element-&gt;pre-&gt;next = head;  </span></li><li><span>    }  </span></li><li><span>    <span>else</span><span>  </span></span></li><li><span>    {  </span></li><li><span>        element-&gt;pre-&gt;next = element-&gt;next;  </span></li><li><span>        element-&gt;next-&gt;pre = element-&gt;pre;  </span></li><li><span>    }  </span></li><li><span>    element-&gt;pre = NULL;  </span></li><li><span>    element-&gt;next = NULL;  </span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存映射表中的索引转化为内存起始地址                                                                    </span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span>* index2addr(PMEMORYPOOL mem_pool, </span><span>size_t</span><span> index)  </span></span></li><li><span>{  </span></li><li><span>    <span>char</span><span>* p = (</span><span>char</span><span>*)(mem_pool-&gt;memory);  </span></span></li><li><span>    <span>void</span><span>* ret = (</span><span>void</span><span>*)(p + index *MINUNITSIZE);  </span></span></li><li><span>      </span></li><li><span>    <span>return</span><span> ret;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存起始地址转化为内存映射表中的索引                                                                    </span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>size_t</span><span> addr2index(PMEMORYPOOL mem_pool, </span><span>void</span><span>* addr)  </span></span></li><li><span>{  </span></li><li><span>    <span>char</span><span>* start = (</span><span>char</span><span>*)(mem_pool-&gt;memory);  </span></span></li><li><span>    <span>char</span><span>* p = (</span><span>char</span><span>*)addr;  </span></span></li><li><span>    <span>size_t</span><span> index = (p - start) / MINUNITSIZE;  </span></span></li><li><span>    <span>return</span><span> index;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 生成内存池</span> </span></li><li><span><span>* pBuf: 给定的内存buffer起始地址</span> </span></li><li><span><span>* sBufSize: 给定的内存buffer大小</span> </span></li><li><span><span>* 返回生成的内存池指针</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span>PMEMORYPOOL CreateMemoryPool(<span>void</span><span>* pBuf, </span><span>size_t</span><span> sBufSize)  </span></span></li><li><span>{  </span></li><li><span>    memset(pBuf, 0, sBufSize);  </span></li><li><span>    PMEMORYPOOL mem_pool = (PMEMORYPOOL)pBuf;  </span></li><li><span>    <span>// 计算需要多少memory map单元格</span><span>  </span></span></li><li><span>    <span>size_t</span><span> mem_pool_struct_size = </span><span>sizeof</span><span>(MEMORYPOOL);  </span></span></li><li><span>    mem_pool-&gt;mem_map_pool_count = (sBufSize - mem_pool_struct_size + MINUNITSIZE - 1) / MINUNITSIZE;  </span></li><li><span>    mem_pool-&gt;mem_map_unit_count = (sBufSize - mem_pool_struct_size + MINUNITSIZE - 1) / MINUNITSIZE;  </span></li><li><span>    mem_pool-&gt;pmem_map = (memory_block*)((<span>char</span><span>*)pBuf + mem_pool_struct_size);  </span></span></li><li><span>    mem_pool-&gt;pfree_mem_chunk_pool = (memory_chunk*)((<span>char</span><span>*)pBuf + mem_pool_struct_size + </span><span>sizeof</span><span>(memory_block) * mem_pool-&gt;mem_map_unit_count);  </span></span></li><li><span>      </span></li><li><span>    mem_pool-&gt;memory = (<span>char</span><span>*)pBuf + mem_pool_struct_size+ </span><span>sizeof</span><span>(memory_block) * mem_pool-&gt;mem_map_unit_count + </span><span>sizeof</span><span>(memory_chunk) * mem_pool-&gt;mem_map_pool_count;  </span></span></li><li><span>    mem_pool-&gt;size = sBufSize - mem_pool_struct_size - <span>sizeof</span><span>(memory_block) * mem_pool-&gt;mem_map_unit_count - </span><span>sizeof</span><span>(memory_chunk) * mem_pool-&gt;mem_map_pool_count;  </span></span></li><li><span>    <span>size_t</span><span> align = check_align_addr(mem_pool-&gt;memory);  </span></span></li><li><span>    mem_pool-&gt;size -= align;  </span></li><li><span>    mem_pool-&gt;size = check_align_block(mem_pool-&gt;size);  </span></li><li><span>    mem_pool-&gt;mem_block_count = mem_pool-&gt;size / MINUNITSIZE;  </span></li><li><span>    <span>// 链表化</span><span>  </span></span></li><li><span>    mem_pool-&gt;pfree_mem_chunk_pool = create_list(mem_pool-&gt;pfree_mem_chunk_pool, mem_pool-&gt;mem_map_pool_count);  </span></li><li><span>    <span>// 初始化 pfree_mem_chunk，双向循环链表</span><span>  </span></span></li><li><span>    memory_chunk* tmp = front_pop(mem_pool-&gt;pfree_mem_chunk_pool);  </span></li><li><span>    tmp-&gt;pre = tmp;  </span></li><li><span>    tmp-&gt;next = tmp;  </span></li><li><span>    tmp-&gt;pfree_mem_addr = NULL;  </span></li><li><span>    mem_pool-&gt;mem_map_pool_count--;  </span></li><li><span>      </span></li><li><span>    <span>// 初始化 pmem_map</span><span>  </span></span></li><li><span>    mem_pool-&gt;pmem_map[0].count = mem_pool-&gt;mem_block_count;  </span></li><li><span>    mem_pool-&gt;pmem_map[0].pmem_chunk = tmp;  </span></li><li><span>    mem_pool-&gt;pmem_map[mem_pool-&gt;mem_block_count-1].start = 0;  </span></li><li><span>      </span></li><li><span>    tmp-&gt;pfree_mem_addr = mem_pool-&gt;pmem_map;  </span></li><li><span>    push_back(mem_pool-&gt;pfree_mem_chunk, tmp);  </span></li><li><span>    mem_pool-&gt;free_mem_chunk_count = 1;  </span></li><li><span>    mem_pool-&gt;mem_used_size = 0;  </span></li><li><span>    <span>return</span><span> mem_pool;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 暂时没用</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span> ReleaseMemoryPool(PMEMORYPOOL* ppMem)   </span></span></li><li><span>{  </span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 从内存池中分配指定大小的内存 </span> </span></li><li><span><span>* pMem: 内存池 指针</span> </span></li><li><span><span>* sMemorySize: 要分配的内存大小</span> </span></li><li><span><span>* 成功时返回分配的内存起始地址，失败返回NULL</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span>* GetMemory(</span><span>size_t</span><span> sMemorySize, PMEMORYPOOL pMem)  </span></span></li><li><span>{  </span></li><li><span>    sMemorySize = check_align_size(sMemorySize);  </span></li><li><span>    <span>size_t</span><span> index = 0;  </span></span></li><li><span>    memory_chunk* tmp = pMem-&gt;pfree_mem_chunk;  </span></li><li><span>    <span>for</span><span> (index = 0; index &lt; pMem-&gt;free_mem_chunk_count; index++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE &gt;= sMemorySize)  </span></span></li><li><span>        {             </span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>          </span></li><li><span>        tmp = tmp-&gt;next;  </span></li><li><span>    }  </span></li><li><span>      </span></li><li><span>    <span>if</span><span> (index == pMem-&gt;free_mem_chunk_count)  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span> NULL;  </span></span></li><li><span>    }  </span></li><li><span>    pMem-&gt;mem_used_size += sMemorySize;  </span></li><li><span>    <span>if</span><span> (tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE == sMemorySize)  </span></span></li><li><span>    {  </span></li><li><span>        <span>// 当要分配的内存大小与当前chunk中的内存大小相同时，从pfree_mem_chunk链表中删除此chunk</span><span>  </span></span></li><li><span>        <span>size_t</span><span> current_index = (tmp-&gt;pfree_mem_addr - pMem-&gt;pmem_map);  </span></span></li><li><span>        delete_chunk(pMem-&gt;pfree_mem_chunk, tmp);  </span></li><li><span>        tmp-&gt;pfree_mem_addr-&gt;pmem_chunk = NULL;  </span></li><li><span>          </span></li><li><span>        push_front(pMem-&gt;pfree_mem_chunk_pool, tmp);  </span></li><li><span>        pMem-&gt;free_mem_chunk_count--;  </span></li><li><span>        pMem-&gt;mem_map_pool_count++;  </span></li><li><span>          </span></li><li><span>        <span>return</span><span> index2addr(pMem, current_index);  </span></span></li><li><span>    }  </span></li><li><span>    <span>else</span><span>  </span></span></li><li><span>    {  </span></li><li><span>        <span>// 当要分配的内存小于当前chunk中的内存时，更改pfree_mem_chunk中相应chunk的pfree_mem_addr</span><span>  </span></span></li><li><span>          </span></li><li><span>        <span>// 复制当前mem_map_unit</span><span>  </span></span></li><li><span>        memory_block copy;  </span></li><li><span>        copy.count = tmp-&gt;pfree_mem_addr-&gt;count;  </span></li><li><span>        copy.pmem_chunk = tmp;  </span></li><li><span>        <span>// 记录该block的起始和结束索引</span><span>  </span></span></li><li><span>        memory_block* current_block = tmp-&gt;pfree_mem_addr;  </span></li><li><span>        current_block-&gt;count = sMemorySize / MINUNITSIZE;  </span></li><li><span>        <span>size_t</span><span> current_index = (current_block - pMem-&gt;pmem_map);  </span></span></li><li><span>        pMem-&gt;pmem_map[current_index+current_block-&gt;count-1].start = current_index;  </span></li><li><span>        current_block-&gt;pmem_chunk = NULL; <span>// NULL表示当前内存块已被分配</span><span>  </span></span></li><li><span>        <span>// 当前block被一分为二，更新第二个block中的内容</span><span>  </span></span></li><li><span>        pMem-&gt;pmem_map[current_index+current_block-&gt;count].count = copy.count - current_block-&gt;count;  </span></li><li><span>        pMem-&gt;pmem_map[current_index+current_block-&gt;count].pmem_chunk = copy.pmem_chunk;  </span></li><li><span>        <span>// 更新原来的pfree_mem_addr</span><span>  </span></span></li><li><span>        tmp-&gt;pfree_mem_addr = &amp;(pMem-&gt;pmem_map[current_index+current_block-&gt;count]);  </span></li><li><span>      </span></li><li><span>        <span>size_t</span><span> end_index = current_index + copy.count - 1;  </span></span></li><li><span>        pMem-&gt;pmem_map[end_index].start = current_index + current_block-&gt;count;  </span></li><li><span>        <span>return</span><span> index2addr(pMem, current_index);  </span></span></li><li><span>    }     </span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 从内存池中释放申请到的内存</span> </span></li><li><span><span>* pMem：内存池指针</span> </span></li><li><span><span>* ptrMemoryBlock：申请到的内存起始地址</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span> FreeMemory(</span><span>void</span><span> *ptrMemoryBlock, PMEMORYPOOL pMem)   </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> current_index = addr2index(pMem, ptrMemoryBlock);  </span></span></li><li><span>    <span>size_t</span><span> size = pMem-&gt;pmem_map[current_index].count * MINUNITSIZE;  </span></span></li><li><span>    <span>// 判断与当前释放的内存块相邻的内存块是否可以与当前释放的内存块合并</span><span>  </span></span></li><li><span>    memory_block* pre_block = NULL;  </span></li><li><span>    memory_block* next_block = NULL;  </span></li><li><span>    memory_block* current_block = &amp;(pMem-&gt;pmem_map[current_index]);  </span></li><li><span>    <span>// 第一个</span><span>  </span></span></li><li><span>    <span>if</span><span> (current_index == 0)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (current_block-&gt;count &lt; pMem-&gt;mem_block_count)  </span></span></li><li><span>        {  </span></li><li><span>            next_block = &amp;(pMem-&gt;pmem_map[current_index+current_block-&gt;count]);  </span></li><li><span>            <span>// 如果后一个内存块是空闲的，合并</span><span>  </span></span></li><li><span>            <span>if</span><span> (next_block-&gt;pmem_chunk != NULL)  </span></span></li><li><span>            {  </span></li><li><span>                next_block-&gt;pmem_chunk-&gt;pfree_mem_addr = current_block;  </span></li><li><span>                pMem-&gt;pmem_map[current_index+current_block-&gt;count+next_block-&gt;count-1].start = current_index;  </span></li><li><span>                current_block-&gt;count += next_block-&gt;count;  </span></li><li><span>                current_block-&gt;pmem_chunk = next_block-&gt;pmem_chunk;  </span></li><li><span>                next_block-&gt;pmem_chunk = NULL;  </span></li><li><span>            }  </span></li><li><span>            <span>// 如果后一块内存不是空闲的，在pfree_mem_chunk中增加一个chunk</span><span>  </span></span></li><li><span>            <span>else</span><span>  </span></span></li><li><span>            {  </span></li><li><span>                memory_chunk* new_chunk = front_pop(pMem-&gt;pfree_mem_chunk_pool);  </span></li><li><span>                new_chunk-&gt;pfree_mem_addr = current_block;  </span></li><li><span>                current_block-&gt;pmem_chunk = new_chunk;  </span></li><li><span>                push_back(pMem-&gt;pfree_mem_chunk, new_chunk);  </span></li><li><span>                pMem-&gt;mem_map_pool_count--;  </span></li><li><span>                pMem-&gt;free_mem_chunk_count++;  </span></li><li><span>            }  </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            memory_chunk* new_chunk = front_pop(pMem-&gt;pfree_mem_chunk_pool);  </span></li><li><span>            new_chunk-&gt;pfree_mem_addr = current_block;  </span></li><li><span>            current_block-&gt;pmem_chunk = new_chunk;  </span></li><li><span>            push_back(pMem-&gt;pfree_mem_chunk, new_chunk);  </span></li><li><span>            pMem-&gt;mem_map_pool_count--;  </span></li><li><span>            pMem-&gt;free_mem_chunk_count++;  </span></li><li><span>        }         </span></li><li><span>    }  </span></li><li><span>      </span></li><li><span>    <span>// 最后一个</span><span>  </span></span></li><li><span>    <span>else</span><span> </span><span>if</span><span> (current_index == pMem-&gt;mem_block_count-1)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (current_block-&gt;count &lt; pMem-&gt;mem_block_count)  </span></span></li><li><span>        {  </span></li><li><span>            pre_block = &amp;(pMem-&gt;pmem_map[current_index-1]);  </span></li><li><span>            <span>size_t</span><span> index = pre_block-&gt;count;  </span></span></li><li><span>            pre_block = &amp;(pMem-&gt;pmem_map[index]);  </span></li><li><span>              </span></li><li><span>            <span>// 如果前一个内存块是空闲的，合并</span><span>  </span></span></li><li><span>            <span>if</span><span> (pre_block-&gt;pmem_chunk != NULL)  </span></span></li><li><span>            {  </span></li><li><span>                pMem-&gt;pmem_map[current_index+current_block-&gt;count-1].start = current_index - pre_block-&gt;count;  </span></li><li><span>                pre_block-&gt;count += current_block-&gt;count;  </span></li><li><span>                current_block-&gt;pmem_chunk = NULL;  </span></li><li><span>            }  </span></li><li><span>            <span>// 如果前一块内存不是空闲的，在pfree_mem_chunk中增加一个chunk</span><span>  </span></span></li><li><span>            <span>else</span><span>  </span></span></li><li><span>            {  </span></li><li><span>                memory_chunk* new_chunk = front_pop(pMem-&gt;pfree_mem_chunk_pool);  </span></li><li><span>                new_chunk-&gt;pfree_mem_addr = current_block;  </span></li><li><span>                current_block-&gt;pmem_chunk = new_chunk;  </span></li><li><span>                push_back(pMem-&gt;pfree_mem_chunk, new_chunk);  </span></li><li><span>                pMem-&gt;mem_map_pool_count--;  </span></li><li><span>                pMem-&gt;free_mem_chunk_count++;  </span></li><li><span>            }  </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            memory_chunk* new_chunk = front_pop(pMem-&gt;pfree_mem_chunk_pool);  </span></li><li><span>            new_chunk-&gt;pfree_mem_addr = current_block;  </span></li><li><span>            current_block-&gt;pmem_chunk = new_chunk;  </span></li><li><span>            push_back(pMem-&gt;pfree_mem_chunk, new_chunk);  </span></li><li><span>            pMem-&gt;mem_map_pool_count--;  </span></li><li><span>            pMem-&gt;free_mem_chunk_count++;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    <span>else</span><span>  </span></span></li><li><span>    {         </span></li><li><span>        next_block = &amp;(pMem-&gt;pmem_map[current_index+current_block-&gt;count]);  </span></li><li><span>        pre_block = &amp;(pMem-&gt;pmem_map[current_index-1]);  </span></li><li><span>        <span>size_t</span><span> index = pre_block-&gt;start;  </span></span></li><li><span>        pre_block = &amp;(pMem-&gt;pmem_map[index]);  </span></li><li><span>        <span>bool</span><span> is_back_merge = </span><span>false</span><span>;  </span></span></li><li><span>        <span>if</span><span> (next_block-&gt;pmem_chunk == NULL &amp;&amp; pre_block-&gt;pmem_chunk == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            memory_chunk* new_chunk = front_pop(pMem-&gt;pfree_mem_chunk_pool);  </span></li><li><span>            new_chunk-&gt;pfree_mem_addr = current_block;  </span></li><li><span>            current_block-&gt;pmem_chunk = new_chunk;  </span></li><li><span>            push_back(pMem-&gt;pfree_mem_chunk, new_chunk);  </span></li><li><span>            pMem-&gt;mem_map_pool_count--;  </span></li><li><span>            pMem-&gt;free_mem_chunk_count++;  </span></li><li><span>        }  </span></li><li><span>        <span>// 后一个内存块</span><span>  </span></span></li><li><span>        <span>if</span><span> (next_block-&gt;pmem_chunk != NULL)  </span></span></li><li><span>        {  </span></li><li><span>            next_block-&gt;pmem_chunk-&gt;pfree_mem_addr = current_block;  </span></li><li><span>            pMem-&gt;pmem_map[current_index+current_block-&gt;count+next_block-&gt;count-1].start = current_index;  </span></li><li><span>            current_block-&gt;count += next_block-&gt;count;  </span></li><li><span>            current_block-&gt;pmem_chunk = next_block-&gt;pmem_chunk;  </span></li><li><span>            next_block-&gt;pmem_chunk = NULL;  </span></li><li><span>            is_back_merge = <span>true</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        <span>// 前一个内存块</span><span>  </span></span></li><li><span>        <span>if</span><span> (pre_block-&gt;pmem_chunk != NULL)  </span></span></li><li><span>        {  </span></li><li><span>            pMem-&gt;pmem_map[current_index+current_block-&gt;count-1].start = current_index - pre_block-&gt;count;  </span></li><li><span>            pre_block-&gt;count += current_block-&gt;count;  </span></li><li><span>            <span>if</span><span> (is_back_merge)  </span></span></li><li><span>            {  </span></li><li><span>                delete_chunk(pMem-&gt;pfree_mem_chunk, current_block-&gt;pmem_chunk);  </span></li><li><span>                push_front(pMem-&gt;pfree_mem_chunk_pool, current_block-&gt;pmem_chunk);  </span></li><li><span>                pMem-&gt;free_mem_chunk_count--;  </span></li><li><span>                pMem-&gt;mem_map_pool_count++;  </span></li><li><span>            }  </span></li><li><span>            current_block-&gt;pmem_chunk = NULL;              </span></li><li><span>        }         </span></li><li><span>    }  </span></li><li><span>    pMem-&gt;mem_used_size -= size;  </span></li><li><span>}  </span></li></ol></div> <p><span style="white-space: pre;"> </span>MemoryPoolTest.cpp</p><div><div><div><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>// memory pool test.cpp : Defines the entry point for the console application.</span><span>  </span></span></li><li><span><span>#include &lt;tchar.h&gt;</span><span>  </span></span></li><li><span><span>#include &quot;MemoryPool.h&quot;</span><span>  </span></span></li><li><span><span>#include &lt;iostream&gt;</span><span>  </span></span></li><li><span><span>#include &lt;windows.h&gt;</span><span>  </span></span></li><li><span><span>#include &lt;vector&gt;</span><span>  </span></span></li><li><span><span>#include &lt;time.h&gt;</span><span>  </span></span></li><li><span><span>#include &lt;math.h&gt;</span><span>  </span></span></li><li><span><span>#include &lt;fstream&gt;</span><span>  </span></span></li><li><span><span>using</span><span> </span><span>namespace</span><span> std;  </span></span></li><li><span><span>int</span><span> break_time = 0;  </span></span></li><li><span><span>// 检测内存池相关参数</span><span>  </span></span></li><li><span><span>void</span><span> check_mem_pool(</span><span>int</span><span>&amp; max_chunk_size, </span><span>int</span><span>&amp; free_chunk_count, </span><span>int</span><span>&amp; min_chunk_size, </span><span>int</span><span>&amp; total_free_mem, MEMORYPOOL* mem_pool)  </span></span></li><li><span>{  </span></li><li><span>    memory_chunk* head = mem_pool-&gt;pfree_mem_chunk;  </span></li><li><span>    memory_chunk* tmp = head;  </span></li><li><span>    free_chunk_count = 0;  </span></li><li><span>    total_free_mem = 0;  </span></li><li><span>    max_chunk_size = 0;  </span></li><li><span>    min_chunk_size = 500*1024*1024;  </span></li><li><span>    <span>if</span><span> (head == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        min_chunk_size = 0;  </span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    <span>while</span><span> (tmp-&gt;next != head)  </span></span></li><li><span>    {  </span></li><li><span>        free_chunk_count++;  </span></li><li><span>        total_free_mem += tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE;  </span></li><li><span>        <span>if</span><span> (tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE &gt; max_chunk_size )  </span></span></li><li><span>        {  </span></li><li><span>            max_chunk_size = tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE;  </span></li><li><span>        }  </span></li><li><span>        <span>if</span><span> (tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE &lt; min_chunk_size)  </span></span></li><li><span>        {  </span></li><li><span>            min_chunk_size = tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE;  </span></li><li><span>        }  </span></li><li><span>        tmp = tmp-&gt;next;  </span></li><li><span>    }  </span></li><li><span>    free_chunk_count++;  </span></li><li><span>    total_free_mem += tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE;  </span></li><li><span>    <span>if</span><span> (tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE &gt; max_chunk_size )  </span></span></li><li><span>    {  </span></li><li><span>        max_chunk_size = tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE;  </span></li><li><span>    }  </span></li><li><span>    <span>if</span><span> (tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE &lt; min_chunk_size)  </span></span></li><li><span>    {  </span></li><li><span>        min_chunk_size = tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE;  </span></li><li><span>    }  </span></li><li><span>}  </span></li><li><span><span>// 申请后紧接着释放</span><span>  </span></span></li><li><span><span>double</span><span> test_mem_pool_perf_1(PMEMORYPOOL mem_pool, </span><span>int</span><span> iter, </span><span>int</span><span>* sizes)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_mem_pool_perf_1*********************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>void</span><span> *p = GetMemory(sizes[i], mem_pool);  </span></span></li><li><span>        <span>if</span><span> (p == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; sizes[i] &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;total memory is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size -  mem_pool-&gt;mem_used_size  &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>            <span>int</span><span> max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem;  </span></span></li><li><span>            check_mem_pool(max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem,  mem_pool);  </span></li><li><span>            cout &lt;&lt; <span>&quot;check memory pool result:&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;free_chunk_count:    &quot;</span><span> &lt;&lt; free_chunk_count &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;total_free_mem:   &quot;</span><span> &lt;&lt; total_free_mem &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;max_chunk_size:   &quot;</span><span> &lt;&lt; max_chunk_size &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;min_chunk_size:   &quot;</span><span> &lt;&lt; min_chunk_size &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        FreeMemory(p,  mem_pool);  </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_mem_pool_perf_1: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_mem_pool_perf_1*********************&quot;</span><span> &lt;&lt;  endl &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>double</span><span> test_std_perf_1(</span><span>int</span><span> iter, </span><span>int</span><span>* sizes)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_std_perf_1*********************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>void</span><span> *p = malloc(sizes[i]);  </span></span></li><li><span>        <span>if</span><span> (p == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; sizes[i] &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        free(p);  </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_std_perf_1: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_std_perf_1*********************&quot;</span><span> &lt;&lt;  endl &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>// 连续申请iter/2次，然后释放所有申请内存；再重复一次</span><span>  </span></span></li><li><span><span>double</span><span> test_mem_pool_perf_2(PMEMORYPOOL mem_pool, </span><span>int</span><span> iter, </span><span>int</span><span> size)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_mem_pool_perf_2*********************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>void</span><span> **p = </span><span>new</span><span> </span><span>void</span><span>*[iter];  </span></span></li><li><span>    <span>if</span><span> (p == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new faild&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span> -1;  </span></span></li><li><span>    }  </span></li><li><span>    <span>int</span><span> count = 0;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter/2; i++)  </span></span></li><li><span>    {  </span></li><li><span>        p[i] = GetMemory(size, mem_pool);  </span></li><li><span>        <span>if</span><span> (p[i] == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;total memory is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size -  mem_pool-&gt;mem_used_size  &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>            <span>int</span><span> max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem;  </span></span></li><li><span>            check_mem_pool(max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem,  mem_pool);  </span></li><li><span>            cout &lt;&lt; <span>&quot;check memory pool result:&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;free_chunk_count:    &quot;</span><span> &lt;&lt; free_chunk_count &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;total_free_mem:   &quot;</span><span> &lt;&lt; total_free_mem &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;max_chunk_size:   &quot;</span><span> &lt;&lt; max_chunk_size &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;min_chunk_size:   &quot;</span><span> &lt;&lt; min_chunk_size &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        count++;  </span></li><li><span>    }  </span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; count; i++)  </span></span></li><li><span>    {  </span></li><li><span>        FreeMemory(p[i],  mem_pool);  </span></li><li><span>    }  </span></li><li><span>    count = 0;  </span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter/2; i++)  </span></span></li><li><span>    {         </span></li><li><span>        p[i] = GetMemory(size, mem_pool);  </span></li><li><span>        <span>if</span><span> (p[i] == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;total memory is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size -  mem_pool-&gt;mem_used_size  &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>              </span></li><li><span>            <span>int</span><span> max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem;  </span></span></li><li><span>            check_mem_pool(max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem,  mem_pool);  </span></li><li><span>            cout &lt;&lt; <span>&quot;check memory pool result:&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;free_chunk_count:    &quot;</span><span> &lt;&lt; free_chunk_count &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;total_free_mem:   &quot;</span><span> &lt;&lt; total_free_mem &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;max_chunk_size:   &quot;</span><span> &lt;&lt; max_chunk_size &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;min_chunk_size:   &quot;</span><span> &lt;&lt; min_chunk_size &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        count++;  </span></li><li><span>    }  </span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; count; i++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (p[i] == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; i &lt;&lt; endl;  </span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        FreeMemory(p[i],  mem_pool);  </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_mem_pool_perf_2: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl;  </span></span></li><li><span>    <span>delete</span><span> []p;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_mem_pool_perf_2*********************&quot;</span><span> &lt;&lt;  endl &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>// 连续申请inner_iter次，释放；重复iter/inner_iter次</span><span>  </span></span></li><li><span><span>double</span><span> test_mem_pool_perf_3(PMEMORYPOOL mem_pool, </span><span>int</span><span> iter, </span><span>int</span><span> size)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_mem_pool_perf_3*********************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    <span>int</span><span> inner_iter = 10;  </span></span></li><li><span>    <span>void</span><span> **p = </span><span>new</span><span> </span><span>void</span><span>*[inner_iter];  </span></span></li><li><span>    <span>if</span><span> (p == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new faild&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span> -1;  </span></span></li><li><span>    }  </span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2, start, finish;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; iter / inner_iter; k++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>int</span><span> j = 0;  </span></span></li><li><span>        <span>for</span><span> (j = 0; j &lt; inner_iter; j++)  </span></span></li><li><span>        {  </span></li><li><span>            p[j] = GetMemory(size, mem_pool);  </span></li><li><span>            <span>if</span><span> (p[j] == NULL)  </span></span></li><li><span>            {  </span></li><li><span>                cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; j &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>                cout &lt;&lt; <span>&quot;total memory is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>                cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>                cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size -  mem_pool-&gt;mem_used_size  &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>                <span>int</span><span> max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem;  </span></span></li><li><span>                check_mem_pool(max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem,  mem_pool);  </span></li><li><span>                cout &lt;&lt; <span>&quot;check memory pool result:&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>                cout &lt;&lt; <span>&quot;free_chunk_count:    &quot;</span><span> &lt;&lt; free_chunk_count &lt;&lt; endl  </span></span></li><li><span>                    &lt;&lt; <span>&quot;total_free_mem:   &quot;</span><span> &lt;&lt; total_free_mem &lt;&lt; endl  </span></span></li><li><span>                    &lt;&lt; <span>&quot;max_chunk_size:   &quot;</span><span> &lt;&lt; max_chunk_size &lt;&lt; endl  </span></span></li><li><span>                    &lt;&lt; <span>&quot;min_chunk_size:   &quot;</span><span> &lt;&lt; min_chunk_size &lt;&lt; endl;  </span></span></li><li><span>                <span>break</span><span>;  </span></span></li><li><span>            }  </span></li><li><span>        }  </span></li><li><span>        <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; j; i++)  </span></span></li><li><span>        {  </span></li><li><span>                FreeMemory(p[i],  mem_pool);          </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_mem_pool_perf_3: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_mem_pool_perf_3*********************&quot;</span><span> &lt;&lt;  endl &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>// 随机内存大小，随机释放操作</span><span>  </span></span></li><li><span><span>double</span><span> test_mem_pool_perf_rand(PMEMORYPOOL mem_pool, </span><span>int</span><span> iter, </span><span>int</span><span>* sizes, </span><span>int</span><span>* instruction)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;-----------------------test_mem_pool_perf_rand----------------------- &quot;</span><span>&lt;&lt; endl;  </span></span></li><li><span>    <span>void</span><span>** p = </span><span>new</span><span> </span><span>void</span><span>*[iter];  </span></span></li><li><span>    <span>if</span><span> (p == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span> -1;  </span></span></li><li><span>    }  </span></li><li><span>    LARGE_INTEGER litmp, gftime;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2, start, finish;  </span></span></li><li><span>    <span>double</span><span> t, GetMemory_time, FreeMemory_time;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>int</span><span> index = 0;  </span></span></li><li><span>    <span>int</span><span> size;  </span></span></li><li><span>    <span>int</span><span> free_tmp = 0;  </span></span></li><li><span>    <span>double</span><span> seach_time;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        size = sizes[i];  </span></li><li><span>        p[index++] = GetMemory(size, mem_pool);  </span></li><li><span>        <span>if</span><span> (p[index-1] == NULL)  </span></span></li><li><span>        {             </span></li><li><span>            break_time++;  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;total memory is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size -  mem_pool-&gt;mem_used_size  &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>            <span>int</span><span> max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem;  </span></span></li><li><span>            check_mem_pool(max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem,  mem_pool);  </span></li><li><span>            cout &lt;&lt; <span>&quot;check memory pool result:&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;free_chunk_count:    &quot;</span><span> &lt;&lt; free_chunk_count &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;total_free_mem:   &quot;</span><span> &lt;&lt; total_free_mem &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;max_chunk_size:   &quot;</span><span> &lt;&lt; max_chunk_size &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;min_chunk_size:   &quot;</span><span> &lt;&lt; min_chunk_size &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>          </span></li><li><span>        <span>if</span><span> (instruction[i] == 1)  </span></span></li><li><span>        {             </span></li><li><span>            FreeMemory(p[--index],  mem_pool);  </span></li><li><span>        }     </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_mem_pool_perf_rand: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>delete</span><span> []p;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>double</span><span> test_std_perf(</span><span>int</span><span> iter, </span><span>int</span><span>* sizes, </span><span>int</span><span>* instruction)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;test_std_perf&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    <span>void</span><span>** p =</span><span>new</span><span> </span><span>void</span><span>*[iter];  </span></span></li><li><span>    <span>if</span><span> (p == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span> -1;  </span></span></li><li><span>    }  </span></li><li><span>      </span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span><span>//  cout &lt;&lt; &quot;test start&quot; &lt;&lt; endl;</span><span>  </span></span></li><li><span>    <span>int</span><span> index = 0;  </span></span></li><li><span>    <span>int</span><span> size;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        size = sizes[i];  </span></li><li><span>        p[index++] = malloc(size);  </span></li><li><span>        <span>if</span><span> (p[index-1] == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; i &lt;&lt; endl;  </span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        <span>if</span><span> (instruction[i] == 1)  </span></span></li><li><span>        {  </span></li><li><span>            free(p[--index]);  </span></li><li><span>        }         </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_std_perf: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; index; k++)  </span></span></li><li><span>    {  </span></li><li><span>        free(p[k]);  </span></li><li><span>    }  </span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>double</span><span> test_std_perf_fix_size(</span><span>int</span><span> iter, </span><span>int</span><span> size)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;******************* test_std_perf_fix_size *******************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>int</span><span> index = 0;  </span></span></li><li><span>      </span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>void</span><span> *p = malloc(size);  </span></span></li><li><span>        <span>if</span><span> (p == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; i &lt;&lt; endl;  </span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        free(p);  </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_std_perf: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;******************* test_std_perf_fix_size *******************&quot;</span><span> &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>void</span><span> test_correct_1(PMEMORYPOOL mem_pool, </span><span>int</span><span> iter, </span><span>int</span><span> size)  </span></span></li><li><span>{  </span></li><li><span>    vector&lt;<span>void</span><span>*&gt;vec;  </span></span></li><li><span>    vector&lt;<span>void</span><span>*&gt;::iterator vec_iter;  </span></span></li><li><span>    <span>int</span><span> i = 0;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;**************************** Get Memory Test Start ****************************&quot;</span><span>&lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>for</span><span> (i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>void</span><span> *p = GetMemory(size, mem_pool);  </span></span></li><li><span>        <span>if</span><span> (p == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        vec.push_back(p);  </span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;verify memory size&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    memory_chunk* tmp = mem_pool-&gt;pfree_mem_chunk;  </span></li><li><span>    <span>int</span><span> free_size = 0;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; mem_pool-&gt;free_mem_chunk_count; k++)  </span></span></li><li><span>    {  </span></li><li><span>        free_size += tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE;  </span></li><li><span>        tmp = tmp-&gt;next;  </span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; <span>&quot;memory free size is &quot;</span><span> &lt;&lt; free_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;memory used size is &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;*************************** Get Memory Test Finish ***************************&quot;</span><span>&lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;*************************** Free Memory Test Start ***************************&quot;</span><span>&lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>int</span><span> index = 0;  </span></span></li><li><span>    <span>for</span><span> (vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++)  </span></span></li><li><span>    {  </span></li><li><span>        index++;  </span></li><li><span>        FreeMemory(*vec_iter, mem_pool);  </span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;*************************** Free Memory Test Finish ***************************&quot;</span><span>&lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;********************* Get Memory Test (after Free) Start *********************&quot;</span><span>&lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>for</span><span> (i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>void</span><span> *p = GetMemory(size, mem_pool);  </span></span></li><li><span>        <span>if</span><span> (p == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>            <span>int</span><span> max_size = 0;  </span></span></li><li><span>            memory_chunk* tmp = mem_pool-&gt;pfree_mem_chunk;  </span></li><li><span>            <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; mem_pool-&gt;free_mem_chunk_count; k++)  </span></span></li><li><span>            {  </span></li><li><span>                <span>if</span><span> (tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE &gt; max_size)  </span></span></li><li><span>                {  </span></li><li><span>                    max_size = tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE &gt; max_size;  </span></li><li><span>                }  </span></li><li><span>            }  </span></li><li><span>            cout &lt;&lt; <span>&quot;max chunk size is: &quot;</span><span> &lt;&lt; max_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        vec.push_back(p);  </span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;verify memory size&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    tmp = mem_pool-&gt;pfree_mem_chunk;  </span></li><li><span>    free_size = 0;  </span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; mem_pool-&gt;free_mem_chunk_count; k++)  </span></span></li><li><span>    {  </span></li><li><span>        free_size += tmp-&gt;pfree_mem_addr-&gt;count * MINUNITSIZE;  </span></li><li><span>        tmp = tmp-&gt;next;  </span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; <span>&quot;memory free size is &quot;</span><span> &lt;&lt; free_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;memory used size is &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;********************* Get Memory Test (after Free) Finish *********************&quot;</span><span>&lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存池性能测试代码</span> </span></li><li><span><span> * 固定大小</span> </span></li><li><span><span> /************************************************************************/</span><span>  </span></span></li><li><span><span>/*</span> </span></li><li><span><span>void test_mem_pool_fix_size(PMEMORYPOOL mem_pool)</span> </span></li><li><span><span>{</span> </span></li><li><span><span>    int iter = 200000;</span> </span></li><li><span><span>    int size = 512;</span> </span></li><li><span><span>    double t1 = test_std_perf_fix_size(iter, size);</span> </span></li><li><span><span>    double t2 = test_mem_pool_perf_1(mem_pool, iter, size);</span> </span></li><li><span><span>    double t3 = test_mem_pool_perf_2(mem_pool, iter, size);</span> </span></li><li><span><span>    double t4 = test_mem_pool_perf_3(mem_pool, iter, size);</span> </span></li><li><span><span>    cout  &lt;&lt; endl &lt;&lt; endl </span> </span></li><li><span><span>        &lt;&lt; &quot;test count: &quot; &lt;&lt; iter &lt;&lt; &quot;, test size: &quot; &lt;&lt; size &lt;&lt; endl</span> </span></li><li><span><span>        &lt;&lt; &quot;test result (system time / mem_pool time) : &quot; &lt;&lt; endl;</span> </span></li><li><span><span>    cout &lt;&lt; &quot;test_mem_pool_perf_1:    &quot; &lt;&lt; t1 / t2 &lt;&lt; endl</span> </span></li><li><span><span>        &lt;&lt; &quot;test_mem_pool_perf_2: &quot; &lt;&lt; t1 / t3 &lt;&lt; endl</span> </span></li><li><span><span>        &lt;&lt; &quot;test_mem_pool_perf_3: &quot; &lt;&lt; t1 / t4 &lt;&lt; endl;</span> </span></li><li><span><span>}</span> </span></li><li><span><span>*/</span><span>  </span></span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存池性能测试代码</span> </span></li><li><span><span> </span> </span></li><li><span><span> * 随机大小，随机释放操作</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span> rand_test()  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> sBufSize = 500* 1024*1024;  </span></span></li><li><span>    <span>void</span><span>*pBuf = malloc(sBufSize);  </span></span></li><li><span>    <span>if</span><span> (pBuf == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;malloc failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    PMEMORYPOOL mem_pool = CreateMemoryPool(pBuf, sBufSize);  </span></li><li><span>    ofstream out(<span>&quot;rand_test.txt&quot;</span><span>);  </span></span></li><li><span>    <span>int</span><span> iter = 2000;  </span></span></li><li><span>    <span>int</span><span>* instruction = </span><span>new</span><span> </span><span>int</span><span>[iter];  </span></span></li><li><span>    <span>int</span><span>* sizes = </span><span>new</span><span> </span><span>int</span><span>[iter];   </span></span></li><li><span>    <span>if</span><span> (instruction == NULL || sizes == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new memory failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    srand(time(NULL));   </span></li><li><span>    cout &lt;&lt; <span>&quot;generate rand number&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    <span>// instruction 中元素为1时表示在GetMemory后执行FreeMemory，0表示不执行FreeMemory</span><span>  </span></span></li><li><span>    <span>// sizes中是每次分配内存的大小，范围从64B~1024B</span><span>  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        instruction[i] = rand() % 2;  </span></li><li><span>        sizes[i] = (rand() % 16 + 1) * 64;  </span></li><li><span>    }  </span></li><li><span>    <span>int</span><span> test_count = 200;  </span></span></li><li><span>    <span>double</span><span> t1, t2;  </span></span></li><li><span>    <span>double</span><span>* ratio = </span><span>new</span><span> </span><span>double</span><span>[test_count];  </span></span></li><li><span>    <span>int</span><span> count = 0;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; test_count; k++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (break_time != 0)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ &quot;</span><span> &lt;&lt; k &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; test_count &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        count++;  </span></li><li><span>        cout &lt;&lt; <span>&quot;******************************************test &quot;</span><span> &lt;&lt; k+1 &lt;&lt; </span><span>&quot; *************************************************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        t1 = test_std_perf(iter, sizes, instruction);  </span></li><li><span>        t2 = test_mem_pool_perf_rand(mem_pool, iter,  sizes, instruction);  </span></li><li><span>        cout &lt;&lt; <span>&quot;total memory: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot;, memory used: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size   </span></span></li><li><span>            &lt;&lt; <span>&quot;, memory left: &quot;</span><span> &lt;&lt; mem_pool-&gt;size - mem_pool-&gt;mem_used_size  &lt;&lt; endl;  </span></span></li><li><span>        ratio[k] = t1 / t2;  </span></li><li><span>          </span></li><li><span>    }  </span></li><li><span>    <span>if</span><span>(break_time == 0)  </span></span></li><li><span>        break_time = test_count;  </span></li><li><span>    break_time = count - 1;  </span></li><li><span>    cout &lt;&lt; <span>&quot;*************************** ratio (system time / mem_pool time) ***************************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; break_time; k++)  </span></span></li><li><span>    {  </span></li><li><span>        out &lt;&lt; ratio[k] &lt;&lt; <span>&quot;,&quot;</span><span>;  </span></span></li><li><span>        <span>if</span><span> (k % 10 == 0 &amp;&amp; k != 0)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; endl;  </span></li><li><span>        }  </span></li><li><span>        cout &lt;&lt; ratio[k] &lt;&lt; <span>&quot; &quot;</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; endl;  </span></li><li><span>    <span>delete</span><span> []ratio;  </span></span></li><li><span>    <span>delete</span><span> []instruction;  </span></span></li><li><span>    <span>delete</span><span> []sizes;  </span></span></li><li><span>    free(pBuf);  </span></li><li><span>}  </span></li><li><span><span>// 申请紧接着释放</span><span>  </span></span></li><li><span><span>void</span><span> rand_test_2()  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> sBufSize = 500* 1024*1024;  </span></span></li><li><span>    <span>void</span><span>*pBuf = malloc(sBufSize);  </span></span></li><li><span>    <span>if</span><span> (pBuf == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;malloc failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    PMEMORYPOOL mem_pool = CreateMemoryPool(pBuf, sBufSize);  </span></li><li><span>    <span>int</span><span> iter = 2000;  </span></span></li><li><span>    <span>int</span><span> test_count = 511;  </span></span></li><li><span>    <span>int</span><span>* sizes = </span><span>new</span><span> </span><span>int</span><span>[iter];   </span></span></li><li><span>    <span>double</span><span>* ratio = </span><span>new</span><span> </span><span>double</span><span>[test_count];  </span></span></li><li><span>    <span>if</span><span> (sizes == NULL || ratio == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new memory failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    srand(time(NULL));   </span></li><li><span>    cout &lt;&lt; <span>&quot;generate rand number&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    ofstream out(<span>&quot;rand_test_2.txt&quot;</span><span>);  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; test_count; k++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>        {  </span></li><li><span>            sizes[i] = (rand() % 16 + 1) * 64 + 1024 * k;  </span></li><li><span>        }  </span></li><li><span>        <span>double</span><span> mem_pool_t = test_mem_pool_perf_1(mem_pool, iter, sizes);  </span></span></li><li><span>        <span>double</span><span> std_t = test_std_perf_1(iter, sizes);  </span></span></li><li><span>          </span></li><li><span>        ratio[k] = std_t / mem_pool_t;  </span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; <span>&quot;*************************** ratio (system time / mem_pool time) ***************************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; test_count; k++)  </span></span></li><li><span>    {  </span></li><li><span>        out &lt;&lt; ratio[k] &lt;&lt; <span>&quot;,&quot;</span><span>;  </span></span></li><li><span>        <span>if</span><span> (k % 10 == 0 &amp;&amp; k != 0)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; endl;  </span></li><li><span>        }  </span></li><li><span>        cout &lt;&lt; ratio[k] &lt;&lt; <span>&quot; &quot;</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; endl;  </span></li><li><span>      </span></li><li><span>    <span>delete</span><span> []sizes;  </span></span></li><li><span>    <span>delete</span><span> ratio;  </span></span></li><li><span>    free(pBuf);  </span></li><li><span>}  </span></li><li><span><span>int</span><span> _tmain(</span><span>int</span><span> argc, _TCHAR* argv[])  </span></span></li><li><span>{  </span></li><li><span>    rand_test();  </span></li><li><span><span>//  rand_test_2();</span><span>  </span></span></li><li><span>      </span></li><li><span>    <span>return</span><span> 0;  </span></span></li><li><span>}  </span></li></ol></div> <p><span style="white-space: pre;"> </span>大顶堆结构内存池：</p><p><span style="white-space: pre;"> </span>MemoryPool.h</p><div><div><div><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>#ifndef _MEMORYPOOL_H</span><span>  </span></span></li><li><span><span>#define _MEMORYPOOL_H</span><span>  </span></span></li><li><span><span>#include &lt;stdlib.h&gt;</span><span>  </span></span></li><li><span><span>#define MINUNITSIZE 64</span><span>  </span></span></li><li><span><span>#define ADDR_ALIGN 8</span><span>  </span></span></li><li><span><span>#define SIZE_ALIGN MINUNITSIZE</span><span>  </span></span></li><li><span><span>#define MAXCHUNKSIZE 1024*1024*64</span><span>  </span></span></li><li><span><span>struct</span><span> memory_chunk;  </span></span></li><li><span><span>typedef</span><span> </span><span>struct</span><span> memory_block  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> count;  </span></span></li><li><span>    <span>size_t</span><span> start;  </span></span></li><li><span>    memory_chunk* pmem_chunk;  </span></li><li><span>}memory_block;  </span></li><li><span><span>typedef</span><span> </span><span>struct</span><span> memory_chunk  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> chunk_size;  </span></span></li><li><span>    memory_block* pfree_mem_addr;  </span></li><li><span>}memory_chunk;  </span></li><li><span><span>typedef</span><span> </span><span>struct</span><span> max_heap  </span></span></li><li><span>{  </span></li><li><span>    memory_chunk *heap;    </span></li><li><span>    <span>size_t</span><span> maxSize;     </span></span></li><li><span>    <span>size_t</span><span> currentSize;    </span></span></li><li><span>}max_heap;  </span></li><li><span><span>typedef</span><span> </span><span>struct</span><span> MEMORYPOOL  </span></span></li><li><span>{  </span></li><li><span>    <span>void</span><span> *memory;  </span></span></li><li><span>    <span>size_t</span><span> size;  </span></span></li><li><span>    memory_block* pmem_map;   </span></li><li><span>    max_heap heap;  </span></li><li><span>    <span>size_t</span><span> mem_used_size; </span><span>// 记录内存池中已经分配给用户的内存的大小</span><span>  </span></span></li><li><span>    <span>size_t</span><span> free_mem_chunk_count; </span><span>// 记录 pfree_mem_chunk链表中的单元个数</span><span>  </span></span></li><li><span>    <span>size_t</span><span> mem_map_unit_count; </span><span>// </span><span>  </span></span></li><li><span>    <span>size_t</span><span> mem_block_count; </span><span>// 一个 mem_unit 大小为 MINUNITSIZE</span><span>  </span></span></li><li><span>}MEMORYPOOL, *PMEMORYPOOL;  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 生成内存池</span> </span></li><li><span><span>* pBuf: 给定的内存buffer起始地址</span> </span></li><li><span><span>* sBufSize: 给定的内存buffer大小</span> </span></li><li><span><span>* 返回生成的内存池指针</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span>PMEMORYPOOL CreateMemoryPool(<span>void</span><span>* pBuf, </span><span>size_t</span><span> sBufSize);  </span></span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 暂时没用</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span> ReleaseMemoryPool(PMEMORYPOOL* ppMem) ;   </span></span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 从内存池中分配指定大小的内存 </span> </span></li><li><span><span>* pMem: 内存池 指针</span> </span></li><li><span><span>* sMemorySize: 要分配的内存大小</span> </span></li><li><span><span>* 成功时返回分配的内存起始地址，失败返回NULL</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span>* GetMemory(</span><span>size_t</span><span> sMemorySize, PMEMORYPOOL pMem) ;  </span></span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 从内存池中释放申请到的内存</span> </span></li><li><span><span>* pMem：内存池指针</span> </span></li><li><span><span>* ptrMemoryBlock：申请到的内存起始地址</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span> FreeMemory(</span><span>void</span><span> *ptrMemoryBlock, PMEMORYPOOL pMem) ;  </span></span></li><li><span><span>#endif //_MEMORYPOOL_H</span><span>  </span></span></li></ol></div> <p><span style="white-space: pre;"> </span>MemoryPool.cpp</p><div><div><div><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>#include &lt;memory.h&gt;</span><span>  </span></span></li><li><span><span>#include &quot;MemoryPool.h&quot;</span><span>  </span></span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 以下为大顶堆操作*/</span><span>                                                                          </span></span></li><li><span><span>void</span><span> init_max_heap(</span><span>size_t</span><span> max_heap_size, memory_chunk* heap_arr, max_heap* heap)  </span></span></li><li><span>{  </span></li><li><span>    heap-&gt;maxSize = max_heap_size;  </span></li><li><span>    heap-&gt;currentSize = 0;  </span></li><li><span>    heap-&gt;heap = heap_arr;  </span></li><li><span>}  </span></li><li><span><span>bool</span><span> is_heap_empty(max_heap* heap)  </span></span></li><li><span>{  </span></li><li><span>    <span>return</span><span> heap-&gt;currentSize == 0;    </span></span></li><li><span>}  </span></li><li><span><span>bool</span><span> is_heap_full(max_heap* heap)  </span></span></li><li><span>{  </span></li><li><span>    <span>return</span><span> heap-&gt;currentSize == heap-&gt;maxSize;    </span></span></li><li><span>}  </span></li><li><span>memory_chunk* filter_up(max_heap* heap, <span>size_t</span><span> start)  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> i = start;  </span></span></li><li><span>    <span>size_t</span><span> j = ( i - 1 ) / 2;    </span></span></li><li><span>    memory_chunk temp = heap-&gt;heap[i];    </span></li><li><span>    <span>while</span><span>(i &gt; 0)  </span></span></li><li><span>    {    </span></li><li><span>        <span>if</span><span>(temp.chunk_size &lt;= heap-&gt;heap[j].chunk_size)  </span></span></li><li><span>            <span>break</span><span>;    </span></span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {             </span></li><li><span>            heap-&gt;heap[i] = heap-&gt;heap[j];    </span></li><li><span>            heap-&gt;heap[j].pfree_mem_addr-&gt;pmem_chunk = &amp;(heap-&gt;heap[i]);  </span></li><li><span>            i = j;    </span></li><li><span>            j = (i - 1) / 2;    </span></li><li><span>        }    </span></li><li><span>    }    </span></li><li><span>    heap-&gt;heap[i] = temp;    </span></li><li><span>    <span>return</span><span> &amp;(heap-&gt;heap[i]);  </span></span></li><li><span>}  </span></li><li><span>memory_chunk* filter_down(max_heap* heap, <span>size_t</span><span> start, </span><span>size_t</span><span> endOfHeap)  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> i = start;  </span></span></li><li><span>    <span>size_t</span><span> j = i * 2 + 1;    </span></span></li><li><span>    memory_chunk temp = heap-&gt;heap[i];    </span></li><li><span>    <span>while</span><span>(j &lt;= endOfHeap)  </span></span></li><li><span>    {    </span></li><li><span>        <span>if</span><span>(j &lt; endOfHeap &amp;&amp; heap-&gt;heap[j].chunk_size &lt; heap-&gt;heap[j+1].chunk_size)  </span></span></li><li><span>            j++;    </span></li><li><span>        <span>if</span><span>(temp.chunk_size &gt; heap-&gt;heap[j].chunk_size)  </span></span></li><li><span>            <span>break</span><span>;    </span></span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {    </span></li><li><span>            heap-&gt;heap[i] = heap-&gt;heap[j];    </span></li><li><span>            heap-&gt;heap[j].pfree_mem_addr-&gt;pmem_chunk = &amp;(heap-&gt;heap[i]);  </span></li><li><span>            i = j;    </span></li><li><span>            j = 2 * i + 1;    </span></li><li><span>        }    </span></li><li><span>    }    </span></li><li><span>    heap-&gt;heap[i] = temp;    </span></li><li><span>    <span>return</span><span> &amp;(heap-&gt;heap[i]);  </span></span></li><li><span>}  </span></li><li><span>memory_chunk* insert_heap(memory_chunk&amp; chunk, max_heap* heap)  </span></li><li><span>{  </span></li><li><span>    <span>if</span><span> (is_heap_full(heap))  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span> NULL;  </span></span></li><li><span>    }  </span></li><li><span>    heap-&gt;heap[heap-&gt;currentSize] = chunk;  </span></li><li><span>    memory_chunk* ret = filter_up(heap, heap-&gt;currentSize);  </span></li><li><span>    heap-&gt;currentSize++;    </span></li><li><span>    <span>return</span><span> ret;    </span></span></li><li><span>}  </span></li><li><span><span>bool</span><span> get_max(memory_chunk*&amp; chunk, max_heap* heap)  </span></span></li><li><span>{  </span></li><li><span>    <span>if</span><span>(is_heap_empty(heap))  </span></span></li><li><span>    {    </span></li><li><span>        <span>return</span><span> </span><span>false</span><span>;    </span></span></li><li><span>    }    </span></li><li><span>    chunk = heap-&gt;heap;    </span></li><li><span>    <span>return</span><span> </span><span>true</span><span>;  </span></span></li><li><span>}  </span></li><li><span><span>bool</span><span> remove_max(max_heap* heap)  </span></span></li><li><span>{  </span></li><li><span>    <span>if</span><span>(is_heap_empty(heap))  </span></span></li><li><span>    {    </span></li><li><span>        <span>return</span><span> </span><span>false</span><span>;    </span></span></li><li><span>    }    </span></li><li><span>    heap-&gt;heap[0] = heap-&gt;heap[heap-&gt;currentSize - 1];    </span></li><li><span>    heap-&gt;currentSize--;    </span></li><li><span>    <span>if</span><span> (heap-&gt;currentSize &gt; 0)  </span></span></li><li><span>    {  </span></li><li><span>        filter_down(heap, 0, heap-&gt;currentSize-1);    </span></li><li><span>    }  </span></li><li><span>    <span>return</span><span> </span><span>true</span><span>;    </span></span></li><li><span>}  </span></li><li><span><span>void</span><span> remove_element(memory_chunk* chunk, max_heap* heap)  </span></span></li><li><span>{  </span></li><li><span>    <span>// 删除某个非max元素有两步组成：</span><span>  </span></span></li><li><span>    <span>// 1. 将该元素size增至最大（大于max element），然后将其上移至堆顶；</span><span>  </span></span></li><li><span>    <span>// 2. 删除堆顶元素</span><span>  </span></span></li><li><span>    <span>size_t</span><span> index = chunk - heap-&gt;heap;  </span></span></li><li><span>    chunk-&gt;chunk_size = MAXCHUNKSIZE;  </span></li><li><span>    filter_up(heap, index);  </span></li><li><span>    remove_max(heap);  </span></li><li><span>}  </span></li><li><span>memory_chunk* increase_element_value(memory_chunk* chunk, max_heap* heap, <span>size_t</span><span> increase_value)  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> index = chunk - heap-&gt;heap;  </span></span></li><li><span>    chunk-&gt;chunk_size += increase_value;  </span></li><li><span>    <span>return</span><span> filter_up(heap, index);  </span></span></li><li><span>}  </span></li><li><span>memory_chunk* decrease_element_value(memory_chunk* chunk, max_heap* heap, <span>size_t</span><span> decrease_value)  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> index = chunk - heap-&gt;heap;  </span></span></li><li><span>    chunk-&gt;chunk_size -= decrease_value;  </span></li><li><span>    <span>return</span><span> filter_down(heap, index, heap-&gt;currentSize-1);  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存池起始地址对齐到ADDR_ALIGN字节</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>size_t</span><span> check_align_addr(</span><span>void</span><span>*&amp; pBuf)  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> align = 0;  </span></span></li><li><span>    <span>size_t</span><span> addr = (</span><span>int</span><span>)pBuf;  </span></span></li><li><span>    align = (ADDR_ALIGN - addr % ADDR_ALIGN) % ADDR_ALIGN;  </span></li><li><span>    pBuf = (<span>char</span><span>*)pBuf + align;  </span></span></li><li><span>    <span>return</span><span> align;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存block大小对齐到MINUNITSIZE字节</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>size_t</span><span> check_align_block(</span><span>size_t</span><span> size)  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> align = size % MINUNITSIZE;  </span></span></li><li><span>      </span></li><li><span>    <span>return</span><span> size - align;   </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 分配内存大小对齐到SIZE_ALIGN字节</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>size_t</span><span> check_align_size(</span><span>size_t</span><span> size)  </span></span></li><li><span>{  </span></li><li><span>    size = (size + SIZE_ALIGN - 1) / SIZE_ALIGN * SIZE_ALIGN;  </span></li><li><span>    <span>return</span><span> size;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存映射表中的索引转化为内存起始地址                                                                    </span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span>* index2addr(PMEMORYPOOL mem_pool, </span><span>size_t</span><span> index)  </span></span></li><li><span>{  </span></li><li><span>    <span>char</span><span>* p = (</span><span>char</span><span>*)(mem_pool-&gt;memory);  </span></span></li><li><span>    <span>void</span><span>* ret = (</span><span>void</span><span>*)(p + index *MINUNITSIZE);  </span></span></li><li><span>      </span></li><li><span>    <span>return</span><span> ret;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 内存起始地址转化为内存映射表中的索引                                                                    </span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>size_t</span><span> addr2index(PMEMORYPOOL mem_pool, </span><span>void</span><span>* addr)  </span></span></li><li><span>{  </span></li><li><span>    <span>char</span><span>* start = (</span><span>char</span><span>*)(mem_pool-&gt;memory);  </span></span></li><li><span>    <span>char</span><span>* p = (</span><span>char</span><span>*)addr;  </span></span></li><li><span>    <span>size_t</span><span> index = (p - start) / MINUNITSIZE;  </span></span></li><li><span>    <span>return</span><span> index;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 生成内存池</span> </span></li><li><span><span>* pBuf: 给定的内存buffer起始地址</span> </span></li><li><span><span>* sBufSize: 给定的内存buffer大小</span> </span></li><li><span><span>* 返回生成的内存池指针</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span>PMEMORYPOOL CreateMemoryPool(<span>void</span><span>* pBuf, </span><span>size_t</span><span> sBufSize)  </span></span></li><li><span>{  </span></li><li><span>    memset(pBuf, 0, sBufSize);  </span></li><li><span>    PMEMORYPOOL mem_pool = (PMEMORYPOOL)pBuf;  </span></li><li><span>    <span>// 计算需要多少memory map单元格</span><span>  </span></span></li><li><span>    <span>size_t</span><span> mem_pool_struct_size = </span><span>sizeof</span><span>(MEMORYPOOL);  </span></span></li><li><span>    mem_pool-&gt;mem_map_unit_count = (sBufSize - mem_pool_struct_size + MINUNITSIZE - 1) / MINUNITSIZE;  </span></li><li><span>    mem_pool-&gt;pmem_map = (memory_block*)((<span>char</span><span>*)pBuf + mem_pool_struct_size);  </span></span></li><li><span>    <span>size_t</span><span> max_heap_size = (sBufSize - mem_pool_struct_size + MINUNITSIZE - 1) / MINUNITSIZE;  </span></span></li><li><span>    memory_chunk* heap_arr = (memory_chunk*)((<span>char</span><span>*)pBuf + mem_pool_struct_size + </span><span>sizeof</span><span>(memory_block) * mem_pool-&gt;mem_map_unit_count);    </span></span></li><li><span>      </span></li><li><span>    mem_pool-&gt;memory = (<span>char</span><span>*)pBuf + mem_pool_struct_size+ </span><span>sizeof</span><span>(memory_block) * mem_pool-&gt;mem_map_unit_count + </span><span>sizeof</span><span>(memory_chunk) * max_heap_size;  </span></span></li><li><span>    mem_pool-&gt;size = sBufSize - mem_pool_struct_size - <span>sizeof</span><span>(memory_block) * mem_pool-&gt;mem_map_unit_count - </span><span>sizeof</span><span>(memory_chunk) * max_heap_size;  </span></span></li><li><span>    <span>size_t</span><span> align = check_align_addr(mem_pool-&gt;memory);  </span></span></li><li><span>    mem_pool-&gt;size -= align;  </span></li><li><span>    mem_pool-&gt;size = check_align_block(mem_pool-&gt;size);  </span></li><li><span>    mem_pool-&gt;mem_block_count = mem_pool-&gt;size / MINUNITSIZE;  </span></li><li><span>    init_max_heap(mem_pool-&gt;mem_block_count, heap_arr, &amp;(mem_pool-&gt;heap));  </span></li><li><span>    memory_chunk chunk;  </span></li><li><span>    chunk.chunk_size = mem_pool-&gt;mem_block_count;  </span></li><li><span>    memory_chunk* pos = insert_heap(chunk, &amp;(mem_pool-&gt;heap));  </span></li><li><span>      </span></li><li><span>    <span>// 初始化 pmem_map</span><span>  </span></span></li><li><span>    mem_pool-&gt;pmem_map[0].count = mem_pool-&gt;mem_block_count;  </span></li><li><span>    mem_pool-&gt;pmem_map[0].pmem_chunk = pos;  </span></li><li><span>    mem_pool-&gt;pmem_map[mem_pool-&gt;mem_block_count-1].start = 0;  </span></li><li><span>      </span></li><li><span>    pos-&gt;pfree_mem_addr = mem_pool-&gt;pmem_map;  </span></li><li><span>    mem_pool-&gt;mem_used_size = 0;  </span></li><li><span>    <span>return</span><span> mem_pool;  </span></span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 暂时没用</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span> ReleaseMemoryPool(PMEMORYPOOL* ppMem)   </span></span></li><li><span>{  </span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 从内存池中分配指定大小的内存 </span> </span></li><li><span><span>* pMem: 内存池 指针</span> </span></li><li><span><span>* sMemorySize: 要分配的内存大小</span> </span></li><li><span><span>* 成功时返回分配的内存起始地址，失败返回NULL</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span>* GetMemory(</span><span>size_t</span><span> sMemorySize, PMEMORYPOOL pMem)  </span></span></li><li><span>{  </span></li><li><span>    sMemorySize = check_align_size(sMemorySize);  </span></li><li><span>    <span>size_t</span><span> index = 0;  </span></span></li><li><span>    memory_chunk* max_chunk;  </span></li><li><span>    <span>bool</span><span> ret = get_max(max_chunk, &amp;(pMem-&gt;heap));  </span></span></li><li><span>    <span>if</span><span> (ret == </span><span>false</span><span> || max_chunk-&gt;chunk_size * MINUNITSIZE &lt; sMemorySize)  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span> NULL;  </span></span></li><li><span>    }  </span></li><li><span>    pMem-&gt;mem_used_size += sMemorySize;  </span></li><li><span>    <span>if</span><span> (max_chunk-&gt;chunk_size * MINUNITSIZE == sMemorySize)  </span></span></li><li><span>    {  </span></li><li><span>        <span>// 当要分配的内存大小与当前chunk中的内存大小相同时，从pfree_mem_chunk链表中删除此chunk</span><span>  </span></span></li><li><span>        <span>size_t</span><span> current_index = (max_chunk-&gt;pfree_mem_addr - pMem-&gt;pmem_map);  </span></span></li><li><span>        remove_max(&amp;(pMem-&gt;heap));  </span></li><li><span>          </span></li><li><span>        <span>return</span><span> index2addr(pMem, current_index);  </span></span></li><li><span>    }  </span></li><li><span>    <span>else</span><span>  </span></span></li><li><span>    {  </span></li><li><span>        <span>// 当要分配的内存小于当前chunk中的内存时，更改pfree_mem_chunk中相应chunk的pfree_mem_addr</span><span>  </span></span></li><li><span>          </span></li><li><span>        <span>// 复制当前mem_map_unit</span><span>  </span></span></li><li><span>        memory_block copy;  </span></li><li><span>        copy.count = max_chunk-&gt;pfree_mem_addr-&gt;count;  </span></li><li><span>        copy.pmem_chunk = max_chunk;  </span></li><li><span>        <span>// 记录该block的起始和结束索引</span><span>  </span></span></li><li><span>        memory_block* current_block = max_chunk-&gt;pfree_mem_addr;  </span></li><li><span>        current_block-&gt;count = sMemorySize / MINUNITSIZE;  </span></li><li><span>        <span>size_t</span><span> current_index = (current_block - pMem-&gt;pmem_map);  </span></span></li><li><span>        pMem-&gt;pmem_map[current_index+current_block-&gt;count-1].start = current_index;  </span></li><li><span>        current_block-&gt;pmem_chunk = NULL; <span>// NULL表示当前内存块已被分配</span><span>  </span></span></li><li><span>        <span>// 当前block被一分为二，更新第二个block中的内容</span><span>  </span></span></li><li><span>        memory_chunk* pos = decrease_element_value(max_chunk, &amp;(pMem-&gt;heap), current_block-&gt;count);  </span></li><li><span>        pMem-&gt;pmem_map[current_index+current_block-&gt;count].count = copy.count - current_block-&gt;count;  </span></li><li><span>        pMem-&gt;pmem_map[current_index+current_block-&gt;count].pmem_chunk = pos;  </span></li><li><span>        <span>// 更新原来的pfree_mem_addr</span><span>  </span></span></li><li><span>        pos-&gt;pfree_mem_addr = &amp;(pMem-&gt;pmem_map[current_index+current_block-&gt;count]);  </span></li><li><span>      </span></li><li><span>        <span>size_t</span><span> end_index = current_index + copy.count - 1;  </span></span></li><li><span>        pMem-&gt;pmem_map[end_index].start = current_index + current_block-&gt;count;  </span></li><li><span>        <span>return</span><span> index2addr(pMem, current_index);  </span></span></li><li><span>    }     </span></li><li><span>}  </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>/* 从内存池中释放申请到的内存</span> </span></li><li><span><span>* pMem：内存池指针</span> </span></li><li><span><span>* ptrMemoryBlock：申请到的内存起始地址</span> </span></li><li><span><span>/************************************************************************/</span><span>  </span></span></li><li><span><span>void</span><span> FreeMemory(</span><span>void</span><span> *ptrMemoryBlock, PMEMORYPOOL pMem)   </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> current_index = addr2index(pMem, ptrMemoryBlock);  </span></span></li><li><span>    <span>size_t</span><span> size = pMem-&gt;pmem_map[current_index].count * MINUNITSIZE;  </span></span></li><li><span>    <span>// 判断与当前释放的内存块相邻的内存块是否可以与当前释放的内存块合并</span><span>  </span></span></li><li><span>    memory_block* pre_block = NULL;  </span></li><li><span>    memory_block* next_block = NULL;  </span></li><li><span>    memory_block* current_block = &amp;(pMem-&gt;pmem_map[current_index]);  </span></li><li><span>    <span>// 第一个</span><span>  </span></span></li><li><span>    <span>if</span><span> (current_index == 0)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (current_block-&gt;count &lt; pMem-&gt;mem_block_count)  </span></span></li><li><span>        {  </span></li><li><span>            next_block = &amp;(pMem-&gt;pmem_map[current_index+current_block-&gt;count]);  </span></li><li><span>            <span>// 如果后一个内存块是空闲的，合并</span><span>  </span></span></li><li><span>            <span>if</span><span> (next_block-&gt;pmem_chunk != NULL)  </span></span></li><li><span>            {  </span></li><li><span>                memory_chunk* pos = increase_element_value(next_block-&gt;pmem_chunk, &amp;(pMem-&gt;heap), current_block-&gt;count);  </span></li><li><span>                pos-&gt;pfree_mem_addr = current_block;  </span></li><li><span>                pMem-&gt;pmem_map[current_index+current_block-&gt;count+next_block-&gt;count-1].start = current_index;  </span></li><li><span>                current_block-&gt;count += next_block-&gt;count;  </span></li><li><span>                current_block-&gt;pmem_chunk = pos;  </span></li><li><span>                next_block-&gt;pmem_chunk = NULL;  </span></li><li><span>            }  </span></li><li><span>            <span>// 如果后一块内存不是空闲的，在pfree_mem_chunk中增加一个chunk</span><span>  </span></span></li><li><span>            <span>else</span><span>  </span></span></li><li><span>            {  </span></li><li><span>                memory_chunk new_chunk;  </span></li><li><span>                new_chunk.chunk_size = current_block-&gt;count;  </span></li><li><span>                new_chunk.pfree_mem_addr = current_block;  </span></li><li><span>                memory_chunk* pos = insert_heap(new_chunk, &amp;(pMem-&gt;heap));  </span></li><li><span>                current_block-&gt;pmem_chunk = pos;  </span></li><li><span>            }  </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            memory_chunk new_chunk;  </span></li><li><span>            new_chunk.chunk_size = current_block-&gt;count;  </span></li><li><span>            new_chunk.pfree_mem_addr = current_block;  </span></li><li><span>            memory_chunk* pos = insert_heap(new_chunk, &amp;(pMem-&gt;heap));  </span></li><li><span>            current_block-&gt;pmem_chunk = pos;  </span></li><li><span>        }         </span></li><li><span>    }  </span></li><li><span>      </span></li><li><span>    <span>// 最后一个</span><span>  </span></span></li><li><span>    <span>else</span><span> </span><span>if</span><span> (current_index == pMem-&gt;mem_block_count-1)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (current_block-&gt;count &lt; pMem-&gt;mem_block_count)  </span></span></li><li><span>        {  </span></li><li><span>            pre_block = &amp;(pMem-&gt;pmem_map[current_index-1]);  </span></li><li><span>            <span>size_t</span><span> index = pre_block-&gt;count;  </span></span></li><li><span>            pre_block = &amp;(pMem-&gt;pmem_map[index]);  </span></li><li><span>              </span></li><li><span>            <span>// 如果前一个内存块是空闲的，合并</span><span>  </span></span></li><li><span>            <span>if</span><span> (pre_block-&gt;pmem_chunk != NULL)  </span></span></li><li><span>            {  </span></li><li><span>                memory_chunk* pos = increase_element_value(pre_block-&gt;pmem_chunk, &amp;(pMem-&gt;heap), current_block-&gt;count);  </span></li><li><span>                pre_block-&gt;pmem_chunk = pos;  </span></li><li><span>                pMem-&gt;pmem_map[current_index+current_block-&gt;count-1].start = current_index - pre_block-&gt;count;  </span></li><li><span>                pre_block-&gt;count += current_block-&gt;count;  </span></li><li><span>                current_block-&gt;pmem_chunk = NULL;  </span></li><li><span>            }  </span></li><li><span>            <span>// 如果前一块内存不是空闲的，在pfree_mem_chunk中增加一个chunk</span><span>  </span></span></li><li><span>            <span>else</span><span>  </span></span></li><li><span>            {  </span></li><li><span>                memory_chunk new_chunk;  </span></li><li><span>                new_chunk.chunk_size = current_block-&gt;count;  </span></li><li><span>                new_chunk.pfree_mem_addr = current_block;  </span></li><li><span>                memory_chunk* pos = insert_heap(new_chunk, &amp;(pMem-&gt;heap));  </span></li><li><span>                current_block-&gt;pmem_chunk = pos;  </span></li><li><span>            }  </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            memory_chunk new_chunk;  </span></li><li><span>            new_chunk.chunk_size = current_block-&gt;count;  </span></li><li><span>            new_chunk.pfree_mem_addr = current_block;  </span></li><li><span>            memory_chunk* pos = insert_heap(new_chunk, &amp;(pMem-&gt;heap));  </span></li><li><span>            current_block-&gt;pmem_chunk = pos;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    <span>else</span><span>  </span></span></li><li><span>    {         </span></li><li><span>        next_block = &amp;(pMem-&gt;pmem_map[current_index+current_block-&gt;count]);  </span></li><li><span>        pre_block = &amp;(pMem-&gt;pmem_map[current_index-1]);  </span></li><li><span>        <span>size_t</span><span> index = pre_block-&gt;start;  </span></span></li><li><span>        pre_block = &amp;(pMem-&gt;pmem_map[index]);  </span></li><li><span>        <span>bool</span><span> is_back_merge = </span><span>false</span><span>;  </span></span></li><li><span>        <span>if</span><span> (next_block-&gt;pmem_chunk == NULL &amp;&amp; pre_block-&gt;pmem_chunk == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            memory_chunk new_chunk;  </span></li><li><span>            new_chunk.chunk_size = current_block-&gt;count;  </span></li><li><span>            new_chunk.pfree_mem_addr = current_block;  </span></li><li><span>            memory_chunk* pos = insert_heap(new_chunk, &amp;(pMem-&gt;heap));  </span></li><li><span>            current_block-&gt;pmem_chunk = pos;  </span></li><li><span>        }  </span></li><li><span>        <span>// 后一个内存块</span><span>  </span></span></li><li><span>        <span>if</span><span> (next_block-&gt;pmem_chunk != NULL)  </span></span></li><li><span>        {  </span></li><li><span>            memory_chunk* pos = increase_element_value(next_block-&gt;pmem_chunk, &amp;(pMem-&gt;heap), current_block-&gt;count);  </span></li><li><span>            pos-&gt;pfree_mem_addr = current_block;  </span></li><li><span>            pMem-&gt;pmem_map[current_index+current_block-&gt;count+next_block-&gt;count-1].start = current_index;  </span></li><li><span>            current_block-&gt;count += next_block-&gt;count;  </span></li><li><span>            current_block-&gt;pmem_chunk = pos;  </span></li><li><span>            next_block-&gt;pmem_chunk = NULL;  </span></li><li><span>            is_back_merge = <span>true</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        <span>// 前一个内存块</span><span>  </span></span></li><li><span>        <span>if</span><span> (pre_block-&gt;pmem_chunk != NULL)  </span></span></li><li><span>        {  </span></li><li><span>            pMem-&gt;pmem_map[current_index+current_block-&gt;count-1].start = current_index - pre_block-&gt;count;  </span></li><li><span>            pre_block-&gt;count += current_block-&gt;count;  </span></li><li><span>            memory_chunk* pos = increase_element_value(pre_block-&gt;pmem_chunk, &amp;(pMem-&gt;heap), current_block-&gt;count);  </span></li><li><span>            pre_block-&gt;pmem_chunk = pos;  </span></li><li><span>            pos-&gt;pfree_mem_addr = pre_block;  </span></li><li><span>            <span>if</span><span> (is_back_merge)  </span></span></li><li><span>            {  </span></li><li><span>                remove_element(current_block-&gt;pmem_chunk, &amp;(pMem-&gt;heap));  </span></li><li><span>            }  </span></li><li><span>            current_block-&gt;pmem_chunk = NULL;              </span></li><li><span>        }     </span></li><li><span>    }  </span></li><li><span>    pMem-&gt;mem_used_size -= size;  </span></li><li><span>}  </span></li></ol></div> <p><span style="white-space: pre;"> </span>MemoryPoolTest.cpp</p><div><div><div><strong>[cpp]</strong> <a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="view plain">view plain</a><a href="http://blog.csdn.net/shawngucas/article/details/6574863#" shape="rect" title="copy">copy</a><br clear="none"/></div></div><ol start="1"><li><span><span>// memory pool test.cpp : Defines the entry point for the console application.</span><span>  </span></span></li><li><span><span>//</span><span>  </span></span></li><li><span><span>#include &lt;tchar.h&gt;</span><span>  </span></span></li><li><span><span>#include &quot;MemoryPool.h&quot;</span><span>  </span></span></li><li><span><span>#include &lt;iostream&gt;</span><span>  </span></span></li><li><span><span>#include &lt;windows.h&gt;</span><span>  </span></span></li><li><span><span>#include &lt;vector&gt;</span><span>  </span></span></li><li><span><span>#include &lt;time.h&gt;</span><span>  </span></span></li><li><span><span>#include &lt;math.h&gt;</span><span>  </span></span></li><li><span><span>#include &lt;fstream&gt;</span><span>  </span></span></li><li><span><span>using</span><span> </span><span>namespace</span><span> std;  </span></span></li><li><span><span>int</span><span> break_time = 0;  </span></span></li><li><span><span>size_t</span><span> used_size = 0;  </span></span></li><li><span><span>void</span><span> output_heap(max_heap* heap, ofstream&amp; out)  </span></span></li><li><span>{  </span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; heap-&gt;currentSize; k++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (k != 0 &amp;&amp; k % 10 == 0)  </span></span></li><li><span>        {  </span></li><li><span>            out &lt;&lt; endl;  </span></li><li><span>        }  </span></li><li><span>        out &lt;&lt; heap-&gt;heap[k].chunk_size &lt;&lt; <span>&quot; &quot;</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    out &lt;&lt; endl;  </span></li><li><span>}  </span></li><li><span><span>void</span><span> check_mem_pool(</span><span>int</span><span>&amp; max_chunk_size, </span><span>int</span><span>&amp; free_chunk_count, </span><span>int</span><span>&amp; min_chunk_size, </span><span>int</span><span>&amp; total_free_mem, MEMORYPOOL* mem_pool)  </span></span></li><li><span>{  </span></li><li><span>    total_free_mem = 0;  </span></li><li><span>    max_chunk_size = 0;  </span></li><li><span>    min_chunk_size = 1024*1024*1024;  </span></li><li><span>    free_chunk_count = mem_pool-&gt;heap.currentSize;  </span></li><li><span>      </span></li><li><span>    <span>size_t</span><span> size;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; free_chunk_count; k++)  </span></span></li><li><span>    {  </span></li><li><span>        size = mem_pool-&gt;heap.heap[k].chunk_size * MINUNITSIZE;  </span></li><li><span>        total_free_mem += size;  </span></li><li><span>        <span>if</span><span> (size &gt; max_chunk_size)  </span></span></li><li><span>        {  </span></li><li><span>            max_chunk_size = size;  </span></li><li><span>        }  </span></li><li><span>        <span>if</span><span> (size &lt; min_chunk_size)  </span></span></li><li><span>        {  </span></li><li><span>            min_chunk_size = size;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>}  </span></li><li><span><span>// 申请后紧接着释放</span><span>  </span></span></li><li><span><span>double</span><span> test_mem_pool_perf_1(PMEMORYPOOL mem_pool, </span><span>int</span><span> iter, </span><span>int</span><span>* sizes)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_mem_pool_perf_1*********************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>void</span><span> *p = GetMemory(sizes[i], mem_pool);  </span></span></li><li><span>        <span>if</span><span> (p == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; sizes[i] &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;total memory is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size -  mem_pool-&gt;mem_used_size  &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>            <span>int</span><span> max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem;  </span></span></li><li><span>            check_mem_pool(max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem,  mem_pool);  </span></li><li><span>            cout &lt;&lt; <span>&quot;check memory pool result:&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;free_chunk_count:    &quot;</span><span> &lt;&lt; free_chunk_count &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;total_free_mem:   &quot;</span><span> &lt;&lt; total_free_mem &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;max_chunk_size:   &quot;</span><span> &lt;&lt; max_chunk_size &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;min_chunk_size:   &quot;</span><span> &lt;&lt; min_chunk_size &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        FreeMemory(p,  mem_pool);  </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_mem_pool_perf_1: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_mem_pool_perf_1*********************&quot;</span><span> &lt;&lt;  endl &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>double</span><span> test_std_perf_1(</span><span>int</span><span> iter, </span><span>int</span><span>* sizes)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_std_perf_1*********************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>void</span><span> *p = malloc(sizes[i]);  </span></span></li><li><span>        <span>if</span><span> (p == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; sizes[i] &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        free(p);  </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_std_perf_1: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;*********************test_std_perf_1*********************&quot;</span><span> &lt;&lt;  endl &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>double</span><span> test_mem_pool_perf_rand(PMEMORYPOOL mem_pool, </span><span>int</span><span> iter, </span><span>int</span><span>* sizes, </span><span>int</span><span>* instruction)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;-----------------------test_mem_pool_perf_rand----------------------- &quot;</span><span>&lt;&lt; endl;  </span></span></li><li><span>    <span>void</span><span>** p = </span><span>new</span><span> </span><span>void</span><span>*[iter];  </span></span></li><li><span>    <span>if</span><span> (p == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span> -1;  </span></span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; <span>&quot;test start&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    LARGE_INTEGER litmp, gftime;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2, start, finish;  </span></span></li><li><span>    <span>double</span><span> t, GetMemory_time, FreeMemory_time;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>int</span><span> index = 0;  </span></span></li><li><span>    <span>int</span><span> size;  </span></span></li><li><span>    <span>int</span><span> free_tmp = 0;  </span></span></li><li><span>    <span>double</span><span> seach_time;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        size = sizes[i];  </span></li><li><span>        p[index++] = GetMemory(size, mem_pool);  </span></li><li><span>        <span>if</span><span> (p[index-1] == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            break_time++;  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ iterator = &quot;</span><span> &lt;&lt; i &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; iter &lt;&lt; </span><span>&quot;,    need memory &quot;</span><span> &lt;&lt; size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;total memory is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory used is: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size &lt;&lt; </span><span>&quot; Byte&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;memory left is: &quot;</span><span> &lt;&lt; mem_pool-&gt;size -  mem_pool-&gt;mem_used_size  &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>            <span>int</span><span> max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem;  </span></span></li><li><span>            check_mem_pool(max_chunk_size, free_chunk_count, min_chunk_size, total_free_mem,  mem_pool);  </span></li><li><span>            cout &lt;&lt; <span>&quot;check memory pool result:&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>            cout &lt;&lt; <span>&quot;free_chunk_count:    &quot;</span><span> &lt;&lt; free_chunk_count &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;total_free_mem:   &quot;</span><span> &lt;&lt; total_free_mem &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;max_chunk_size:   &quot;</span><span> &lt;&lt; max_chunk_size &lt;&lt; endl  </span></span></li><li><span>                &lt;&lt; <span>&quot;min_chunk_size:   &quot;</span><span> &lt;&lt; min_chunk_size &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        used_size += size;  </span></li><li><span>        <span>if</span><span> (instruction[i] == 1)  </span></span></li><li><span>        {             </span></li><li><span>            FreeMemory(p[--index],  mem_pool);  </span></li><li><span>            used_size -= size;  </span></li><li><span>        }     </span></li><li><span>    }  </span></li><li><span>      </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_mem_pool_perf_rand: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>delete</span><span> []p;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>double</span><span> test_std_perf(</span><span>int</span><span> iter, </span><span>int</span><span>* sizes, </span><span>int</span><span>* instruction)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;test_std_perf&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    <span>void</span><span>** p =</span><span>new</span><span> </span><span>void</span><span>*[iter];  </span></span></li><li><span>    <span>if</span><span> (p == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span> -1;  </span></span></li><li><span>    }  </span></li><li><span>      </span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span><span>//  cout &lt;&lt; &quot;test start&quot; &lt;&lt; endl;</span><span>  </span></span></li><li><span>    <span>int</span><span> index = 0;  </span></span></li><li><span>    <span>int</span><span> size;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        size = sizes[i];  </span></li><li><span>        p[index++] = malloc(size);  </span></li><li><span>        <span>if</span><span> (p[index-1] == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; i &lt;&lt; endl;  </span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        <span>if</span><span> (instruction[i] == 1)  </span></span></li><li><span>        {  </span></li><li><span>            free(p[--index]);  </span></li><li><span>        }         </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_std_perf: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; index; k++)  </span></span></li><li><span>    {  </span></li><li><span>        free(p[k]);  </span></li><li><span>    }  </span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>double</span><span> test_std_perf_fix_size(</span><span>int</span><span> iter, </span><span>int</span><span> size)  </span></span></li><li><span>{  </span></li><li><span>    cout &lt;&lt; <span>&quot;test_std_perf_fix_size&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    LARGE_INTEGER litmp;   </span></li><li><span>    <span>LONGLONG</span><span> QPart1, QPart2;  </span></span></li><li><span>    <span>double</span><span> t;  </span></span></li><li><span>    <span>double</span><span> dfMinus, dfFreq;   </span></span></li><li><span>    QueryPerformanceFrequency(&amp;litmp);  </span></li><li><span>    dfFreq = (<span>double</span><span>)litmp.QuadPart;</span><span>// 获得计数器的时钟频率</span><span>  </span></span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart1 = litmp.QuadPart;<span>// 获得初始值</span><span>  </span></span></li><li><span>    <span>int</span><span> index = 0;  </span></span></li><li><span>      </span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>void</span><span> *p = malloc(size);  </span></span></li><li><span>        <span>if</span><span> (p == NULL)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; i &lt;&lt; endl;  </span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        free(p);  </span></li><li><span>    }  </span></li><li><span>    QueryPerformanceCounter(&amp;litmp);  </span></li><li><span>    QPart2 = litmp.QuadPart;<span>//获得中止值</span><span>  </span></span></li><li><span>    dfMinus = (<span>double</span><span>)(QPart2-QPart1);  </span></span></li><li><span>    t = dfMinus / dfFreq;<span>// 获得对应的时间值，单位为秒   </span><span>  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;test_std_perf: iter = &quot;</span><span> &lt;&lt; iter &lt;&lt; endl;  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;time: &quot;</span><span> &lt;&lt; t &lt;&lt; endl &lt;&lt; endl;  </span></span></li><li><span>    <span>return</span><span> t;  </span></span></li><li><span>}  </span></li><li><span><span>void</span><span> rand_test()  </span></span></li><li><span>{  </span></li><li><span>    ofstream out(<span>&quot;rand_test.txt&quot;</span><span>);  </span></span></li><li><span>    used_size = 0;  </span></li><li><span>    <span>int</span><span> iter = 2000;  </span></span></li><li><span>    <span>size_t</span><span> sBufSize = 500* 1024*1024;  </span></span></li><li><span>    <span>void</span><span>*pBuf = malloc(sBufSize);  </span></span></li><li><span>    <span>if</span><span> (pBuf == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;malloc failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    PMEMORYPOOL mem_pool = CreateMemoryPool(pBuf, sBufSize);  </span></li><li><span>    <span>int</span><span>* instruction = </span><span>new</span><span> </span><span>int</span><span>[iter];  </span></span></li><li><span>    <span>int</span><span>* sizes = </span><span>new</span><span> </span><span>int</span><span>[iter];   </span></span></li><li><span>    <span>if</span><span> (instruction == NULL || sizes == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    srand(time(NULL));   </span></li><li><span>    ofstream out_rand(<span>&quot;rand&quot;</span><span>);  </span></span></li><li><span>    ofstream out_size(<span>&quot;size&quot;</span><span>);  </span></span></li><li><span>    cout &lt;&lt; <span>&quot;generate rand number&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    <span>int</span><span> k_count = 0;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>    {  </span></li><li><span>        instruction[i] = rand() % 2;  </span></li><li><span>        sizes[i] = (rand() % 16 + 1) * 64;  </span></li><li><span>    }  </span></li><li><span>    <span>int</span><span> test_count = 200;  </span></span></li><li><span>    <span>double</span><span> t1, t2;  </span></span></li><li><span>    <span>double</span><span>* ratio = </span><span>new</span><span> </span><span>double</span><span>[test_count];  </span></span></li><li><span>    <span>int</span><span> count = 0;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; test_count; k++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (break_time != 0)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; <span>&quot;break @ &quot;</span><span> &lt;&lt; k &lt;&lt; </span><span>&quot; / &quot;</span><span> &lt;&lt; test_count &lt;&lt; endl;  </span></span></li><li><span>            <span>break</span><span>;  </span></span></li><li><span>        }  </span></li><li><span>        count++;  </span></li><li><span>        cout &lt;&lt; <span>&quot;******************************************test &quot;</span><span> &lt;&lt; k+1 &lt;&lt; </span><span>&quot; *************************************************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        t1 = test_std_perf(iter, sizes, instruction);  </span></li><li><span>        t2 = test_mem_pool_perf_rand(mem_pool, iter,  sizes, instruction);  </span></li><li><span>        cout &lt;&lt; <span>&quot;total memory: &quot;</span><span> &lt;&lt; mem_pool-&gt;size &lt;&lt; </span><span>&quot;, memory used: &quot;</span><span> &lt;&lt; mem_pool-&gt;mem_used_size   </span></span></li><li><span>            &lt;&lt; <span>&quot;, memory left: &quot;</span><span> &lt;&lt; mem_pool-&gt;size - mem_pool-&gt;mem_used_size  &lt;&lt; endl;  </span></span></li><li><span>        ratio[k] = t1 / t2;  </span></li><li><span>    }  </span></li><li><span>    <span>if</span><span>(break_time == 0)  </span></span></li><li><span>        break_time = test_count;  </span></li><li><span>    break_time = count - 1;  </span></li><li><span>    cout &lt;&lt; <span>&quot;*************************** ratio (system time / mem_pool time) ***************************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; break_time; k++)  </span></span></li><li><span>    {  </span></li><li><span>        out &lt;&lt; ratio[k] &lt;&lt; <span>&quot;,&quot;</span><span>;  </span></span></li><li><span>        <span>if</span><span> (k % 10 == 0 &amp;&amp; k != 0)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; endl;  </span></li><li><span>        }  </span></li><li><span>        cout &lt;&lt; ratio[k] &lt;&lt; <span>&quot; &quot;</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; endl;  </span></li><li><span>    <span>delete</span><span> []ratio;  </span></span></li><li><span>    free(pBuf);  </span></li><li><span>    <span>delete</span><span> []instruction;  </span></span></li><li><span>    <span>delete</span><span> []sizes;  </span></span></li><li><span>}  </span></li><li><span><span>// 申请紧接着释放</span><span>  </span></span></li><li><span><span>void</span><span> rand_test_2()  </span></span></li><li><span>{  </span></li><li><span>    <span>size_t</span><span> sBufSize = 500* 1024*1024;  </span></span></li><li><span>    <span>void</span><span>*pBuf = malloc(sBufSize);  </span></span></li><li><span>    <span>if</span><span> (pBuf == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;malloc failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    PMEMORYPOOL mem_pool = CreateMemoryPool(pBuf, sBufSize);  </span></li><li><span>    <span>int</span><span> iter = 1000;  </span></span></li><li><span>    <span>int</span><span> test_count = 1024;  </span></span></li><li><span>    <span>int</span><span>* sizes = </span><span>new</span><span> </span><span>int</span><span>[iter];   </span></span></li><li><span>    <span>double</span><span>* ratio = </span><span>new</span><span> </span><span>double</span><span>[test_count];  </span></span></li><li><span>    <span>double</span><span>* std_perf = </span><span>new</span><span> </span><span>double</span><span>[test_count];  </span></span></li><li><span>    <span>double</span><span>* mem_pool_perf = </span><span>new</span><span> </span><span>double</span><span>[test_count];  </span></span></li><li><span>    <span>if</span><span> (sizes == NULL || ratio == NULL)  </span></span></li><li><span>    {  </span></li><li><span>        cout &lt;&lt; <span>&quot;new memory failed&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>return</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    srand(time(NULL));   </span></li><li><span>    cout &lt;&lt; <span>&quot;generate rand number&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    ofstream out(<span>&quot;rand_test_2.txt&quot;</span><span>);  </span></span></li><li><span>    ofstream out_std(<span>&quot;std_perf_2.txt&quot;</span><span>);  </span></span></li><li><span>    ofstream out_mem_pool(<span>&quot;mem_pool_perf_2.txt&quot;</span><span>);  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; test_count; k++)  </span></span></li><li><span>    {  </span></li><li><span>        <span>for</span><span> (</span><span>int</span><span> i = 0; i &lt; iter; i++)  </span></span></li><li><span>        {  </span></li><li><span>            sizes[i] = (rand() % 16 + 1) * 64 + 1024 * k;  </span></li><li><span>        }  </span></li><li><span>        cout &lt;&lt; <span>&quot;******************************************test &quot;</span><span> &lt;&lt; k+1 &lt;&lt; </span><span>&quot; *************************************************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>        <span>double</span><span> mem_pool_t = test_mem_pool_perf_1(mem_pool, iter, sizes);  </span></span></li><li><span>        <span>double</span><span> std_t = test_std_perf_1(iter, sizes);  </span></span></li><li><span>        std_perf[k] = std_t;  </span></li><li><span>        mem_pool_perf[k] = mem_pool_t;  </span></li><li><span>        ratio[k] = std_t / mem_pool_t;  </span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; <span>&quot;*************************** ratio (system time / mem_pool time) ***************************&quot;</span><span> &lt;&lt; endl;  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> k = 0; k &lt; test_count; k++)  </span></span></li><li><span>    {  </span></li><li><span>        out_std &lt;&lt; std_perf[k] &lt;&lt; <span>&quot;,&quot;</span><span>;  </span></span></li><li><span>        out_mem_pool &lt;&lt; mem_pool_perf[k] &lt;&lt; <span>&quot;,&quot;</span><span>;  </span></span></li><li><span>        out &lt;&lt; ratio[k] &lt;&lt; <span>&quot;,&quot;</span><span>;  </span></span></li><li><span>        <span>if</span><span> (k % 10 == 0 &amp;&amp; k != 0)  </span></span></li><li><span>        {  </span></li><li><span>            cout &lt;&lt; endl;  </span></li><li><span>        }  </span></li><li><span>        cout &lt;&lt; ratio[k] &lt;&lt; <span>&quot; &quot;</span><span>;  </span></span></li><li><span>    }  </span></li><li><span>    cout &lt;&lt; endl;  </span></li><li><span>    <span>delete</span><span> []sizes;  </span></span></li><li><span>    <span>delete</span><span> []ratio;  </span></span></li><li><span>    <span>delete</span><span> []mem_pool_perf;  </span></span></li><li><span>    <span>delete</span><span> []std_perf;  </span></span></li><li><span>    free(pBuf);  </span></li><li><span>}  </span></li><li><span><span>int</span><span> _tmain(</span><span>int</span><span> argc, _TCHAR* argv[])  </span></span></li><li><span>{  </span></li><li><span><span>//  rand_test();</span><span>  </span></span></li><li><span>    rand_test_2();  </span></li><li><span>      </span></li><li><span>    <span>return</span><span> 0;  </span></span></li><li><span>}  </span></li></ol></div> <p><br clear="none"/></p></div></div>
</div></body></html> 