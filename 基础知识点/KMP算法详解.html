<html>
<head>
  <title>KMP算法详解</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1134"/>
<h1>KMP算法详解</h1>

<div>
<div><div><h3>引记</h3><p>    此前一天，一位MS的朋友邀我一起去与他讨论快速排序，红黑树，字典树，<span style="font-family: Arial;">B</span><span style="font-family: 宋体;">树、后缀树，包括</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法，唯独在讲解</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法的时候，言语磕磕碰碰，我想，原因有二：</span><span style="font-family: Arial;">1</span><span style="font-family: 宋体;">、博客内的东西不常回顾，忘了不少；</span><span style="font-family: Arial;">2</span><span style="font-family: 宋体;">、便是我对</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法的理解还不够彻底，自不用说讲解自如，运用自如了。所以，特再写本篇文章。由于此前，个人已经写过关于</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法的两篇文章，所以，本文名为：</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法之总结篇。</span></p><p>   本文分为如下六个部分：</p><ol><li>第一部分、再次回顾普通的<span style="font-family: Arial;">BF</span><span style="font-family: 宋体;">算法与</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法各自的时间复杂度，并两相对照各自的匹配原理；</span></li><li><span style="font-family: 宋体;">第二部分、通过我此前第二篇文章的引用，用图从头到尾详细阐述</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法中的</span><span style="font-family: Arial;">next</span><span style="font-family: 宋体;">数组求法，并运用求得的</span><span style="font-family: Arial;">next</span><span style="font-family: 宋体;">数组写出</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法的源码；</span></li><li><span style="font-family: 宋体;">第三部分、KMP算法的两种实现，代码实现一是根据本人关于KMP算法的第二篇文章所写，代码实现二是根据本人的关于KMP算法的第一篇文章所写；</span></li><li><span style="font-family: 宋体;">第四部分、测试，分别对第三部分的两种实现中next数组的求法进行测试，挖掘其区别之所在；</span></li><li><span style="font-family: 宋体;">第五部分、KMP完整准确源码，给出KMP算法的准确的完整源码；</span></li><li><span style="font-family: 宋体;">第六步份、一眼看出字符串的next数组各值，通过几个例子，让读者能根据字符串本身一眼判断出其next数组各值。</span></li></ol><p><span style="font-family: 宋体;">    力求让此文彻底让读者洞穿此</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法，所有原理，来龙去脉，让读者搞个通通透透<span style="font-family: 宋体; color: #333333; font-size: 14px; line-height: 26px; text-align: left;">（<span style="color: #cc00;">注意</span><span style="color: #9900;">，</span>本文中第二部分及第三部分的代码实现一的字符串下标i 从</span><span style="font-family: Arial; color: #333333; font-size: 14px; line-height: 26px; text-align: left;">0</span><span style="font-family: 宋体; color: #333333; font-size: 14px; line-height: 26px; text-align: left;">开始计算，其它部分如第三部分的代码实现二，第五部分，和第六部分的字符串下标i 皆是从1开始的）。</span></span></p><span style="font-family: 宋体;"></span><p>    在看本文之前，你心中如若对前缀和后缀这个两个概念有自己的理解，便最好了。有些东西比如此<span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法需要我们反复思考，反复求解才行。个人写的关于KMP算法的第二篇文章为：<a href="http://blog.csdn.net/v_JULY_v/archive/2011/06/15/6545192.aspx" shape="rect" style="text-align: left; color: #220000; line-height: 26px; font-family: Arial; font-size: 14px; text-decoration: none;" target="_blank">六（续）、从KMP算法一步一步谈到BM算法</a></span><span style="font-family: Arial;">；第一篇为：六、教你初步了解KMP算法、updated（文末链接）。ok</span><span style="font-family: 宋体;">，若有任何问题，恳请不吝指正。多谢。</span></p><h3><a name="t1" shape="rect"></a>第一部分、<span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法初解</span></h3><p><strong>1<span style="font-family: 宋体;">、</span>普通字符串匹配BF<span style="font-family: 宋体;">算法与</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法的时间复杂度比较</span></strong></p><p>    KMP<span style="font-family: 宋体;">算法是一种线性时间复杂的字符串匹配算法，它是对</span><span style="font-family: Arial;">BF</span><span style="font-family: 宋体;">算法（</span><span style="font-family: Arial;">Brute-Force</span><span style="font-family: 宋体;">，最基本的字符串匹配算法的）改进。对于给的原始串</span><span style="font-family: Arial;">S</span><span style="font-family: 宋体;">和模式串</span><span style="font-family: Arial;">P</span><span style="font-family: 宋体;">，需要从字符串</span><span style="font-family: Arial;">S</span><span style="font-family: 宋体;">中找到字符串</span><span style="font-family: Arial;">P</span><span style="font-family: 宋体;">出现的位置的索引。</span></p><blockquote style="margin: 0px 0px 0px 40px; padding: 0px;"><div><div><p>BF<span style="font-family: 宋体;">算法的时间复杂度</span><span style="font-family: Arial;">O(strlen(S) * strlen(T))</span><span style="font-family: 宋体;">，空间复杂度</span><span style="font-family: Arial;">O(1)</span><span style="font-family: 宋体;">。</span></p></div></div></blockquote><blockquote style="margin: 0px 0px 0px 40px; padding: 0px;"><div><div><p>KMP<span style="font-family: 宋体;">算法的时间复杂度</span><span style="font-family: Arial;">O(strlen(S) + strlen(T))</span><span style="font-family: 宋体;">，空间复杂度</span><span style="font-family: Arial;">O(strlen(T))</span><span style="font-family: 宋体;">。</span></p></div></div></blockquote><div><div><p><strong>2<span style="font-family: 宋体;">、</span><span style="font-family: Arial;">BF</span><span style="font-family: 宋体;">算法与</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法的区别</span></strong></p><p>    假设现在<span style="font-family: Arial;">S</span><span style="font-family: 宋体;">串匹配到</span><span style="font-family: Arial;">i</span><span style="font-family: 宋体;">位置，</span><span style="font-family: Arial;">T</span><span style="font-family: 宋体;">串匹配到</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">位置。那么总的来说，两种算法的主要区别在于失配的情况下，对</span><span style="font-family: Arial;"><img src="KMP算法详解_files/Image.gif" type="image/gif" alt="[j]"/> </span><span style="font-family: 宋体;">的值做的处理</span><span style="font-family: 宋体;">：</span></p><p>   BF<span style="font-family: 宋体;">算法中，如果当前字符匹配成功，即</span><span style="font-family: Arial;">s[i+j] == T[j]</span><span style="font-family: 宋体;">，令</span><span style="font-family: Arial;">j++</span><span style="font-family: 宋体;">，继续匹配下一个字符；如果失配，即</span><span style="font-family: Arial;">S[i + j] != T[j]</span><span style="font-family: 宋体;">，<strong>需要让</strong></span><strong><span style="font-family: Arial;">i++,</span><span style="font-family: 宋体;">并且</span><span style="font-family: Arial;">j</span>= 0</strong><span style="font-family: 宋体;">，即每次匹配失败的情况下，模式串</span><span style="font-family: Arial;">T</span><span style="font-family: 宋体;">相对于原始串</span><span style="font-family: Arial;">S</span><span style="font-family: 宋体;">向右移动了一位。</span></p><p>    而<span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法中，如果当前字符匹配成功，即</span><span style="font-family: Arial;">S[i]==T[j]</span><span style="font-family: 宋体;">，令</span><span style="font-family: Arial;">i++</span><span style="font-family: 宋体;">，</span><span style="font-family: Arial;">j++</span><span style="font-family: 宋体;">，继续匹配下一个字符；如果</span>匹配失败，即<span style="font-family: Arial;">S[i] != T[j]</span><span style="font-family: 宋体;">，需要保持</span><span style="font-family: Arial;">i</span><span style="font-family: 宋体;">不变，并且让</span><span style="font-family: Arial;">j = next[j]</span><span style="font-family: 宋体;">，这里</span><span style="font-family: Arial;">next[j] &lt;=j -1</span><span style="font-family: 宋体;">，即模式串</span><span style="font-family: Arial;">T</span><span style="font-family: 宋体;">相对于原始串</span><span style="font-family: Arial;">S</span><span style="font-family: 宋体;">向右移动了至少</span><span style="font-family: Arial;">1</span><span style="font-family: 宋体;">位</span><span style="font-family: Arial;">(</span><span style="font-family: 宋体;"><strong>移动的实际位数</strong></span><span style="font-family: Arial;"><strong>j - next[j]  &gt;=1</strong>),</span></p><p>    同时移动之后，<span style="text-decoration: underline;"><span style="font-family: Arial;">i</span><span style="font-family: 宋体;">之前的部分（即</span><span style="font-family: Arial;">S[i-j+1 ~ i-1]</span><span style="font-family: 宋体;">），和</span><span style="font-family: Arial;">j=next[j]</span><span style="font-family: 宋体;">之前的部分（即</span><span style="font-family: Arial;">T[0 ~ j-2]</span></span><span style="font-family: 宋体;"><span style="text-decoration: underline;">）仍然相等</span>。显然，相对于</span><span style="font-family: Arial;">BF</span><span style="font-family: 宋体;">算法来说，</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">移动更多的位数，起到了一个加速的作用！ </span><span style="font-family: Arial;">(</span><span style="font-family: 宋体;">失配的特殊情形，令</span><span style="font-family: Arial;">j=next[j]</span><span style="font-family: 宋体;">导致</span>j==0<span style="font-family: 宋体;">的时候，需要将</span><span style="font-family: Arial;">i ++</span>，否则此时没有移动模式串<span style="font-family: Arial;">)</span><span style="font-family: 宋体;">。</span><br clear="none"/></p><p><strong>3、BF<span style="font-family: 宋体;">算法为什么要回溯</span></strong></p></div></div><p>首先说一下为什么<span style="font-family: Arial;">BF</span><span style="font-family: 宋体;">算法要回溯。如下两字符串匹配（恰如上面所述：BF算法中，<span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">如果当前字符匹配成功，即</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">s[i+j] == T[j]</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">，令</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">j++</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">，继续匹配下一个字符</span>）：</span></p><p><span style="white-space: pre;"></span>      i+j<span style="font-family: 宋体;">（</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">随</span><span style="font-family: Arial;">T</span><span style="font-family: 宋体;">中的</span><span style="font-family: Arial;">j++</span><span style="font-family: 宋体;">变，而动）</span></p><p><span style="white-space: pre;"></span>S：aaa<span style="color: #cc0000;">a</span>cefghij</p><p>   <span style="white-space: pre;"></span>      j++</p><p><span style="white-space: pre;"></span>T：aaa<span style="color: #cc0000;">c</span> </p><p>如果不回溯的话就是从下一位开始比起：</p><p><span style="white-space: pre;"></span>aaaa<span style="color: #cc0000;">c</span>efghij</p><p><span style="white-space: pre;"></span>        <span style="color: #cc0000;">a</span>aac</p><p>看到上面红颜色的没，如果不回溯的话，那么从<span style="font-family: Arial;">a </span><span style="font-family: 宋体;">的下一位</span><span style="font-family: Arial;">c </span><span style="font-family: 宋体;">比起。然而下述这种情况就漏了（正确的做法当然是要回溯：<span style="font-family: 宋体; color: #333333; line-height: 26px; font-size: 14px;">如果失配，即</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">S[i + j] != T[j]</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">，<strong>需要让</strong></span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">i++,<span style="font-family: 宋体;">并且</span>j= 0</span>）：</span></p><p><span style="white-space: pre;"></span>a<span style="text-decoration: underline;">aaac</span>efghij</p><p><span style="white-space: pre;"></span>  <span style="color: #cc0000;">aaac</span></p><div><div><p>    所以，BF算法要回溯，其代码如下：</p><div><div><div><a href="http://blog.csdn.net/v_july_v/article/details/7041827#" shape="rect" title="view plain">view plain</a><br clear="none"/></div></div><ol start="1"><li><span><span>int</span><span> Index(SString S, SString T, </span><span>int</span><span> pos) {  </span></span></li><li><span>   <span>//返回T在S中第pos个字符之后的位置</span><span>  </span></span></li><li><span>   i=pos; j=1;k=0;  </span></li><li><span>  <span>while</span><span> ( i&lt; = S[0] &amp;&amp; j&lt; = T[0] ) {  </span></span></li><li><span>      <span>if</span><span> (S[i+k] = = T[j] ) {++k;  ++j;}   </span><span>//继续比较后续字符</span><span>  </span></span></li><li><span>      <span>else</span><span> {i=i+1;   j=1; k=0;}      </span><span>//指针回溯到 下一首位，重新开始</span><span>  </span></span></li><li><span>  }  </span></li><li><span>  <span>if</span><span>(j&gt;T[0]) </span><span>return</span><span> i;          </span><span>//子串结束，说明匹配成功</span><span>  </span></span></li><li><span>  <span>else</span><span> </span><span>return</span><span>  0;  </span></span></li><li><span>}<span>//Index</span><span>  </span></span></li></ol></div><p>  不过，也有特殊情况可以不回溯，如下：<br clear="none"/> <span style="white-space: pre;"></span>abcdefghij(<span style="font-family: 宋体;">主串</span><span style="font-family: Arial;">)</span><br clear="none"/> <span style="white-space: pre;"></span>abcdefg(<span style="font-family: 宋体;">模式串</span><span style="font-family: Arial;">)</span><br clear="none"/>   即(<span style="font-family: 宋体;">模式串</span><span style="font-family: Arial;">)</span><span style="font-family: 宋体;">没有相同的才不需要回溯。</span></p><p><br clear="none"/> <strong>4<span style="font-family: 宋体;">、</span><span style="font-family: Arial;">KMP </span><span style="font-family: 宋体;">算法思想</span></strong><br clear="none"/>     普通的字符串匹配算法必须要回溯。但回溯就影响了效率，回溯是由T串本身的性质决定的，是因为T串本身有前后'部分匹配'的性质。像上面所说如果主串为abcdef这样的，大没有回溯的必要。</p><p>    改进的地方也就是这里，我们从<span style="font-family: Arial;">T</span><span style="font-family: 宋体;">串本身出发，事先就找准了</span><span style="font-family: Arial;">T</span><span style="font-family: 宋体;">自身前后部分匹配的位置，那就可以改进算法。</span></p><p>    如果不用回溯，那模式串下一个位置从哪里开始呢？</p><p>    还是上面那个例子，<span style="font-family: Arial;">T(</span><span style="font-family: 宋体;">模式串</span><span style="font-family: Arial;">)</span><span style="font-family: 宋体;">为</span><span style="font-family: Arial;">ababc</span><span style="font-family: 宋体;">，如果</span><span style="font-family: Arial;">c</span><span style="font-family: 宋体;">失配，那就可以往前移到</span><span style="font-family: Arial;">aba</span><span style="font-family: 宋体;">最后一个</span><span style="font-family: Arial;">a</span><span style="font-family: 宋体;">的位置，像这样：</span></p></div></div><blockquote style="margin: 0px 0px 0px 40px; padding: 0px;"><div><div><p>...ababd...</p></div></div><div><div><p>   ababc</p></div></div><div><div><p>    -&gt;ababc</p></div></div></blockquote><div><div><p>这样<span style="font-family: Arial;">i</span><span style="font-family: 宋体;">不用回溯，</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">跳到前</span><span style="font-family: Arial;">2</span><span style="font-family: 宋体;">个位置，继续匹配的过程，这就是</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法所在。这个当</span><span style="font-family: Arial;">T[j]</span><span style="font-family: 宋体;">失配后，</span><strong>j <span style="font-family: 宋体;">应该往前跳的值就是</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">的</span><span style="font-family: Arial;">next</span><span style="font-family: 宋体;">值</span>，它是由<span style="font-family: Arial;">T</span><span style="font-family: 宋体;">串本身固有决定的，与</span><span style="font-family: Arial;">S</span><span style="font-family: 宋体;">串</span><span style="font-family: Arial;">(</span><span style="font-family: 宋体;">主串</span><span style="font-family: Arial;">)</span><span style="font-family: 宋体;">无关</span></strong>。</p><p><br clear="none"/> <strong>5、next<span style="font-family: 宋体;">数组的含义</span></strong></p><p>重点来了。下面解释一下next<span style="font-family: 宋体;">数组的含义</span>，这个也是<span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法中比较不好理解的一点。</span></p><p>  令原始串为<span style="font-family: Arial;">: S[i]</span><span style="font-family: 宋体;">，其中</span><span style="font-family: Arial;">0&lt;=i&lt;=n</span><span style="font-family: 宋体;">；模式串为</span><span style="font-family: Arial;">: T[j]</span><span style="font-family: 宋体;">，其中</span><span style="font-family: Arial;">0&lt;=j&lt;=m</span><span style="font-family: 宋体;">。</span></p><p>  假设目前匹配到如下位置</p><p style="text-align: left; color: #333333; font-family: Arial; font-size: 14px;">               S0,S1,S2,...,<span style="color: #33cc00;">Si-j,Si-j+1...............,Si-1</span>, <span style="color: #cc0000;">Si</span>, Si+1,....,Sn</p><p style="text-align: left; color: #333333; font-family: Arial; font-size: 14px;">                                   <span style="color: #33cc00;">T0,T1,.....................,Tj-1</span>, <span style="color: #cc0000;">Tj</span>, ..........</p><p>  S<span style="font-family: 宋体;">和</span><span style="font-family: Arial;">T</span><span style="font-family: 宋体;">的绿色部分匹配成功，恰好到</span><span style="font-family: Arial;">Si</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial;">Tj</span><span style="font-family: 宋体;">的时候失配，如果要保持</span><span style="font-family: Arial;">i</span><span style="font-family: 宋体;">不变，同时达到让模式串</span><span style="font-family: Arial;">T</span><span style="font-family: 宋体;">相对于原始串</span><span style="font-family: Arial;">S</span><span style="font-family: 宋体;">右移的话，可以更新</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">的值，让</span><span style="font-family: Arial;">Si</span><span style="font-family: 宋体;">和新的</span><span style="font-family: Arial;">Tj</span><span style="font-family: 宋体;">进行匹配，假设新的</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">用</span><span style="font-family: Arial;">next[j]</span><span style="font-family: 宋体;">表示，即让</span><span style="font-family: Arial;">Si</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial;">next[j]</span><span style="font-family: 宋体;">匹配，显然新的</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">值要小于之前的</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">值，模式串才会是右移的效果，也就是说应该有</span><span style="font-family: Arial;">next[j] &lt;= j -1</span><span style="font-family: 宋体;">。那新的</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">值也就是</span><span style="font-family: Arial;">next[j]</span><span style="font-family: 宋体;">应该是多少呢？我们观察如下的匹配：</span></p><p>      1)<span style="font-family: 宋体;">如果</span>模式串右移<span style="font-family: Arial;">1</span><span style="font-family: 宋体;">位（从简单的思考起，移动一位会怎么样）</span>，即<span style="font-family: Arial;">next[j] = j - 1</span><span style="font-family: 宋体;">， 即让蓝色的</span><span style="font-family: Arial;">Si</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial;">Tj-1</span><span style="font-family: 宋体;">匹配 </span><span style="font-family: Arial;">(</span><span style="font-family: 宋体;">注：省略号为未匹配部分</span><span style="font-family: Arial;">)</span></p><p style="text-align: left; color: #333333; font-family: Arial; font-size: 14px;">               S0,S1,S2,...,<span style="color: #33cc00;">Si-j,Si-j+1...............,Si-1</span>, <span style="color: #3366ff;">Si</span>, Si+1,....,Sn</p><p style="text-align: left; color: #333333; font-family: Arial; font-size: 14px;">                                   <span style="color: #33cc00;">T0,T1,.....................,Tj-1</span>, <span style="color: #cc0000;">Tj</span>, .......... (T的划线部分和S划线部分相等【1】)</p><p style="text-align: left; color: #333333; font-family: Arial; font-size: 14px;"><span style="color: #0cc22;">                                        <span style="color: #33cc00;"> T0,T1,.................Tj-2</span><span style="color: #055ff;">,</span></span><span style="color: #3366ff;">Tj-1</span><span style="color: #055ff;">, </span><span style="color: #ff00;">...</span>.... (移动后的T的划线部分和S的划线部分相等【2】)</p><p>        根据【<span style="font-family: Arial;">1</span><span style="font-family: 宋体;">】【</span><span style="font-family: Arial;">2</span><span style="font-family: 宋体;">】可以知道当</span><span style="font-family: Arial;">next[j] =j -1</span><span style="font-family: 宋体;">，即模式串右移一位的时候，有</span><span style="font-family: Arial;">T[0 ~ j-2] == T[1 ~ j-1]，</span><span style="font-family: 宋体;">而这两部分恰好是字符串</span><span style="font-family: Arial;">T[0 ~j-1]</span><span style="font-family: 宋体;">的前缀和后缀</span><span style="font-family: 宋体;">，也就是说</span><span style="font-family: Arial;">next[j]</span><span style="font-family: 宋体;">的值取决于模式串</span><span style="font-family: Arial;">T</span><span style="font-family: 宋体;">中</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">前面部分的前缀和后缀相等部分的长度（好好揣摩这两个关键字概念：前缀、后缀，或者再想想，我的上一篇文章，从</span><span style="font-family: Arial;">Trie</span><span style="font-family: 宋体;">树谈到后缀树中，后缀树的概念）。</span></p></div></div><p>      2)<span style="font-family: 宋体;">如果模式串右移</span><span style="font-family: Arial;">2</span><span style="font-family: 宋体;">位，即</span><span style="font-family: Arial;">next[j] = j - 2</span><span style="font-family: 宋体;">， 即让蓝色的</span><span style="font-family: Arial;">Si</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial;">Tj-2</span><span style="font-family: 宋体;">匹配     </span></p><p style="text-align: left; color: #333333; font-family: Arial; font-size: 14px;">               S0,S1,...,<span style="color: #33cc00;">Si-j,Si-j+1,Si-j+2...............,Si-1</span>, <span style="color: #3366ff;">Si</span>, Si+1,....,Sn</p><p style="text-align: left; color: #333333; font-family: Arial; font-size: 14px;">                                   <span style="color: #33cc00;">T0,T1,T2,.....................,Tj-1</span>, <span style="color: #cc0000;">Tj</span>, ..........(T的划线部分和S划线部分相等【3】)</p><p style="text-align: left; color: #333333; font-family: Arial; font-size: 14px;"><span style="color: #0cc22;">                                              <span style="color: #33cc00;"> T0,T1,...............,Tj-3</span>,<span style="color: #055ff;"><span style="color: #3366ff;">Tj-2</span>,.....</span></span>....(移动后的T的划线部分和S的划线部分相等【4】)</p><p>        同样根据【<span style="font-family: Arial;">3</span><span style="font-family: 宋体;">】【</span><span style="font-family: Arial;">4</span><span style="font-family: 宋体;">】可以知道当</span><span style="font-family: Arial;">next[j] =j -2</span><span style="font-family: 宋体;">，即模式串右移两位的时候，有</span><span style="font-family: Arial;">T[0 ~ j-3] == T[2 ~ j-1]</span><span style="font-family: 宋体;">。而这两部分也恰好是字符串</span><span style="font-family: Arial;">T[0 ~j-1]</span><span style="font-family: 宋体;">的前缀和后缀，也就是说</span>next[j]<span style="font-family: 宋体;">的值取决于模式串</span><span style="font-family: Arial;">T</span><span style="font-family: 宋体;">中</span><span style="font-family: Arial;">j</span><span style="font-family: 宋体;">前面部分的前缀和后缀相等部分的长度</span>。</p><p>     3)<span style="font-family: 宋体;">依次类推，可以得到如下结论：</span><strong>当发生失配的情况下，<span style="font-family: Arial;">j</span><span style="font-family: 宋体;">的新值</span><span style="font-family: Arial;">next[j]</span><span style="font-family: 宋体;">取决于模式串中</span><span style="font-family: Arial;">T[0 ~ j-1]</span><span style="font-family: 宋体;">中前缀和后缀相等部分的长度， 并且</span><span style="font-family: Arial;">next[j]</span><span style="font-family: 宋体;">恰好等于这个最大长度</span></strong>。</p><p>    为此，请再允许我引用上文中的一段原文：<span style="font-size: 24px;">“</span><span style="font-family: Arial; color: #333333; line-height: 26px; font-size: 14px;">KMP</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">算法中，如果当前字符匹配成功，即</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">S[i]==T[j]</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">，令</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">i++</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">，</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">j++</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">，继续匹配下一个字符；如果</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">匹配失败，即S[i] != T[j]</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">，需要保持</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">i</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">不变，并且让</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">j = next[j]</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">，这里</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">next[j] &lt;=j -1</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">，即模式串</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">T</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">相对于原始串</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">S</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">向右移动了至少</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">1</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">位</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">(</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;"><strong>移动的实际位数</strong></span><strong>j - next[j]  &gt;=1</strong><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">),</span></p><p style="text-align: left; color: #333333; line-height: 26px; font-family: Arial; font-size: 14px;">    同时移动之后，<span style="text-decoration: underline;">i<span style="font-family: 宋体;">之前的部分（即</span>S[i-j+1 ~ i-1]<span style="font-family: 宋体;">），和</span>j=next[j]<span style="font-family: 宋体;">之前的部分（即</span>T[0 ~ j-2]</span><span style="font-family: 宋体;"><span style="text-decoration: underline;">）仍然相等</span>。显然，<strong>相对于</strong></span><strong>BF<span style="font-family: 宋体;">算法来说，</span>KMP</strong><span style="font-family: 宋体;"><strong>移动更多的位数，起到了一个加速的作用</strong>！ </span>(<span style="font-family: 宋体;">失配的特殊情形，令</span>j=next[j]<span style="font-family: 宋体;">导致</span>j==0<span style="font-family: 宋体;">的时候，需要将</span>i ++，否则此时没有移动模式串)<span style="font-family: 宋体;">。”</span></p><p>    于此，也就不难理解了我的关于KMP算法的第二篇文章之中：<span style="font-size: 24px;">“</span><span style="font-family: Arial; color: #333333; line-height: 26px; font-size: 14px;">当匹配到S[i] != P[j]的时候有 S[i-j…i-1] = P[0…j-1]. 如果下面用j_next去匹配，则有P[0…j_next-1] = S[i-j_next…i-1] = P[j-j_next…j-1]。此过程如下图3-1所示。</span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 60px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt; vertical-align: baseline;"><span style="font-size: 13px;"><span style="font-family: 宋体;">  当匹配到</span><span style="font-family: Calibri;">S[i] != P[j]</span><span style="font-family: 宋体;">时，<span style="font-family: Verdana;">S[i-j…i-1] = P[0…j-1]</span>：</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 90px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt; vertical-align: baseline;"><span style="font-size: 13px;"><span style="font-family: Calibri;">S: 0 … </span><span style="text-decoration: underline;">i-j … i-1</span><span style="font-family: Calibri;"> i …</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 90px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt; vertical-align: baseline;"><span style="font-size: 13px;"><span style="font-family: Calibri;">P:       </span><span style="text-decoration: underline;">0 …   j-1</span><span style="font-family: Calibri;"> j …</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 60px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt; vertical-align: baseline;"><span style="font-size: 13px;"><span style="font-family: 宋体;"><span style="font-family: Verdana;"><span style="font-family: 宋体;">  如果下面用j_next去匹配，则有P[0…j_next-1] = S[i-j_next…i-1] = P[j-j_next…j-1]。<br clear="none"/> 所以在P中有如下匹配关系（获得这个匹配关系的意义是用来求next数组）</span></span></span><span style="font-family: 宋体;">：</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 90px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt; vertical-align: baseline;"><span style="font-size: 13px;"><span style="font-family: Calibri;">P: 0 … </span><span style="text-decoration: underline;">j-j_next  .…j-1_</span><span style="font-family: Calibri;">    …</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 90px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt; vertical-align: baseline;"><span style="font-size: 13px;"><span style="font-family: Calibri;">P:        </span><span style="text-decoration: underline;">0    … .j_next-1</span><span style="font-family: Calibri;"> …</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 60px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt; vertical-align: baseline;"><span style="font-size: 13px;"><span style="font-family: 宋体;">  所以，</span><span style="font-family: 宋体;">根据上面两个步骤，推出</span><span style="font-family: 宋体;">下一匹配位置</span><span style="font-family: Calibri;">j_next:</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 90px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt; vertical-align: baseline;"><span style="font-size: 13px;"><span style="font-family: Calibri;">S: 0 … i-j … </span> <span style="text-decoration: underline;">i-j_next …   i-1  </span><span style="font-family: Calibri;">  </span><span style="font-family: 宋体;">  </span><span style="font-family: Calibri;">i …</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 90px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 13px;"><span style="font-family: Calibri;">P:                   </span><span style="text-decoration: underline;">0   … <strong>j_next-1</strong></span><span style="font-family: Calibri;"> </span> <span style="font-family: 宋体;"></span><span style="font-family: Calibri;">j_next …</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; padding-left: 60px; font-family: Arial; font-size: 14px; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-family: Calibri; font-size: 12pt;">             <span style="color: #0080;"> 图3-1 求j-next（最大的值）的三个步骤</span></span></p><p style="text-align: left; color: #333333; line-height: 26px; font-family: Arial; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-size: 14px;">    下面，</span><strong>我们用变量k来代表求得的j_next的最大值</strong><span style="font-size: 14px;">，即k表示这S[i]、P[j]不匹配时P中下一个用来匹配的位置，使得</span><span style="text-decoration: underline;">P[0…k-1] = P[j-k…j-1]</span><span style="font-size: 14px;">，而我们要尽量找到这个k的最大值。</span><span style="font-family: Arial,Verdana,sans-serif; color: #000000; line-height: normal;"><span style="font-size: 24px;">”。</span></span></p><p>      根据上文的【1】与【2】的匹配情况，可得第二篇文章之中所谓的k=1（如aaaa的形式），根据上文的【3】与【4】的匹配情况，k=2（如abab的形式）。</p><p>     所以，归根究底，<span style="color: #cc0000;">KMP算法的本质</span>便是：针对待匹配的模式串的特点，判断它是否有重复的字符，从而找到它的前缀与后缀，进而求出相应的Next数组，最终根据Next数组而进行KMP匹配。接下来，进入本文的第二部分。</p><h3><a name="t2" shape="rect"></a>第二部分、<span style="font-family: Arial;">next</span><span style="font-family: 宋体;">数组求法的来龙去脉与</span><span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法的源码</span></h3><p>    本部分引自个人此前的关于<span style="font-family: Arial;">KMP</span><span style="font-family: 宋体;">算法的第二篇文章：六之续、由KMP算法谈到BM算法。前面，我们已经知道<span style="font-family: Arial; color: #333333; line-height: 26px; font-size: 14px;">即不能让P[j]=P[next[j]]成立成立。不能再出现上面那样的情况啊！</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">即不能有这种情况出现：P[3]=b，而竟也有P[next[3]]=P[1]=b</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">。</span></span></p><p><span style="font-family: 宋体;"><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">    正如在第二篇文章中，所提到的那样：“这里读者理解可能有困难的是因为文中，时而next，时而nextval，把他们的思维搞混乱了。其实next用于表达数组索引，而nextval专用于表达next数组索引下的具体各值，区别细微。至于文中说不允许P<img src="KMP算法详解_files/Image [1].gif" type="image/gif" alt="[j]"/>=P[next[j] ]出现，是因为已经有P<img src="KMP算法详解_files/Image [2].gif" type="image/gif" alt="[3]"/>=b与S<img src="KMP算法详解_files/Image [3].gif" type="image/gif" alt="[i]"/>匹配败，而P[next<img src="KMP算法详解_files/Image [4].gif" type="image/gif" alt="[3]"/>]=P1=b，若再拿P[1]=b去与S<img src="KMP算法详解_files/Image [5].gif" type="image/gif" alt="[i]"/>匹配则必败。”--<span style="font-family: 宋体;">六之续、由KMP算法谈到BM算法。</span></span></span></p><p><span style="font-family: 宋体;"><span style="text-align: left; color: #333333; line-height: 26px; font-family: Arial;"><span style="font-family: 宋体;"><span style="font-size: 14px;">   又恰恰如上文中所述：“</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">模式串</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">T</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">相对于原始串</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">S</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">向右移动了至少</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">1</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">位</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">(</span><span style="font-family: 宋体; color: #333333; text-align: left; line-height: 26px; font-size: 14px;"><strong>移动的实际位数</strong></span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">j - next[j]  &gt;=1</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">)</span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px;"><span style="font-size: 24px;">”</span></span><span style="font-family: Arial; color: #333333; text-align: left; line-height: 26px; font-size: 14px;">。</span></span></span></span></p><p><span style="font-family: 宋体;">    ok，求</span><span style="font-family: Arial;">next</span><span style="font-family: 宋体;">数组的</span><span style="font-family: Arial;">get_nextval</span><span style="font-family: 宋体;">函数正确代码如下：</span></p><div><div><div><div><a href="http://blog.csdn.net/v_july_v/article/details/7041827#" shape="rect" title="view plain">view plain</a><br clear="none"/></div></div><ol start="1"><li><span><span>//代码4-1  </span><span>  </span></span></li><li><span><span>//修正后的求next数组各值的函数代码  </span><span>  </span></span></li><li><span><span>void</span><span> get_nextval(</span><span>char</span><span> </span><span>const</span><span>* ptrn, </span><span>int</span><span> plen, </span><span>int</span><span>* nextval)    </span></span></li><li><span>{    </span></li><li><span>    <span>int</span><span> i = 0;     </span></span></li><li><span>    nextval[i] = -1;    </span></li><li><span>    <span>int</span><span> j = -1;    </span></span></li><li><span>    <span>while</span><span>( i &lt; plen-1 )    </span></span></li><li><span>    {    </span></li><li><span>        <span>if</span><span>( j == -1 || ptrn[i] == ptrn[j] )   </span><span>//循环的if部分  </span><span>  </span></span></li><li><span>        {    </span></li><li><span>            ++i;    </span></li><li><span>            ++j;    </span></li><li><span>            <span>//修正的地方就发生下面这4行  </span><span>  </span></span></li><li><span>            <span>if</span><span>( ptrn[i] != ptrn[j] ) </span><span>//++i，++j之后，再次判断ptrn[i]与ptrn[j]的关系  </span><span>  </span></span></li><li><span>                nextval[i] = j;      <span>//之前的错误解法就在于整个判断只有这一句。  </span><span>  </span></span></li><li><span>            <span>else</span><span>    </span></span></li><li><span>                nextval[i] = nextval[j];    </span></li><li><span>        }    </span></li><li><span>        <span>else</span><span>                                 </span><span>//循环的else部分  </span><span>  </span></span></li><li><span>            j = nextval[j];    </span></li><li><span>    }    </span></li><li><span>}    </span></li></ol></div></div><blockquote><p><span style="font-size: 13px;">    举个例子，举例说明下上述求next数组的方法。<br clear="none"/> S a b a b a b c<br clear="none"/> P a b a b c<br clear="none"/> S[4] != P[4]<br clear="none"/>     那么下一个和S[4]匹配的位置是k=2(也即P[next[4]])。此处的k=2也再次佐证了上文第3节开头处关于为了找到下一个匹配的位置时k的求 法。上面的主串与模式串开头4个字符都是“abab”，所以，匹配失效后下一个匹配的位置直接跳两步继续进行匹配。<br clear="none"/> S a b a b a b c<br clear="none"/> P      a b a b c<br clear="none"/> 匹配成功</span></p><p><span style="font-size: 13px;">P的next数组值分别为-1 0 -1 0 2</span></p><p><span style="font-size: 13px;">    next数组各值怎么求出来的呢?分以下五步：</span></p><ol><li><span style="font-size: 13px;">初始化：i=0，j=-1，<strong>nextval[0] = -1</strong>。<span style="font-family: Arial; color: #333333; line-height: 26px; font-size: 14px;">由于j == -1，进入上述循环的if部分，++i得i=1，++j得j=0，且ptrn[i] != ptrn[j]（即a！=b）），所以得到第二个next值即nextval[1] = 0；</span>；</span></li><li><span style="font-size: 13px;">i=1，j=0，进入循环esle部分，</span><span style="font-size: 13px;">j=nextval[j]=nextval[0]=-1；</span></li><li><span style="font-size: 13px;">进入循环的if部分，++i，++j，i=2，j=0，因为ptrn[i]=ptrn[j]=a,所以nextval[2]=nextval[0]=-1；</span></li><li><span style="font-size: 13px;">i=2, j=0, 由于ptrn[i]=ptrn[j],再次进入循环if部分，所以++i=3，++j=1,因为ptrn[i]=ptrn[j]=b,所以nextval[3]=nextval[1]=0；</span></li><li><span style="font-size: 13px;">i=3,j=1,由于ptrn[i]=ptrn[j]=b,所以++i=4，++j=2,退出循环。 </span></li></ol></blockquote><p>    这样上例中模式串的next数组各值最终应该为:</p><p><img height="104" src="http://hi.csdn.net/attachment/201106/14/8394323_1308075858HK8k.jpg" width="273"></img></p><p>       <span style="color: #333399;">     图4-1 正确的next数组各值<br clear="none"/> </span><strong>next数组求解的具体过程如下：<br clear="none"/> </strong>    初始化：nextval[0] = -1，我们得到第一个next值即-1.</p><p><img height="84" src="http://hi.csdn.net/attachment/201106/14/8394323_1308075858aNNR.jpg" width="277"></img></p><p>          <span style="color: #333399;">  图4-2 初始化第一个next值即-1</span></p><p>    i = 0，j = -1，由于j == -1，进入上述循环的if部分，++i得i=1，++j得j=0，且ptrn[i] != ptrn[j]（即a！=b）），所以得到第二个next值即nextval[1] = 0；</p><p><img height="95" src="http://hi.csdn.net/attachment/201106/14/8394323_1308075858mc76.jpg" width="288"></img></p><p>           <span style="color: #333399;">图4-3 第二个next值0</span></p><p>   上面我们已经得到，i= 1，j = 0，由于不满足条件j == -1 || ptrn[i] == ptrn[j]，所以进入循环的esle部分，得j = nextval[j] = -1；此时，仍满足循环条件，由于i = 1，j = -1，因为j == -1，再次进入循环的if部分，++i得i=2，++j得j=0，由于ptrn[i] == ptrn[j]（即ptrn[2]=ptrn[0]，也就是说第1个元素和第三个元素都是a），所以进入循环if部分内嵌的else部分，得到 nextval[2] = nextval[0] = -1；</p><p><img height="92" src="http://hi.csdn.net/attachment/201106/14/8394323_1308075858ljso.jpg" width="266"></img></p><p>   <span style="color: #333399;">      图4-4 第三个next数组元素值-1</span></p><p>    i = 2，j = 0，由于ptrn[i] == ptrn[j]，进入if部分，++i得i=3，++j得j=1，所以ptrn[i] == ptrn[j]（ptrn[3]==ptrn[1]，也就是说第2个元素和第4个元素都是b），所以进入循环if部分内嵌的else部分，得到 nextval[3] = nextval[1] = 0；</p><p><img height="96" src="http://hi.csdn.net/attachment/201106/14/8394323_13080758581C1S.jpg" width="266"></img></p><p>         <span style="color: #333399;">图4-5 第四个数组元素值0<br clear="none"/> </span>    如果你还是没有弄懂上述过程是怎么一回事，请现在拿出一张纸和一支笔出来，一步一步的画下上述过程。相信我，把图画出来了之后，你一定能明白它的。<br clear="none"/>     然后，我留一个问题给读者，为什么上述的next数组要那么求?有什么原理么?</p><p>    <span style="color: #cc0000;">提示</span>：我们从上述字符串abab 各字符的next值<span style="text-decoration: underline;">-1 0 -1 0</span>，可以看出来，根据求得的next数组值，偷用前缀、后缀的概念，一定可以判断出在abab之中，前缀和后缀相同，即都是ab，反过来，如果一个字符串的前缀和后缀相同，那么根据前缀和后缀依次求得的next各值也是相同的。</p><div><ul><li><strong><span style="font-size: 16px;"><span style="color: #8000;">5、利用求得的next数组各值运用Kmp算法</span></span></strong></li></ul></div><p>    Ok，next数组各值已经求得，万事俱备，东风也不欠了。接下来，咱们就要应用求得的next值，应用KMP算法来匹配字符串了。还记得KMP算法是怎么一回事吗?容我再次引用下之前的KMP算法的代码，如下：<br clear="none"/> <span style="font-family: monospace; font-size: 13px;"><span style="white-space: pre-wrap;"></span></span></p><div><div><div><a href="http://blog.csdn.net/v_july_v/article/details/7041827#" shape="rect" title="view plain">view plain</a><br clear="none"/></div></div><ol start="1"><li><span><span>//代码5-1  </span><span>  </span></span></li><li><span><span>//int kmp_seach(char const*, int, char const*, int, int const*, int pos)  KMP模式匹配函数  </span><span>  </span></span></li><li><span><span>//输入：src, slen主串  </span><span>  </span></span></li><li><span><span>//输入：patn, plen模式串  </span><span>  </span></span></li><li><span><span>//输入：nextval KMP算法中的next函数值数组  </span><span>  </span></span></li><li><span><span>int</span><span> kmp_search(</span><span>char</span><span> </span><span>const</span><span>* src, </span><span>int</span><span> slen, </span><span>char</span><span> </span><span>const</span><span>* patn, </span><span>int</span><span> plen, </span><span>int</span><span> </span><span>const</span><span>* nextval, </span><span>int</span><span> pos)    </span></span></li><li><span>{    </span></li><li><span>    <span>int</span><span> i = pos;    </span></span></li><li><span>    <span>int</span><span> j = 0;    </span></span></li><li><span>    <span>while</span><span> ( i &lt; slen &amp;&amp; j &lt; plen )    </span></span></li><li><span>    {    </span></li><li><span>        <span>if</span><span>( j == -1 || src[i] == patn[j] )    </span></span></li><li><span>        {    </span></li><li><span>            ++i;    </span></li><li><span>            ++j;    </span></li><li><span>        }    </span></li><li><span>        <span>else</span><span>    </span></span></li><li><span>        {    </span></li><li><span>            j = nextval[j];              </span></li><li><span>            <span>//当匹配失败的时候直接用p[j_next]与s[i]比较，  </span><span>  </span></span></li><li><span>            <span>//下面阐述怎么求这个值，即匹配失效后下一次匹配的位置  </span><span>  </span></span></li><li><span>        }    </span></li><li><span>    }    </span></li><li><span>    <span>if</span><span>( j &gt;= plen )    </span></span></li><li><span>        <span>return</span><span> i-plen;    </span></span></li><li><span>    <span>else</span><span>    </span></span></li><li><span>        <span>return</span><span> -1;    </span></span></li><li><span>}    </span></li></ol></div><p>我们上面已经求得的next值，如下：</p><p style="padding-left: 30px;"><img height="96" src="http://hi.csdn.net/attachment/201106/14/8394323_13080758581C1S.jpg" width="266"></img></p><p style="padding-left: 30px;">        <span style="color: #333399;">图5-1 求得的正确的next数组元素各值</span></p><p>    以下是匹配过程，分三步：<br clear="none"/>     第一步：主串和模式串如下，S[3]与P[3]匹配失败。</p><p><img height="159" src="http://hi.csdn.net/attachment/201106/14/8394323_130807585714lW.jpg" width="417"></img></p><p>               <span style="color: #333399;">图5-2 第一步，S[3]与P[3]匹配失败<br clear="none"/> </span>    第二步：S[3]保持不变，P的下一个匹配位置是P[next[3]]，而next[3]=0,所以P[next[3]]=P[0]，即P[0]与S[3]匹配。在P[0]与S[3]处匹配失败。</p><p><img height="176" src="http://hi.csdn.net/attachment/201106/14/8394323_13080758571390.jpg" width="495"></img></p><p>                <span style="color: #333399;">图5-3 第二步，在P[0]与S[3]处匹配失败</span></p><p>    第三步：与上文中第3小节末的情况一致。由于上述第三步中，P[0]与S[3]还是不匹配。此时i=3,j=nextval[0]=-1,由于满足条件 j==-1，所以进入循环的if部分,++i=4,++j=0,即主串指针下移一个位置，从P[0]与S[4]处开始匹配。最后j==plen，跳出循 环，输出结果i-plen=4(即字串第一次出现的位置），匹配成功，算法结束。</p><p><img height="167" src="http://hi.csdn.net/attachment/201106/14/8394323_1308075857e40u.jpg" width="451"></img></p><p>                <span style="color: #333399;">图5-4 第三步，匹配成功，算法结束<br clear="none"/> </span>    <span style="text-decoration: underline;">所以，综上，总结上述三步为</span>：</p><ol><li>开始匹配，直到P[3]！=S[3]，匹配失败；</li><li>nextval[3]=0，所以P[0]继续与S[3]匹配，再次匹配失败；</li><li>nextval[0]=-1，满足循环if部分条件j==-1，所以，++i，++j，主串指针下移一个位置，从P[0]与S[4]处开始匹配，最后j==plen，跳出循环，输出结果i-plen=4，算法结束。</li></ol><h3><a name="t3" shape="rect"></a>第三部分、KMP算法的两种实现</h3><p><strong>代码实现一：</strong>   </p><p>    根据上文中第二部分内容的解析，完整写出KMP算法的代码已经不是难事了，如下：</p><div><div><div><a href="http://blog.csdn.net/v_july_v/article/details/7041827#" shape="rect" title="view plain">view plain</a><br clear="none"/></div></div><ol start="1"><li><span><span>//copyright@2011 binghu and july</span><span>  </span></span></li><li><span><span>#include &quot;StdAfx.h&quot;</span><span>  </span></span></li><li><span><span>#include &lt;string&gt;</span><span>  </span></span></li><li><span><span>#include &lt;iostream&gt;</span><span>  </span></span></li><li><span><span>using</span><span> </span><span>namespace</span><span> std;  </span></span></li><li><span>  </span></li><li><span><span>//代码4-1  </span><span>  </span></span></li><li><span><span>//修正后的求next数组各值的函数代码  </span><span>  </span></span></li><li><span><span>void</span><span> get_nextval(</span><span>char</span><span> </span><span>const</span><span>* ptrn, </span><span>int</span><span> plen, </span><span>int</span><span>* nextval)    </span></span></li><li><span>{    </span></li><li><span>    <span>int</span><span> i = 0;  </span><span>//注，此处与下文的代码实现二不同的是，i是从0开始的（代码实现二i从1开始）   </span><span>  </span></span></li><li><span>    nextval[i] = -1;    </span></li><li><span>    <span>int</span><span> j = -1;    </span></span></li><li><span>    <span>while</span><span>( i &lt; plen-1 )    </span></span></li><li><span>    {    </span></li><li><span>        <span>if</span><span>( j == -1 || ptrn[i] == ptrn[j] )   </span><span>//循环的if部分  </span><span>  </span></span></li><li><span>        {    </span></li><li><span>            ++i;    </span></li><li><span>            ++j;    </span></li><li><span>            <span>//修正的地方就发生下面这4行  </span><span>  </span></span></li><li><span>            <span>if</span><span>( ptrn[i] != ptrn[j] ) </span><span>//++i，++j之后，再次判断ptrn[i]与ptrn[j]的关系  </span><span>  </span></span></li><li><span>                nextval[i] = j;      <span>//之前的错误解法就在于整个判断只有这一句。  </span><span>  </span></span></li><li><span>            <span>else</span><span>    </span></span></li><li><span>                nextval[i] = nextval[j];    </span></li><li><span>        }    </span></li><li><span>        <span>else</span><span>                                 </span><span>//循环的else部分  </span><span>  </span></span></li><li><span>            j = nextval[j];    </span></li><li><span>    }    </span></li><li><span>}    </span></li><li><span>  </span></li><li><span><span>void</span><span> print_progress(</span><span>char</span><span> </span><span>const</span><span>* src, </span><span>int</span><span> src_index, </span><span>char</span><span> </span><span>const</span><span>* pstr, </span><span>int</span><span> pstr_index)  </span></span></li><li><span>{  </span></li><li><span>    cout&lt;&lt;src_index&lt;&lt;<span>&quot;\t&quot;</span><span>&lt;&lt;src&lt;&lt;endl;  </span></span></li><li><span>    cout&lt;&lt;pstr_index&lt;&lt;<span>&quot;\t&quot;</span><span>;  </span></span></li><li><span>    <span>for</span><span>( </span><span>int</span><span> i = 0; i &lt; src_index-pstr_index; ++i )  </span></span></li><li><span>        cout&lt;&lt;<span>&quot; &quot;</span><span>;  </span></span></li><li><span>    cout&lt;&lt;pstr&lt;&lt;endl;  </span></li><li><span>    cout&lt;&lt;endl;  </span></li><li><span>}  </span></li><li><span>  </span></li><li><span><span>//代码5-1  </span><span>  </span></span></li><li><span><span>//int kmp_seach(char const*, int, char const*, int, int const*, int pos)  KMP模式匹配函数  </span><span>  </span></span></li><li><span><span>//输入：src, slen主串  </span><span>  </span></span></li><li><span><span>//输入：patn, plen模式串  </span><span>  </span></span></li><li><span><span>//输入：nextval KMP算法中的next函数值数组  </span><span>  </span></span></li><li><span><span>int</span><span> kmp_search(</span><span>char</span><span> </span><span>const</span><span>* src, </span><span>int</span><span> slen, </span><span>char</span><span> </span><span>const</span><span>* patn, </span><span>int</span><span> plen, </span><span>int</span><span> </span><span>const</span><span>* nextval, </span><span>int</span><span> pos)    </span></span></li><li><span>{    </span></li><li><span>    <span>int</span><span> i = pos;    </span></span></li><li><span>    <span>int</span><span> j = 0;    </span></span></li><li><span>    <span>while</span><span> ( i &lt; slen &amp;&amp; j &lt; plen )    </span></span></li><li><span>    {    </span></li><li><span>        <span>if</span><span>( j == -1 || src[i] == patn[j] )    </span></span></li><li><span>        {    </span></li><li><span>            ++i;    </span></li><li><span>            ++j;    </span></li><li><span>        }    </span></li><li><span>        <span>else</span><span>    </span></span></li><li><span>        {    </span></li><li><span>            j = nextval[j];              </span></li><li><span>            <span>//当匹配失败的时候直接用p[j_next]与s[i]比较，  </span><span>  </span></span></li><li><span>            <span>//下面阐述怎么求这个值，即匹配失效后下一次匹配的位置  </span><span>  </span></span></li><li><span>        }    </span></li><li><span>    }    </span></li><li><span>    <span>if</span><span>( j &gt;= plen )    </span></span></li><li><span>        <span>return</span><span> i-plen;    </span></span></li><li><span>    <span>else</span><span>    </span></span></li><li><span>        <span>return</span><span> -1;    </span></span></li><li><span>}    </span></li><li><span>  </span></li><li><span><span>int</span><span>   main()  </span></span></li><li><span>{  </span></li><li><span>    std::string src = <span>&quot;aabcabcebafabcabceabcaefabcacdabcab&quot;</span><span>;  </span></span></li><li><span>    std::string prn = <span>&quot;abac&quot;</span><span>;  </span></span></li><li><span>  </span></li><li><span>    <span>int</span><span>* nextval = </span><span>new</span><span> </span><span>int</span><span>[prn.size()];  </span></span></li><li><span>    <span>//int* next = new int[prn.size()];</span><span>  </span></span></li><li><span>    get_nextval(prn.data(), prn.size(), nextval);  </span></li><li><span>    <span>//get_next(prn.data(), prn.size(), next);</span><span>  </span></span></li><li><span>  </span></li><li><span>    <span>for</span><span>( </span><span>int</span><span> i = 0; i &lt; prn.size(); ++i )  </span></span></li><li><span>        cout&lt;&lt;nextval[i]&lt;&lt;<span>&quot;\t&quot;</span><span>;  </span></span></li><li><span>    cout&lt;&lt;endl;  </span></li><li><span>      </span></li><li><span>    cout&lt;&lt;<span>&quot;result sub str: &quot;</span><span>&lt;&lt;src.substr( kmp_search(src.data(), src.size(), prn.data(), prn.size(), nextval, 0) )&lt;&lt;endl;  </span></span></li><li><span>    system(<span>&quot;pause&quot;</span><span>);  </span></span></li><li><span>  </span></li><li><span>    <span>delete</span><span>[] nextval;  </span></span></li><li><span>    <span>return</span><span> 0;  </span></span></li><li><span>}   </span></li></ol></div><p>    运行结果，如下图所示：</p><p><img src="http://hi.csdn.net/attachment/201112/8/0_1323314920mQh4.gif"></img></p><p><strong>代码实现二</strong>：</p><p>     再给出代码实现二之前，让我们再次<span style="font-size: 18px;">回顾下关于KMP算法的第一篇文章中的部分内容</span>：</p><p><span style="font-size: 24px;"><strong>“</strong></span><span style="font-size: 13px;"><span style="color: #8000;"><span style="font-size: 16px;">第二节、KMP算法</span></span></span></p><p><strong><span style="color: black;"><span style="font-family: Calibri;">2.1、 </span> </span><span style="font-family: 宋体; color: black;">覆盖函数</span><span style="color: black;"><span style="font-family: Calibri;">(overlay_function)</span></span></strong></p><p>    覆盖函数所表征的是pattern本身的性质，可以让为其表征的是pattern从左开始的所有连续子串的自我覆盖程度。比如如下的字串，abaabcaba</p><blockquote dir="ltr" style="margin-right: 0px;"><blockquote dir="ltr" style="margin-right: 0px;"><blockquote dir="ltr" style="margin-right: 0px;"><blockquote dir="ltr" style="margin-right: 0px;"><p><img height="294" src="http://hi.csdn.net/attachment/201101/1/8394323_1293874441hilM.jpg" width="236"></img></p></blockquote></blockquote></blockquote></blockquote><p>    可能上面的图令读者理解起来还是不那么清晰易懂，其实很简单，针对字符串abaabcaba</p><p><span style="color: #3333ff;">a（-1） </span><span style="color: #3333ff;">b（-1）</span><span style="color: #3333ff;">a（0）</span><span style="color: #3333ff;"> </span><span style="color: #3333ff;">a</span><span style="color: #3333ff; white-space: pre;">（</span><span style="color: #3333ff;">0</span><span style="color: #3333ff; white-space: pre;">）</span><span style="color: #3333ff;"> </span><span style="color: #3333ff;">b</span><span style="color: #3333ff; white-space: pre;">（1） </span><span style="color: #3333ff;">c（-1）</span><span style="color: #3333ff;"> </span><span style="color: #3333ff;">a（0）</span><span style="color: #3333ff;"> b（1）</span><span style="color: #3333ff;">a（2）</span></p><p><span style="color: #3333ff;"><span style="color: #3333ff;">解释：</span></span></p><ol><li><span style="color: #3333ff;">初始化为-1 </span><span style="color: #3333ff;"> </span></li><li><span style="color: #3333ff;">b与a不同为-1   </span></li><li><span style="color: #3333ff;">与第一个字符a相同为0   </span></li><li><span style="color: #3333ff;">还是a为0   </span></li><li><span style="color: #3333ff;">后缀ab与前缀ab两个字符相同为1 </span></li><li><span style="color: #3333ff;">前面并无前缀c为-1  </span></li><li><span style="color: #3333ff;">与第一个字符同为0  </span></li><li><span style="color: #3333ff;">后缀ab前缀ab为1 </span></li><li><span style="color: #3333ff;">前缀aba后缀aba为2</span></li></ol><p>    由于计数是从0始的，因此覆盖函数的值为0说明有1个匹配，对于从0还是从来开始计数是偏好问题，具体请自行调整，其中-1表示没有覆盖，那么何为覆盖呢，下面比较数学的来看一下定义，比如对于序列</p><div style="layout-grid: both loose 15.6pt none;"><p style="padding-left: 30px; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-family: 宋体; font-size: 22pt;">  a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">0</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">1...</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j-1 </span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j</span></p><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;"></span><p style="padding-left: 30px; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;"><span style="font-family: 宋体;">要找到一个</span><span lang="EN-US"><span style="font-family: Calibri;">k,</span></span><span style="font-family: 宋体;">使它满足</span></span></p><p style="padding-left: 30px; margin-top: 0pt; margin-bottom: 0pt;"><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">  a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">0</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">1...</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">k-1</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">k=</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j-k</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j-k+1...</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j-1</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j</span></p></div><p>    而没有更大的k满足这个条件，就是说要找到尽可能大k,使pattern前k字符与后k字符相匹配，k要尽可能的大，原因是如果有比较大的k存在。</p><p>    但若我们选择较小的满足条件的k，那么当失配时，我们就会使pattern向右移动的位置变大，而较少的移动位置是存在匹配的，这样我们就会把可能匹配的结果丢失。比如下面的序列，</p><blockquote dir="ltr" style="margin-right: 0px;"><p><img height="122" src="http://hi.csdn.net/attachment/201101/1/8394323_1293874442uL1u.jpg" width="537"></img></p></blockquote><p>    在红色部分失配，正确的结果是k=1的情况，把pattern右移4位，如果选择k=0,右移5位则会产生错误。计算这个overlay函数的方法可以采用递推，可以想象如果对于pattern的前j个字符，如果覆盖函数值为k</p><p style="margin-top: 0pt; margin-bottom: 0pt;"><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">    a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">0</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">1...</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">k-1</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">k=</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j-k</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j-k+1...</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j-1</span><span style="font-family: '宋体'; font-size: 22pt; font-weight: normal;">a</span><span style="font-family: '宋体'; font-size: 10.5pt; font-weight: normal;">j</span><br clear="none"/> 则对于pattern的前j+1序列字符，则有如下可能<br clear="none"/>     ⑴     pattern[k+1]==pattern[j+1] 此时overlay(j+1)=k+1=overlay(j)+1<br clear="none"/>     ⑵     pattern[k+1]≠pattern[j+1] 此时只能在pattern前k+1个子符组所的子串中找到相应的overlay函数，h=overlay(k),如果此时 pattern[h+1]==pattern[j+1],则overlay(j+1)=h+1否则重复(2)过程.</p><p style="margin-top: 0pt; margin-bottom: 0pt;">下面给出一段计算覆盖函数的代码：</p><div><div><div><a href="http://blog.csdn.net/v_july_v/article/details/7041827#" shape="rect" title="view plain">view plain</a><br clear="none"/></div></div><ol start="1"><li><span><span>//copyright@ staurman</span><span>  </span></span></li><li><span><span>//updated@2011 July</span><span>  </span></span></li><li><span><span>#include &quot;StdAfx.h&quot;</span><span>  </span></span></li><li><span><span>#include&lt;iostream&gt;</span><span>  </span></span></li><li><span><span>#include&lt;string&gt;</span><span>  </span></span></li><li><span><span>using</span><span> </span><span>namespace</span><span> std;  </span></span></li><li><span>  </span></li><li><span><span>//solve to the next array</span><span>  </span></span></li><li><span><span>void</span><span> compute_overlay(</span><span>const</span><span> string&amp; pattern)  </span></span></li><li><span>{  </span></li><li><span>    <span>const</span><span> </span><span>int</span><span> pattern_length = pattern.size();  </span></span></li><li><span>    <span>int</span><span> *overlay_function = </span><span>new</span><span> </span><span>int</span><span>[pattern_length];  </span></span></li><li><span>    <span>int</span><span> index;  </span></span></li><li><span>    overlay_function[0] = -1;  </span></li><li><span>    <span>for</span><span>(</span><span>int</span><span> i=1;i&lt;pattern_length;++i)      </span></span></li><li><span>        <span>//注，与上文代码段一不同的是，此处i是从1开始的，所以，下文中运用俩种方法求出来的next数组各值会有所不同</span><span>  </span></span></li><li><span>    {  </span></li><li><span>        index = overlay_function[i-1];  </span></li><li><span>        <span>//store previous fail position k to index;</span><span>  </span></span></li><li><span>  </span></li><li><span>        <span>while</span><span>(index&gt;=0 &amp;&amp; pattern[i]!=pattern[index+1])  </span></span></li><li><span>        {  </span></li><li><span>            index = overlay_function[index];  </span></li><li><span>        }  </span></li><li><span>        <span>if</span><span>(pattern[i]==pattern[index+1])  </span></span></li><li><span>        {  </span></li><li><span>            overlay_function[i] = index + 1;    </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            overlay_function[i] = -1;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    <span>for</span><span>(</span><span>int</span><span> i=0;i&lt;pattern_length;++i)  </span></span></li><li><span>    {  </span></li><li><span>        cout&lt;&lt;overlay_function[i]&lt;&lt;endl;  </span></li><li><span>    }  </span></li><li><span>    <span>delete</span><span>[] overlay_function;  </span></span></li><li><span>}  </span></li><li><span>  </span></li><li><span><span>//abaabcaba</span><span>  </span></span></li><li><span><span>int</span><span> main()  </span></span></li><li><span>{  </span></li><li><span>    string pattern = <span>&quot;abaabcaba&quot;</span><span>;  </span></span></li><li><span>    compute_overlay(pattern);  </span></li><li><span>    system(<span>&quot;pause&quot;</span><span>);  </span></span></li><li><span>    <span>return</span><span> 0;  </span></span></li><li><span>}  </span></li></ol></div><p><strong>    </strong>运行结果如下所示：</p><p><img src="http://hi.csdn.net/attachment/201112/9/0_1323398212crbf.gif"></img></p><p><strong>2.2、kmp算法<br clear="none"/> </strong>     有了覆盖函数，那么实现kmp算法就是很简单的了，我们的原则还是从左向右匹配，但是当失配发生时，我们不用把target_index向回移 动，target_index前面已经匹配过的部分在pattern自身就能体现出来，只要动pattern_index就可以了。</p><p><span style="color: #00ff;">当发生在j长度失配时，只要把pattern向右移动j-overlay(j)长度就可以了。</span></p><p>     如果失配时pattern_index==0，相当于pattern第一个字符就不匹配，这时就应该把target_index加1，向右移动1位就可以了。</p><p>    ok，下图就是KMP算法的过程（红色即是采用KMP算法的执行过程）：</p><blockquote dir="ltr" style="margin-right: 0px;"><p><img height="587" src="http://hi.csdn.net/attachment/201101/1/8394323_12938727418BHQ.jpg" width="602"></img></p></blockquote><p><span style="font-size: 13px;">    （另一作者saturnman发现，在上述KMP匹配过程图中，index=8和index=11处画错了。还有，anaven也早已发现，index=3处也画错了。非常感谢。但图已无法修改，见谅）</span></p><p>KMP 算法可在O（n+m）时间内完成全部的串的模式匹配工作。<strong><span style="font-size: 24px;">”</span></strong></p><p>    OK，下面此前写的关于KMP算法的第一篇文章中的源码：</p><div><div><div><a href="http://blog.csdn.net/v_july_v/article/details/7041827#" shape="rect" title="view plain">view plain</a><br clear="none"/></div></div><ol start="1"><li><span><span>//copyright@ saturnman</span><span>  </span></span></li><li><span><span>//updated@ 2011 July</span><span>  </span></span></li><li><span><span>#include &quot;stdafx.h&quot;</span><span>  </span></span></li><li><span><span>#include&lt;iostream&gt;</span><span>  </span></span></li><li><span><span>#include&lt;string&gt;</span><span>  </span></span></li><li><span><span>#include &lt;vector&gt;</span><span>  </span></span></li><li><span><span>using</span><span> </span><span>namespace</span><span> std;  </span></span></li><li><span>  </span></li><li><span><span>int</span><span> kmp_find(</span><span>const</span><span> string&amp; target,</span><span>const</span><span> string&amp; pattern)  </span></span></li><li><span>{  </span></li><li><span>    <span>const</span><span> </span><span>int</span><span> target_length=target.size();  </span></span></li><li><span>    <span>const</span><span> </span><span>int</span><span> pattern_length=pattern.size();  </span></span></li><li><span>    <span>int</span><span>* overlay_value=</span><span>new</span><span> </span><span>int</span><span>[pattern_length];  </span></span></li><li><span>    overlay_value[0]=-1;        <span>//remember:next array's first number was -1.</span><span>  </span></span></li><li><span>    <span>int</span><span> index=0;  </span></span></li><li><span>  </span></li><li><span>    <span>//next array</span><span>  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i=1;i&lt;pattern_length;++i)  </span></span></li><li><span>        <span>//注，此处的i是从1开始的</span><span>  </span></span></li><li><span>    {  </span></li><li><span>        index=overlay_value[i-1];  </span></li><li><span>        <span>while</span><span> (index&gt;=0 &amp;&amp; pattern[index+1]!=pattern[i])  </span><span>//remember:!=</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            index=overlay_value[index];  </span></li><li><span>        }  </span></li><li><span>        <span>if</span><span>(pattern[index+1] == pattern[i])  </span></span></li><li><span>        {  </span></li><li><span>            overlay_value[i]=index+1;  </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            overlay_value[i]=-1;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>//mach algorithm start</span><span>  </span></span></li><li><span>    <span>int</span><span> pattern_index=0;  </span></span></li><li><span>    <span>int</span><span> target_index=0;  </span></span></li><li><span>    <span>while</span><span> (pattern_index&lt;pattern_length &amp;&amp; target_index&lt;target_length)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (target[target_index] == pattern[pattern_index])  </span></span></li><li><span>        {  </span></li><li><span>            ++target_index;  </span></li><li><span>            ++pattern_index;  </span></li><li><span>        }   </span></li><li><span>        <span>else</span><span> </span><span>if</span><span>(pattern_index==0)  </span></span></li><li><span>        {  </span></li><li><span>            ++target_index;  </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            pattern_index=overlay_value[pattern_index-1]+1;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    <span>if</span><span> (pattern_index==pattern_length)  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span> target_index-pattern_index;  </span></span></li><li><span>    }   </span></li><li><span>    <span>else</span><span>  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span> -1;  </span></span></li><li><span>    }  </span></li><li><span>    <span>delete</span><span> [] overlay_value;  </span></span></li><li><span>}  </span></li><li><span>  </span></li><li><span><span>int</span><span> main()  </span></span></li><li><span>{  </span></li><li><span>    string sourc=<span>&quot;ababc&quot;</span><span>;  </span></span></li><li><span>    string pattern=<span>&quot;abc&quot;</span><span>;  </span></span></li><li><span>    cout&lt;&lt;kmp_find(sourc,pattern)&lt;&lt;endl;  </span></li><li><span>    system(<span>&quot;pause&quot;</span><span>);  </span></span></li><li><span>    <span>return</span><span> 0;  </span></span></li><li><span>}  </span></li></ol></div><p>    由于是abc跟ababc匹配，那么将返回匹配的位置“2”，运行结果如所示：</p><p><img src="http://hi.csdn.net/attachment/201112/9/0_1323418497xll5.gif"></img></p><h3><a name="t4" shape="rect"></a>第四部分、测试</h3><p>    针对上文中第三部分的两段代码测试了下，纠结了，两种求next数组的方法对同一个字符串求next数组各值，得到的结果竟然不一样，如下二图所示：</p><p>    1、两种方法对字符串<strong>abab</strong>求next数组各值比较：<img src="http://hi.csdn.net/attachment/201112/9/0_1323415780EZsh.gif"></img></p><p>    2、两种对字符串<strong>abaabcaba</strong>求next数组各值比较：<img src="http://hi.csdn.net/attachment/201112/9/0_1323414665F40E.gif"></img></p><p>    为何会这样呢，其实很简单，上文中已经有所说明了，<span style="color: #990000;">代码实现一的i 是从0开始的，代码实现二的i 是从1开始的</span>。但从最终的运行结果来看，暂时还是以代码实现段二为准。</p><h3><a name="t5" shape="rect"></a>第五部分、KMP完整准确源码</h3><p>    求next数组各值的方法为：</p><div><div><div><a href="http://blog.csdn.net/v_july_v/article/details/7041827#" shape="rect" title="view plain">view plain</a><br clear="none"/></div></div><ol start="1"><li><span><span>//copyright@ staurman</span><span>  </span></span></li><li><span><span>//updated@2011 July</span><span>  </span></span></li><li><span><span>#include &quot;StdAfx.h&quot;</span><span>  </span></span></li><li><span><span>#include&lt;iostream&gt;</span><span>  </span></span></li><li><span><span>#include&lt;string&gt;</span><span>  </span></span></li><li><span><span>using</span><span> </span><span>namespace</span><span> std;  </span></span></li><li><span>  </span></li><li><span><span>//solve to the next array</span><span>  </span></span></li><li><span><span>void</span><span> compute_overlay(</span><span>const</span><span> string&amp; pattern)  </span></span></li><li><span>{  </span></li><li><span>    <span>const</span><span> </span><span>int</span><span> pattern_length = pattern.size();  </span></span></li><li><span>    <span>int</span><span> *overlay_function = </span><span>new</span><span> </span><span>int</span><span>[pattern_length];  </span></span></li><li><span>    <span>int</span><span> index;  </span></span></li><li><span>    overlay_function[0] = -1;  </span></li><li><span>    <span>for</span><span>(</span><span>int</span><span> i=1;i&lt;pattern_length;++i)  </span></span></li><li><span>    {  </span></li><li><span>        index = overlay_function[i-1];  </span></li><li><span>        <span>//store previous fail position k to index;</span><span>  </span></span></li><li><span>  </span></li><li><span>        <span>while</span><span>(index&gt;=0 &amp;&amp; pattern[i]!=pattern[index+1])  </span></span></li><li><span>        {  </span></li><li><span>            index = overlay_function[index];  </span></li><li><span>        }  </span></li><li><span>        <span>if</span><span>(pattern[i]==pattern[index+1])  </span></span></li><li><span>        {  </span></li><li><span>            overlay_function[i] = index + 1;    </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            overlay_function[i] = -1;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    <span>for</span><span>(</span><span>int</span><span> i=0;i&lt;pattern_length;++i)  </span></span></li><li><span>    {  </span></li><li><span>        cout&lt;&lt;overlay_function[i]&lt;&lt;endl;  </span></li><li><span>    }  </span></li><li><span>    <span>delete</span><span>[] overlay_function;  </span></span></li><li><span>}  </span></li><li><span>  </span></li><li><span><span>//abaabcaba</span><span>  </span></span></li><li><span><span>int</span><span> main()  </span></span></li><li><span>{  </span></li><li><span>    string pattern = <span>&quot;abaabcaba&quot;</span><span>;  </span></span></li><li><span>    compute_overlay(pattern);  </span></li><li><span>    system(<span>&quot;pause&quot;</span><span>);  </span></span></li><li><span>    <span>return</span><span> 0;  </span></span></li><li><span>}  </span></li></ol></div><p>    运行结果入下图所示：<span style="font-size: 24px;">abab的next数组各值是-1，-1,0,1，而非本文第二部分所述的-1,0，-1,0</span>。为什么呢？难道是搬石头砸了自己的脚？</p><p>    NO，上文第四部分末已经详细说明，上处代码i 从0开始，本文第二部分代码i 从1开始。</p><p><img src="http://hi.csdn.net/attachment/201112/9/0_13234174252zC2.gif"></img></p><p>    KMP算法完整源码，如下：</p><div><div><div><a href="http://blog.csdn.net/v_july_v/article/details/7041827#" shape="rect" title="view plain">view plain</a><br clear="none"/></div></div><ol start="1"><li><span><span>//copyright@ saturnman</span><span>  </span></span></li><li><span><span>//updated@ 2011 July</span><span>  </span></span></li><li><span><span>#include &quot;stdafx.h&quot;</span><span>  </span></span></li><li><span><span>#include&lt;iostream&gt;</span><span>  </span></span></li><li><span><span>#include&lt;string&gt;</span><span>  </span></span></li><li><span><span>#include &lt;vector&gt;</span><span>  </span></span></li><li><span><span>using</span><span> </span><span>namespace</span><span> std;  </span></span></li><li><span>  </span></li><li><span><span>int</span><span> kmp_find(</span><span>const</span><span> string&amp; target,</span><span>const</span><span> string&amp; pattern)  </span></span></li><li><span>{  </span></li><li><span>    <span>const</span><span> </span><span>int</span><span> target_length=target.size();  </span></span></li><li><span>    <span>const</span><span> </span><span>int</span><span> pattern_length=pattern.size();  </span></span></li><li><span>    <span>int</span><span>* overlay_value=</span><span>new</span><span> </span><span>int</span><span>[pattern_length];  </span></span></li><li><span>    overlay_value[0]=-1;        <span>//remember:next array's first number was -1.</span><span>  </span></span></li><li><span>    <span>int</span><span> index=0;  </span></span></li><li><span>  </span></li><li><span>    <span>//next array</span><span>  </span></span></li><li><span>    <span>for</span><span> (</span><span>int</span><span> i=1;i&lt;pattern_length;++i)  </span></span></li><li><span>        <span>//注，此处的i是从1开始的</span><span>  </span></span></li><li><span>    {  </span></li><li><span>        index=overlay_value[i-1];  </span></li><li><span>        <span>while</span><span> (index&gt;=0 &amp;&amp; pattern[index+1]!=pattern[i])    </span></span></li><li><span>        {  </span></li><li><span>            index=overlay_value[index];  </span></li><li><span>        }  </span></li><li><span>        <span>if</span><span>(pattern[index+1] == pattern[i])  </span></span></li><li><span>        {  </span></li><li><span>            overlay_value[i]=index+1;  </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            overlay_value[i]=-1;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span>//mach algorithm start</span><span>  </span></span></li><li><span>    <span>int</span><span> pattern_index=0;  </span></span></li><li><span>    <span>int</span><span> target_index=0;  </span></span></li><li><span>    <span>while</span><span> (pattern_index&lt;pattern_length &amp;&amp; target_index&lt;target_length)  </span></span></li><li><span>    {  </span></li><li><span>        <span>if</span><span> (target[target_index] == pattern[pattern_index])  </span></span></li><li><span>        {  </span></li><li><span>            ++target_index;  </span></li><li><span>            ++pattern_index;  </span></li><li><span>        }   </span></li><li><span>        <span>else</span><span> </span><span>if</span><span>(pattern_index==0)  </span></span></li><li><span>        {  </span></li><li><span>            ++target_index;  </span></li><li><span>        }  </span></li><li><span>        <span>else</span><span>  </span></span></li><li><span>        {  </span></li><li><span>            pattern_index=overlay_value[pattern_index-1]+1;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>    <span>if</span><span> (pattern_index==pattern_length)  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span> target_index-pattern_index;  </span></span></li><li><span>    }   </span></li><li><span>    <span>else</span><span>  </span></span></li><li><span>    {  </span></li><li><span>        <span>return</span><span> -1;  </span></span></li><li><span>    }  </span></li><li><span>    <span>delete</span><span> [] overlay_value;  </span></span></li><li><span>}  </span></li><li><span>  </span></li><li><span><span>int</span><span> main()  </span></span></li><li><span>{  </span></li><li><span>    string sourc=<span>&quot;ababc&quot;</span><span>;  </span></span></li><li><span>    string pattern=<span>&quot;abc&quot;</span><span>;  </span></span></li><li><span>    cout&lt;&lt;kmp_find(sourc,pattern)&lt;&lt;endl;  </span></li><li><span>    system(<span>&quot;pause&quot;</span><span>);  </span></span></li><li><span>    <span>return</span><span> 0;  </span></span></li><li><span>}  </span></li></ol></div><p><strong>    </strong>运行结果如下：</p><p><img src="http://hi.csdn.net/attachment/201112/9/0_13234207304Rm0.gif"></img></p><h3><a name="t6" shape="rect"></a>第六部分、一眼看出字符串的next数组各值</h3><p>    上文已经用程序求出了一个字符串的next数组各值，接下来，稍稍演示下，如何一眼大致判断出next数组各值，以及初步判断某个程序求出的next数组各值是不是正确的。有一点务必注意：<span style="color: #990000;">下文中的代码全部采取代码实现二，即i是从1开始的</span>。</p><ul><li>1、对字符串aba求next数组各值，各位可以先猜猜，-1，...，aba中，a初始化为-1，第二个字符b与a不同也为-1，最后一个字符和第一个字符都是a，所以，我猜其next数组各值应该是-1，-1,0，结果也不出所料，如下图所示：</li></ul><p><img src="http://hi.csdn.net/attachment/201112/9/0_1323421403lIU8.gif"></img></p><ul><li>2、字符串“abab”呢，不用猜了，我已经看出来了，当然上文中代码实现一和代码实现二都已经求出来了。如果i 是1开始的话，那么next数组各值将如代码实现二所运行的那样，将是：-1，-1,0,1；</li><li>3、字符串“<span style="font-family: Arial; color: #333333; font-size: 14px; line-height: 26px;">abaabcaba”呢，next数组如上第三部分代码实现二所述，为-1，-1,0,0,1，-1,0,1,2；</span></li><li>4、字符串“abcdab”呢，next数组各值将是-1，-1，-1，-1,0,1；</li><li>5、字符串“abcdabc”呢，next数组各值将是-1，-1，-1，-1,0,1,2；</li><li>6、字符串“abcdabcd”呢，那么next数组各值将是-1，-1，-1，-1,0，1,2,3；</li></ul><p><img src="http://hi.csdn.net/attachment/201112/9/0_13234227806AQ4.gif"></img></p><p>    怎么样，看出规律来了没？呵呵，可以用上述第五部分中求next数组的方法自个多试探几次，相信，很快，你也会跟我一样，不用计算，一眼便能看出某个字符 串的next数组各值了。如此便恭喜你，理解了next数组的求法，KMP算法也就算是真真正正彻彻底底的理解了。完。</p><h3><a name="t7" shape="rect"></a>相关链接</h3><ol><li>KMP之第二篇文章：<a href="http://blog.csdn.net/v_JULY_v/archive/2011/06/15/6545192.aspx" shape="rect" style="text-align: left; color: #220000; line-height: 26px; font-family: Arial; font-size: 14px; text-decoration: none;" target="_blank">六（续）、从KMP算法一步一步谈到BM算法</a>。</li><li>KMP之第一篇文章：<a href="http://blog.csdn.net/v_JULY_v/archive/2011/01/01/6111565.aspx" shape="rect" target="_blank">六、教你初步了解KMP算法、updated</a>。</li></ol><h3><a name="t8" shape="rect"></a>后记 </h3><div>     相信，看过此文后，无论是谁，都一定可以把KMP算法搞懂了（但万一还是有读者没有搞懂，那怎么办呢？还有最后一个办法：把<span style="color: #cc00;">本文打印下来，再仔细琢磨</span>。如果是真真正正想彻底弄懂某一个东西，那么必须付出些代价。但万一要是打印下来了却还是没有弄懂呢？那来北京找我吧，我手把手教你。祝好运）。</div><div>    在结束全文之前，谈两点感悟：</div><div><ol><li>语言-&gt;数据结构-&gt;算法：语言是基础，够啃一辈子，基本的常见的数据结构得了如指掌，最后才是算法。除了算法之外，有更多更重要且 更值得学习的东西（最重要的是，学习如何编程）。切勿盲目跟风，找准自己的兴趣点，和领域才是关键。这跟选择职位、与领域并持久做下去，比选择公司更重要 一样。选择学什么东西不重要，重要的是你的兴趣。</li><li>修订这篇文章之时，个人接触KMP都有一年了，学算法也刚好快一年。想想阿，我弄一个 KMP，弄了近一年了，到今天才算是真正彻底理解其思想，可想而知，当初创造这个算法的k、m、p三人是何等不易。我想，有不少读者是因为我的出现而想学 算法的，但不可急功近利，切勿妄想算法速成。早已说过，学算法先修心。<br clear="none"/></li></ol></div><div>     OK，文中有关任何问题或错误，烦请不吝赐教与指正。谢谢，完。</div><div>    July、二零一一年十二月五日中午。</div></div></div>
</div></body></html> 