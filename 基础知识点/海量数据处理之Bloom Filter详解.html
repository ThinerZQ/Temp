<html>
<head>
  <title>海量数据处理之Bloom Filter详解</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1080"/>
<h1>海量数据处理之Bloom Filter详解</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><h3>一、什么是Bloom Filter</h3><p><span style="font-size:16px"><span style="font-family:Times New Roman">    Bloom Filter</span>是一种空间效率很高的随机数据结构，它的</span><span style="font-size: 16px;">原理是，<span style="font-family:Microsoft YaHei;">当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，把它们置为1</span>。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检索元素一定不在；如果都是1，则被检索元素很可能在。这就是布隆过滤器的基本思想。</span></p><p><span style="font-size: 16px;"><span style="font-family:Times New Roman">    但Bloom Filter</span>的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（<span style="font-family:Times New Roman">false positive</span>）。因此，<span style="font-family:Times New Roman">Bloom Filter</span>不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，<span style="font-family:Times New Roman">Bloom Filter</span>通过极少的错误换取了存储空间的极大节省。</span></p><p><span style="font-size:16px">    有人可能想知道它的中文叫法，倒是有被译作称布隆过滤器。该不该译，译的是否恰当，由诸君品之。下文之中，如果有诸多公式不慎理解，也无碍，只作稍稍了解即可。</span></p><h4>1.1、集合表示和元素查询</h4><p><span style="font-size:16px">    下面我们具体来看<span style="font-family:Times New Roman">Bloom Filter</span>是如何用位数组表示集合的。初始状态时，<span style="font-family:Times New Roman">Bloom Filter</span>是一个包含<span style="font-family:Times New Roman">m</span>位的位数组，每一位都置为<span style="font-family:Times New Roman">0</span>。</span></p><p align="center"><span style="font-size:16px"><img src="海量数据处理之Bloom Filter详解_files/Image.jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></span></p><p><span style="font-size:16px">    为了表达<span style="font-family:Times New Roman">S={x<sub>1</sub>, x<sub>2</sub>,…,x<sub>n</sub>}</span>这样一个<span style="font-family:Times New Roman">n</span>个元素的集合，<span style="font-family:Times New Roman">Bloom Filter</span>使用<span style="font-family:Times New Roman">k</span>个相互独立的哈希函数（<span style="font-family:Times New Roman">Hash Function</span>），它们分别将集合中的每个元素映射到<span style="font-family:Times New Roman">{1,…,m}</span>的范围中。对任意一个元素<span style="font-family:Times New Roman">x</span>，第<span style="font-family:Times New Roman">i</span>个哈希函数映射的位置<span style="font-family:Times New Roman">h<sub>i</sub>(x)</span>就会被置为<span style="font-family:Times New Roman">1</span>（<span style="font-family:Times New Roman">1</span>≤<span style="font-family:Times New Roman">i</span>≤<span style="font-family:Times New Roman">k</span>）。注意，如果一个位置多次被置为<span style="font-family:Times New Roman">1</span>，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，<span style="font-family:Times New Roman">k=3</span>，且有两个哈希函数选中同一个位置（从左边数第五位，即第二个“1“处）。</span><span style="font-size:16px">   </span></p><p align="center"><img src="海量数据处理之Bloom Filter详解_files/Image [1].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></p><p><span style="font-family:Times New Roman; font-size:16px"> </span></p><p><span style="font-size:16px">    在判断<span style="font-family:Times New Roman">y</span>是否属于这个集合时，我们对<span style="font-family:Times New Roman">y</span>应用<span style="font-family:Times New Roman">k</span>次哈希函数，如果所有<span style="font-family:Times New Roman">h<sub>i</sub>(y)</span>的位置都是<span style="font-family:Times New Roman">1</span>（<span style="font-family:Times New Roman">1</span>≤<span style="font-family:Times New Roman">i</span>≤<span style="font-family:Times New Roman">k</span>），那么我们就认为<span style="font-family:Times New Roman">y</span>是集合中的元素，否则就认为<span style="font-family:Times New Roman">y</span>不是集合中的元素。下图中<span style="font-family:Times New Roman">y<sub>1</sub></span>就不是集合中的元素（因为y1有一处指向了“0”位）。<span style="font-family:Times New Roman">y<sub>2</sub></span>或者属于这个集合，或者刚好是一个<span style="font-family:Times New Roman">false positive</span>。</span></p><p align="center"><span style="font-size:16px"><img src="海量数据处理之Bloom Filter详解_files/Image [2].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></span></p><h4>1.2、错误率估计</h4><p><span style="font-size:16px">    前面我们已经提到了，<span style="font-family:Times New Roman">Bloom Filter</span>在判断一个元素是否属于它表示的集合时会有一定的错误率（<span style="font-family:Times New Roman">false positive rate</span>），下面我们就来估计错误率的大小。在估计之前为了简化模型，我们假设<span style="font-family:Times New Roman">kn&lt;m</span>且各个哈希函数是完全随机的。当集合<span style="font-family:Times New Roman">S={x<sub>1</sub>, x<sub>2</sub>,…,x<sub>n</sub>}</span>的所有元素都被<span style="font-family:Times New Roman">k</span>个哈希函数映射到<span style="font-family:Times New Roman">m</span>位的位数组中时，这个位数组中某一位还是<span style="font-family:Times New Roman">0</span>的概率是：</span></p><p align="center"><span style="font-size:16px"><img src="海量数据处理之Bloom Filter详解_files/Image [3].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></span></p><p><span style="font-size:16px">    其中<span style="font-family:Times New Roman">1/m</span>表示任意一个哈希函数选中这一位的概率（前提是哈希函数是完全随机的），<span style="font-family:Times New Roman">(1-1/m)</span>表示哈希一次没有选中这一位的概率。要把<span style="font-family:Times New Roman">S</span>完全映射到位数组中，需要做<span style="font-family:Times New Roman">kn</span>次哈希。某一位还是<span style="font-family:Times New Roman">0</span>意味着<span style="font-family:Times New Roman">kn</span>次哈希都没有选中它，因此这个概率就是（<span style="font-family:Times New Roman">1-1/m</span>）的<span style="font-family:Times New Roman">kn</span>次方。令<span style="font-family:Times New Roman">p = e<sup>-kn/m</sup></span>是为了简化运算，这里用到了计算e时常用的近似：</span></p><p align="center"><span style="font-size:16px"><img src="海量数据处理之Bloom Filter详解_files/Image [4].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></span></p><p align="center"> </p><p><span style="font-size:16px">令ρ为位数组中<span style="font-family:Times New Roman">0</span>的比例，则ρ的数学期望E(ρ)= <span style="font-family:Times New Roman">p’</span>。在ρ已知的情况下，要求的错误率（<span style="font-family:Times New Roman">false positive rate</span>）为：</span></p><p align="center"><span style="font-size:16px"><img src="海量数据处理之Bloom Filter详解_files/Image [5].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></span></p><p><span style="font-size:16px"><span style="font-family:Times New Roman">(1-</span>ρ)为位数组中<span style="font-family:Times New Roman">1</span>的比例，<span style="font-family:Times New Roman">(1-</span>ρ)<sup>k</sup>就表示<span style="font-family:Times New Roman">k</span>次哈希都刚好选中<span style="font-family:Times New Roman">1</span>的区域，即<span style="font-family:Times New Roman">false positive rate</span>。上式中第二步近似在前面已经提到了，现在来看第一步近似。<span style="font-family:Times New Roman">p’</span>只是ρ的数学期望，在实际中ρ的值有可能偏离它的数学期望值。<span style="font-family:Times New Roman">M. Mitzenmacher</span>已经证明<sup><span style="font-family:Times New Roman">[2]</span></sup> ，位数组中0的比例非常集中地分布在它的数学期望值的附近。因此，第一步的近似得以成立。分别将<span style="font-family:Times New Roman">p</span>和<span style="font-family:Times New Roman">p’</span>代入上式中，得：</span></p><p><span style="font-size:16px">   </span></p><p align="center"><img src="海量数据处理之Bloom Filter详解_files/Image [6].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></p><p align="center"><img src="海量数据处理之Bloom Filter详解_files/Image [7].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></p><p><span style="font-size:16px">相比<span style="font-family:Times New Roman">p’</span>和<span style="font-family:Times New Roman">f’</span>，使用<span style="font-family:Times New Roman">p</span>和<span style="font-family:Times New Roman">f</span>通常在分析中更为方便。</span></p><h4>1.3、最优的哈希函数个数</h4><p><span style="font-size:16px">    既然<span style="font-family:Times New Roman">Bloom Filter</span>要靠多个哈希函数将集合映射到位数组中，那么应该选择几个哈希函数才能使元素查询时的错误率降到最低呢？这里有两个互斥的理由：如果哈希函数的个数多，那么在对一个不属于集合的元素进行查询时得到<span style="font-family:Times New Roman">0</span>的概率就大；但另一方面，如果哈希函数的个数少，那么位数组中的<span style="font-family:Times New Roman">0</span>就多。为了得到最优的哈希函数个数，我们需要根据上一小节中的错误率公式进行计算。</span></p><p><span style="font-size:16px">    先用<span style="font-family:Times New Roman">p</span>和<span style="font-family:Times New Roman">f</span>进行计算。注意到<span style="font-family:Times New Roman">f = exp(k ln(1 − e<sup>−kn/m</sup>))</span>，我们令<span style="font-family:Times New Roman">g = k ln(1 − e<sup>−kn/m</sup>)</span>，只要让<span style="font-family:Times New Roman">g</span>取到最小，<span style="font-family:Times New Roman">f</span>自然也取到最小。由于<span style="font-family:Times New Roman">p = e<sup>-kn/m</sup></span>，我们可以将<span style="font-family:Times New Roman">g</span>写成</span></p><p align="center"><span style="font-size:16px"><img src="海量数据处理之Bloom Filter详解_files/Image [8].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></span></p><p><span style="font-size:16px">    根据对称性法则可以很容易看出当<span style="font-family:Times New Roman">p = 1/2</span>，也就是<span style="font-family:Times New Roman">k = ln2· (m/n)</span>时，<span style="font-family:Times New Roman">g</span>取得最小值。在这种情况下，最小错误率<span style="font-family:Times New Roman">f</span>等于<span style="font-family:Times New Roman">(1/2)<sup>k</sup></span>≈ <span style="font-family:Times New Roman">(0.6185)<sup>m/n</sup></span>。另外，注意到p是位数组中某一位仍是0的概率，所以<span style="font-family:Times New Roman">p = 1/2</span><span style="font-family:Times New Roman">对应着位数组中0和1各一半。换句话说，要想保持错误率低，最好让位数组有一半还空着。</span></span></p><p><span style="font-size:16px">    需要强调的一点是，<span style="font-family:Times New Roman">p = 1/2</span>时错误率最小这个结果并不依赖于近似值<span style="font-family:Times New Roman">p</span>和<span style="font-family:Times New Roman">f</span>。同样对于<span style="font-family:Times New Roman">f’ = exp(k ln(1 − (1 − 1/m)<sup>kn</sup>))</span>，<span style="font-family:Times New Roman">g’ = k ln(1 − (1 − 1/m)<sup>kn</sup>)</span>，<span style="font-family:Times New Roman">p’ = (1 − 1/m)<sup>kn</sup></span>，我们可以将<span style="font-family:Times New Roman">g’</span>写成</span></p><p align="center"><span style="font-size:16px"><img src="海量数据处理之Bloom Filter详解_files/Image [9].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></span></p><p><span style="font-size:16px">同样根据对称性法则可以得到当<span style="font-family:Times New Roman">p’ = 1/2</span>时，<span style="font-family:Times New Roman">g’</span>取得最小值。</span></p><h4>1.4、位数组的大小</h4><p><span style="font-size:16px">    下面我们来看看，在不超过一定错误率的情况下，<span style="font-family:Times New Roman">Bloom Filter</span>至少需要多少位才能表示全集中任意<span style="font-family:Times New Roman">n</span>个元素的集合。假设全集中共有<span style="font-family:Times New Roman">u</span>个元素，允许的最大错误率为<span style="font-family:Times New Roman">є</span>，下面我们来求位数组的位数<span style="font-family:Times New Roman">m</span>。</span></p><p><span style="font-size:16px">    假设<span style="font-family:Times New Roman">X</span>为全集中任取<span style="font-family:Times New Roman">n</span>个元素的集合，<span style="font-family:Times New Roman">F(X)</span>是表示<span style="font-family:Times New Roman">X</span>的位数组。那么对于集合<span style="font-family:Times New Roman">X</span>中任意一个元素<span style="font-family:Times New Roman">x</span>，在<span style="font-family:Times New Roman">s = F(X)</span>中查询<span style="font-family:Times New Roman">x</span>都能得到肯定的结果，即<span style="font-family:Times New Roman">s</span>能够接受<span style="font-family:Times New Roman">x</span>。显然，由于<span style="font-family:Times New Roman">Bloom Filter</span>引入了错误，<span style="font-family:Times New Roman">s</span>能够接受的不仅仅是<span style="font-family:Times New Roman">X</span>中的元素，它还能够<span style="font-family:Times New Roman">є (u - n)</span>个<span style="font-family:Times New Roman">false positive</span>。因此，对于一个确定的位数组来说，它能够接受总共<span style="font-family:Times New Roman">n + є (u - n)</span>个元素。在<span style="font-family:Times New Roman">n + є (u - n)</span>个元素中，<span style="font-family:Times New Roman">s</span>真正表示的只有其中<span style="font-family:Times New Roman">n</span>个，所以一个确定的位数组可以表示</span></p><p align="center"><span style="font-size:16px"><img src="海量数据处理之Bloom Filter详解_files/Image [10].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></span></p><p><span style="font-size:16px">个集合。<span style="font-family:Times New Roman">m</span>位的位数组共有<span style="font-family:Times New Roman">2<sup>m</sup></span>个不同的组合，进而可以推出，<span style="font-family:Times New Roman">m</span>位的位数组可以表示</span></p><p><span style="font-size:16px">   </span></p><p align="center"><img src="海量数据处理之Bloom Filter详解_files/Image [11].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></p><p><span style="font-size:16px">个集合。全集中<span style="font-family:Times New Roman">n</span>个元素的集合总共有</span></p><p><span style="font-size:16px">   </span></p><p align="center"><img src="海量数据处理之Bloom Filter详解_files/Image [12].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></p><p><span style="font-size:16px">个，因此要让<span style="font-family:Times New Roman">m</span>位的位数组能够表示所有<span style="font-family:Times New Roman">n</span>个元素的集合，必须有</span></p><p><span style="font-size:16px">   </span></p><p align="center"><img src="海量数据处理之Bloom Filter详解_files/Image [13].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></p><p><span style="font-size:16px">即：</span></p><p><span style="font-size:16px">   </span></p><p align="center"><img src="海量数据处理之Bloom Filter详解_files/Image [14].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></p><p><span style="font-size:16px">上式中的近似前提是<span style="font-family:Times New Roman">n</span>和<span style="font-family:Times New Roman">єu</span>相比很小，这也是实际情况中常常发生的。根据上式，我们得出结论：在错误率不大于<span style="font-family:Times New Roman">є</span>的情况下，<span style="font-family:Times New Roman">m</span>至少要等于<span style="font-family:Times New Roman">n log<sub>2</sub>(1/є)</span>才能表示任意<span style="font-family:Times New Roman">n</span>个元素的集合。</span></p><p> </p><p><span style="font-size:16px">上一小节中我们曾算出当<span style="font-family:Times New Roman">k = ln2· (m/n)</span>时错误率<span style="font-family:Times New Roman">f</span>最小，这时<span style="font-family:Times New Roman">f = (1/2)<sup>k</sup>= (1/2)<sup>mln2 / n</sup></span>。现在令<span style="font-family:Times New Roman">f</span>≤<span style="font-family:Times New Roman">є</span>，可以推出</span></p><p align="center"><span style="font-size:16px"><img src="海量数据处理之Bloom Filter详解_files/Image [15].jpg" type="image/jpeg" style="cursor: default;cursor: default;"/></span></p><p><span style="font-size:16px">这个结果比前面我们算得的下界<span style="font-family:Times New Roman">n log<sub>2</sub>(1/є)</span>大了<span style="font-family:Times New Roman">log<sub>2</sub>e</span>≈ <span style="font-family:Times New Roman">1.44</span>倍。这说明在哈希函数的个数取到最优时，要让错误率不超过<span style="font-family:Times New Roman">є</span>，<span style="font-family:Times New Roman">m</span>至少需要取到最小值的<span style="font-family:Times New Roman">1.44</span>倍。</span></p><h4>1.5、概括</h4><p><span style="font-size:16px">    在计算机科学中，我们常常会碰到时间换空间或者空间换时间的情况，即为了达到某一个方面的最优而牺牲另一个方面。<span style="font-family:Times New Roman">Bloom Filter</span>在时间空间这两个因素之外又引入了另一个因素：错误率。在使用<span style="font-family:Times New Roman">Bloom Filter</span>判断一个元素是否属于某个集合时，会有一定的错误率。也就是说，有可能把不属于这个集合的元素误认为属于这个集合（<span style="font-family:Times New Roman">False Positive</span>），但不会把属于这个集合的元素误认为不属于这个集合（<span style="font-family:Times New Roman">False Negative</span>）。在增加了错误率这个因素之后，<span style="font-family:Times New Roman">Bloom Filter</span>通过允许少量的错误来节省大量的存储空间。</span></p><p><span style="font-size:16px">    自从<span style="font-family:Times New Roman">Burton Bloom</span>在<span style="font-family:Times New Roman">70</span>年代提出<span style="font-family:Times New Roman">Bloom Filter</span>之后，<span style="font-family:Times New Roman">Bloom Filter</span>就被广泛用于拼写检查和数据库系统中。近一二十年，伴随着网络的普及和发展，<span style="font-family:Times New Roman">Bloom Filter</span>在网络领域获得了新生，各种<span style="font-family:Times New Roman">Bloom Filter</span>变种和新的应用不断出现。可以预见，随着网络应用的不断深入，新的变种和应用将会继续出现，<span style="font-family:Times New Roman">Bloom Filter</span>必将获得更大的发展。</span></p><h3>二、适用范围</h3><p><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;">    可以用来实现数据字典，进行数据的判重，或者集合求交集 </span></span></p><h3>三、基本原理及要点</h3><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;">    对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显 这 个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。 </span></span></div><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;"><br/></span></span></div><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;">    还有一个比较重要的问题，如 何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)*(m/n)时错误率最小。在错误率不大于E的情况 下，m至少要等于n*lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应 该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。 </span></span></div><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;"><br/></span></span></div><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;">举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。 </span></span></div><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;"><br/></span></span></div><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;">    注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。 </span></span></div><div> </div><h3>四、扩展</h3><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;">    Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。 </span></span></div><div> </div><h3>五、问题实例</h3><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;">    给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？ </span></span></div><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;"><br/></span></span></div><div><span style="font-size:14px"><span style="font-family:&apos;Courier New&apos;">根 据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。 现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。 </span></span></div></div>
</div></body></html> 